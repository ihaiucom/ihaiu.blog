!
function(t) {
    var e;
    "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window: "undefined" != typeof global ? e = global: "undefined" != typeof self && (e = self), e.p2 = t())
} (function() {
    return function t(e, i, s) {
        function n(o, a) {
            if (!i[o]) {
                if (!e[o]) {
                    var h = "function" == typeof require && require;
                    if (!a && h) return h(o, !0);
                    if (r) return r(o, !0);
                    throw new Error("Cannot find module '" + o + "'")
                }
                var l = i[o] = {
                    exports: {}
                };
                e[o][0].call(l.exports,
                function(t) {
                    return n(e[o][1][t] || t)
                },
                l, l.exports, t, e, i, s)
            }
            return i[o].exports
        }
        for (var r = "function" == typeof require && require,
        o = 0; o < s.length; o++) n(s[o]);
        return n
    } ({
        1 : [function(t, e, i) {
            function s() {}
            var n = t("./Scalar");
            e.exports = s,
            s.lineInt = function(t, e, i) {
                i = i || 0;
                var s, r, o, a, h, l, c, u = [0, 0];
                return s = t[1][1] - t[0][1],
                r = t[0][0] - t[1][0],
                o = s * t[0][0] + r * t[0][1],
                a = e[1][1] - e[0][1],
                h = e[0][0] - e[1][0],
                l = a * e[0][0] + h * e[0][1],
                c = s * h - a * r,
                n.eq(c, 0, i) || (u[0] = (h * o - r * l) / c, u[1] = (s * l - a * o) / c),
                u
            },
            s.segmentsIntersect = function(t, e, i, s) {
                var n = e[0] - t[0],
                r = e[1] - t[1],
                o = s[0] - i[0],
                a = s[1] - i[1];
                if (o * r - a * n == 0) return ! 1;
                var h = (n * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * n),
                l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - o * r);
                return h >= 0 && h <= 1 && l >= 0 && l <= 1
            }
        },
        {
            "./Scalar": 4
        }],
        2 : [function(t, e, i) {
            function s() {}
            e.exports = s,
            s.area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            },
            s.left = function(t, e, i) {
                return s.area(t, e, i) > 0
            },
            s.leftOn = function(t, e, i) {
                return s.area(t, e, i) >= 0
            },
            s.right = function(t, e, i) {
                return s.area(t, e, i) < 0
            },
            s.rightOn = function(t, e, i) {
                return s.area(t, e, i) <= 0
            };
            var n = [],
            r = [];
            s.collinear = function(t, e, i, o) {
                if (o) {
                    var a = n,
                    h = r;
                    a[0] = e[0] - t[0],
                    a[1] = e[1] - t[1],
                    h[0] = i[0] - e[0],
                    h[1] = i[1] - e[1];
                    var l = a[0] * h[0] + a[1] * h[1],
                    c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                    u = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
                    return Math.acos(l / (c * u)) < o
                }
                return 0 == s.area(t, e, i)
            },
            s.sqdist = function(t, e) {
                var i = e[0] - t[0],
                s = e[1] - t[1];
                return i * i + s * s
            }
        },
        {}],
        3 : [function(t, e, i) {
            function s() {
                this.vertices = []
            }
            function n(t, e, i, s, n) {
                n = n || 0;
                var r = e[1] - t[1],
                o = t[0] - e[0],
                h = r * t[0] + o * t[1],
                l = s[1] - i[1],
                c = i[0] - s[0],
                u = l * i[0] + c * i[1],
                d = r * c - l * o;
                return a.eq(d, 0, n) ? [0, 0] : [(c * h - o * u) / d, (r * u - l * h) / d]
            }
            var r = t("./Line"),
            o = t("./Point"),
            a = t("./Scalar");
            e.exports = s,
            s.prototype.at = function(t) {
                var e = this.vertices,
                i = e.length;
                return e[t < 0 ? t % i + i: t % i]
            },
            s.prototype.first = function() {
                return this.vertices[0]
            },
            s.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            },
            s.prototype.clear = function() {
                this.vertices.length = 0
            },
            s.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var s = e; s < i; s++) this.vertices.push(t.vertices[s])
            },
            s.prototype.makeCCW = function() {
                for (var t = 0,
                e = this.vertices,
                i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                o.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            },
            s.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            },
            s.prototype.isReflex = function(t) {
                return o.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var h = [],
            l = [];
            s.prototype.canSee = function(t, e) {
                var i, s, n = h,
                a = l;
                if (o.leftOn(this.at(t + 1), this.at(t), this.at(e)) && o.rightOn(this.at(t - 1), this.at(t), this.at(e))) return ! 1;
                s = o.sqdist(this.at(t), this.at(e));
                for (var c = 0; c !== this.vertices.length; ++c) if ((c + 1) % this.vertices.length !== t && c !== t && o.leftOn(this.at(t), this.at(e), this.at(c + 1)) && o.rightOn(this.at(t), this.at(e), this.at(c)) && (n[0] = this.at(t), n[1] = this.at(e), a[0] = this.at(c), a[1] = this.at(c + 1), i = r.lineInt(n, a), o.sqdist(this.at(t), i) < s)) return ! 1;
                return ! 0
            },
            s.prototype.copy = function(t, e, i) {
                var n = i || new s;
                if (n.clear(), t < e) for (r = t; r <= e; r++) n.vertices.push(this.vertices[r]);
                else {
                    for (r = 0; r <= e; r++) n.vertices.push(this.vertices[r]);
                    for (var r = t; r < this.vertices.length; r++) n.vertices.push(this.vertices[r])
                }
                return n
            },
            s.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], n = new s, r = Number.MAX_VALUE, o = 0; o < this.vertices.length; ++o) if (this.isReflex(o)) for (var a = 0; a < this.vertices.length; ++a) if (this.canSee(o, a)) {
                    e = this.copy(o, a, n).getCutEdges(),
                    i = this.copy(a, o, n).getCutEdges();
                    for (var h = 0; h < i.length; h++) e.push(i[h]);
                    e.length < r && (t = e, r = e.length, t.push([this.at(o), this.at(a)]))
                }
                return t
            },
            s.prototype.decomp = function() {
                var t = this.getCutEdges();
                return t.length > 0 ? this.slice(t) : [this]
            },
            s.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++) for (var s = t[i], n = 0; n < e.length; n++) {
                        var r = e[n].slice(s);
                        if (r) {
                            e.splice(n, 1),
                            e.push(r[0], r[1]);
                            break
                        }
                    }
                    return e
                }
                s = t,
                i = this.vertices.indexOf(s[0]),
                n = this.vertices.indexOf(s[1]);
                return - 1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)]
            },
            s.prototype.isSimple = function() {
                for (var t = this.vertices,
                e = 0; e < t.length - 1; e++) for (var i = 0; i < e - 1; i++) if (r.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return ! 1;
                for (e = 1; e < t.length - 2; e++) if (r.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return ! 1;
                return ! 0
            },
            s.prototype.quickDecomp = function(t, e, i, r, a, h) {
                a = a || 100,
                h = h || 0,
                r = r || 25,
                t = void 0 !== t ? t: [],
                e = e || [],
                i = i || [];
                var l = [0, 0],
                c = [0, 0],
                u = [0, 0],
                d = 0,
                p = 0,
                f = 0,
                g = 0,
                m = 0,
                y = 0,
                v = 0,
                x = new s,
                b = new s,
                _ = this,
                w = this.vertices;
                if (w.length < 3) return t;
                if (++h > a) return console.warn("quickDecomp: max level (" + a + ") reached."),
                t;
                for (var T = 0; T < this.vertices.length; ++T) if (_.isReflex(T)) {
                    for (e.push(_.vertices[T]), d = p = Number.MAX_VALUE, P = 0; P < this.vertices.length; ++P) o.left(_.at(T - 1), _.at(T), _.at(P)) && o.rightOn(_.at(T - 1), _.at(T), _.at(P - 1)) && (u = n(_.at(T - 1), _.at(T), _.at(P), _.at(P - 1)), o.right(_.at(T + 1), _.at(T), u) && (f = o.sqdist(_.vertices[T], u)) < p && (p = f, c = u, y = P)),
                    o.left(_.at(T + 1), _.at(T), _.at(P + 1)) && o.rightOn(_.at(T + 1), _.at(T), _.at(P)) && (u = n(_.at(T + 1), _.at(T), _.at(P), _.at(P + 1)), o.left(_.at(T - 1), _.at(T), u) && (f = o.sqdist(_.vertices[T], u)) < d && (d = f, l = u, m = P));
                    if (y == (m + 1) % this.vertices.length) u[0] = (c[0] + l[0]) / 2,
                    u[1] = (c[1] + l[1]) / 2,
                    i.push(u),
                    T < m ? (x.append(_, T, m + 1), x.vertices.push(u), b.vertices.push(u), 0 != y && b.append(_, y, _.vertices.length), b.append(_, 0, T + 1)) : (0 != T && x.append(_, T, _.vertices.length), x.append(_, 0, m + 1), x.vertices.push(u), b.vertices.push(u), b.append(_, y, T + 1));
                    else {
                        if (y > m && (m += this.vertices.length), g = Number.MAX_VALUE, m < y) return t;
                        for (var P = y; P <= m; ++P) o.leftOn(_.at(T - 1), _.at(T), _.at(P)) && o.rightOn(_.at(T + 1), _.at(T), _.at(P)) && (f = o.sqdist(_.at(T), _.at(P))) < g && (g = f, v = P % this.vertices.length);
                        T < v ? (x.append(_, T, v + 1), 0 != v && b.append(_, v, w.length), b.append(_, 0, T + 1)) : (0 != T && x.append(_, T, w.length), x.append(_, 0, v + 1), b.append(_, v, T + 1))
                    }
                    return x.vertices.length < b.vertices.length ? (x.quickDecomp(t, e, i, r, a, h), b.quickDecomp(t, e, i, r, a, h)) : (b.quickDecomp(t, e, i, r, a, h), x.quickDecomp(t, e, i, r, a, h)),
                    t
                }
                return t.push(this),
                t
            },
            s.prototype.removeCollinearPoints = function(t) {
                for (var e = 0,
                i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) o.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        },
        {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4 : [function(t, e, i) {
            function s() {}
            e.exports = s,
            s.eq = function(t, e, i) {
                return i = i || 0,
                Math.abs(t - e) < i
            }
        },
        {}],
        5 : [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        },
        {
            "./Point": 2,
            "./Polygon": 3
        }],
        6 : [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.1",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.1"
                }
            }
        },
        {}],
        7 : [function(t, e, i) {
            function s(t) {
                this.lowerBound = n.create(),
                t && t.lowerBound && n.copy(this.lowerBound, t.lowerBound),
                this.upperBound = n.create(),
                t && t.upperBound && n.copy(this.upperBound, t.upperBound)
            }
            var n = t("../math/vec2");
            t("../utils/Utils"),
            e.exports = s;
            var r = n.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var o = this.lowerBound,
                a = this.upperBound;
                "number" != typeof i && (i = 0),
                0 !== i ? n.rotate(o, t[0], i) : n.copy(o, t[0]),
                n.copy(a, o);
                for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) {
                    var u = t[c];
                    if (0 !== i) {
                        var d = u[0],
                        p = u[1];
                        r[0] = h * d - l * p,
                        r[1] = l * d + h * p,
                        u = r
                    }
                    for (var f = 0; f < 2; f++) u[f] > a[f] && (a[f] = u[f]),
                    u[f] < o[f] && (o[f] = u[f])
                }
                e && (n.add(this.lowerBound, this.lowerBound, e), n.add(this.upperBound, this.upperBound, e)),
                s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            },
            s.prototype.copy = function(t) {
                n.copy(this.lowerBound, t.lowerBound),
                n.copy(this.upperBound, t.upperBound)
            },
            s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var s = t.upperBound[e];
                    this.upperBound[e] < s && (this.upperBound[e] = s)
                }
            },
            s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                i = this.upperBound,
                s = t.lowerBound,
                n = t.upperBound;
                return (s[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (s[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1])
            },
            s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            },
            s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                i = 1 / t.direction[1],
                s = (this.lowerBound[0] - t.from[0]) * e,
                n = (this.upperBound[0] - t.from[0]) * e,
                r = (this.lowerBound[1] - t.from[1]) * i,
                o = (this.upperBound[1] - t.from[1]) * i,
                a = Math.max(Math.max(Math.min(s, n), Math.min(r, o))),
                h = Math.min(Math.min(Math.max(s, n), Math.max(r, o)));
                return h < 0 ? -1 : a > h ? -1 : a
            }
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8 : [function(t, e, i) {
            function s(t) {
                this.type = t,
                this.result = [],
                this.world = null,
                this.boundingVolumeType = s.AABB
            }
            var n = t("../math/vec2"),
            r = t("../objects/Body");
            e.exports = s,
            s.AABB = 1,
            s.BOUNDING_CIRCLE = 2,
            s.prototype.setWorld = function(t) {
                this.world = t
            },
            s.prototype.getCollisionPairs = function(t) {};
            var o = n.create();
            s.boundingRadiusCheck = function(t, e) {
                n.sub(o, t.position, e.position);
                var i = n.squaredLength(o),
                s = t.boundingRadius + e.boundingRadius;
                return i <= s * s
            },
            s.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            },
            s.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                case s.BOUNDING_CIRCLE:
                    i = s.boundingRadiusCheck(t, e);
                    break;
                case s.AABB:
                    i = s.aabbCheck(t, e);
                    break;
                default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            },
            s.canCollide = function(t, e) {
                var i = r.KINEMATIC,
                s = r.STATIC;
                return ! (t.type === s && e.type === s || t.type === i && e.type === s || t.type === s && e.type === i || t.type === i && e.type === i || t.sleepState === r.SLEEPING && e.sleepState === r.SLEEPING || t.sleepState === r.SLEEPING && e.type === s || e.sleepState === r.SLEEPING && t.type === s)
            },
            s.NAIVE = 1,
            s.SAP = 2
        },
        {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9 : [function(t, e, i) {
            function s() {
                n.call(this, n.NAIVE)
            }
            t("../shapes/Circle"),
            t("../shapes/Plane"),
            t("../shapes/Shape"),
            t("../shapes/Particle");
            var n = t("../collision/Broadphase");
            t("../math/vec2"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.getCollisionPairs = function(t) {
                var e = t.bodies,
                i = this.result;
                i.length = 0;
                for (var s = 0,
                r = e.length; s !== r; s++) for (var o = e[s], a = 0; a < s; a++) {
                    var h = e[a];
                    n.canCollide(o, h) && this.boundingVolumeCheck(o, h) && i.push(o, h)
                }
                return i
            },
            s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var s = t.bodies,
                n = 0; n < s.length; n++) {
                    var r = s[n];
                    r.aabbNeedsUpdate && r.updateAABB(),
                    r.aabb.overlaps(e) && i.push(r)
                }
                return i
            }
        },
        {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10 : [function(t, e, i) {
            function s() {
                this.contactEquations = [],
                this.frictionEquations = [],
                this.enableFriction = !0,
                this.enabledEquations = !0,
                this.slipForce = 10,
                this.frictionCoefficient = .3,
                this.surfaceVelocity = 0,
                this.contactEquationPool = new c({
                    size: 32
                }),
                this.frictionEquationPool = new FrictionEquationPool({
                    size: 64
                }),
                this.restitution = 0,
                this.stiffness = p.DEFAULT_STIFFNESS,
                this.relaxation = p.DEFAULT_RELAXATION,
                this.frictionStiffness = p.DEFAULT_STIFFNESS,
                this.frictionRelaxation = p.DEFAULT_RELAXATION,
                this.enableFrictionReduction = !0,
                this.collidingBodiesLastStep = new TupleDictionary,
                this.contactSkinSize = .01
            }
            function n(t, e) {
                o.set(t.vertices[0], .5 * -e.length, -e.radius),
                o.set(t.vertices[1], .5 * e.length, -e.radius),
                o.set(t.vertices[2], .5 * e.length, e.radius),
                o.set(t.vertices[3], .5 * -e.length, e.radius)
            }
            function r(t, e, i, s) {
                for (var n = H,
                r = q,
                l = Y,
                c = z,
                u = t,
                d = e.vertices,
                p = null,
                f = 0; f !== d.length + 1; f++) {
                    var g = d[f % d.length],
                    m = d[(f + 1) % d.length];
                    o.rotate(n, g, s),
                    o.rotate(r, m, s),
                    h(n, n, i),
                    h(r, r, i),
                    a(l, n, u),
                    a(c, r, u);
                    var y = o.crossLength(l, c);
                    if (null === p && (p = y), y * p <= 0) return ! 1;
                    p = y
                }
                return ! 0
            }
            var o = t("../math/vec2"),
            a = o.sub,
            h = o.add,
            l = o.dot,
            c = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
            FrictionEquationPool = t("../utils/FrictionEquationPool"),
            TupleDictionary = t("../utils/TupleDictionary"),
            p = t("../equations/Equation"),
            f = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
            g = t("../shapes/Convex"),
            m = t("../shapes/Shape"),
            y = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = s;
            var v = o.fromValues(0, 1),
            x = o.fromValues(0, 0),
            b = o.fromValues(0, 0),
            _ = o.fromValues(0, 0),
            w = o.fromValues(0, 0),
            T = o.fromValues(0, 0),
            P = o.fromValues(0, 0),
            C = o.fromValues(0, 0),
            S = o.fromValues(0, 0),
            A = o.fromValues(0, 0),
            E = o.fromValues(0, 0),
            M = o.fromValues(0, 0),
            R = o.fromValues(0, 0),
            L = o.fromValues(0, 0),
            B = o.fromValues(0, 0),
            I = o.fromValues(0, 0),
            O = o.fromValues(0, 0),
            k = o.fromValues(0, 0),
            F = o.fromValues(0, 0),
            D = [],
            U = o.create(),
            G = o.create();
            s.prototype.bodiesOverlap = function(t, e) {
                for (var i = U,
                s = G,
                n = 0,
                r = t.shapes.length; n !== r; n++) {
                    var o = t.shapes[n];
                    t.toWorldFrame(i, o.position);
                    for (var a = 0,
                    h = e.shapes.length; a !== h; a++) {
                        var l = e.shapes[a];
                        if (e.toWorldFrame(s, l.position), this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return ! 0
                    }
                }
                return ! 1
            },
            s.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                s = 0 | e.id;
                return !! this.collidingBodiesLastStep.get(i, s)
            },
            s.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations,
                e = t.length; e--;) {
                    var i = t[e],
                    s = i.bodyA.id,
                    n = i.bodyB.id;
                    this.collidingBodiesLastStep.set(s, n, !0)
                }
                for (var r = this.contactEquations,
                o = this.frictionEquations,
                a = 0; a < r.length; a++) this.contactEquationPool.release(r[a]);
                for (a = 0; a < o.length; a++) this.frictionEquationPool.release(o[a]);
                this.contactEquations.length = this.frictionEquations.length = 0
            },
            s.prototype.createContactEquation = function(t, e, i, s) {
                var n = this.contactEquationPool.get();
                return n.bodyA = t,
                n.bodyB = e,
                n.shapeA = i,
                n.shapeB = s,
                n.restitution = this.restitution,
                n.firstImpact = !this.collidedLastStep(t, e),
                n.stiffness = this.stiffness,
                n.relaxation = this.relaxation,
                n.needsUpdate = !0,
                n.enabled = this.enabledEquations,
                n.offset = this.contactSkinSize,
                n
            },
            s.prototype.createFrictionEquation = function(t, e, i, s) {
                var n = this.frictionEquationPool.get();
                return n.bodyA = t,
                n.bodyB = e,
                n.shapeA = i,
                n.shapeB = s,
                n.setSlipForce(this.slipForce),
                n.frictionCoefficient = this.frictionCoefficient,
                n.relativeVelocity = this.surfaceVelocity,
                n.enabled = this.enabledEquations,
                n.needsUpdate = !0,
                n.stiffness = this.frictionStiffness,
                n.relaxation = this.frictionRelaxation,
                n.contactEquations.length = 0,
                n
            },
            s.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return o.copy(e.contactPointA, t.contactPointA),
                o.copy(e.contactPointB, t.contactPointB),
                o.rotate90cw(e.t, t.normalA),
                e.contactEquations.push(t),
                e
            },
            s.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                s = e.bodyA;
                e.bodyB,
                o.set(i.contactPointA, 0, 0),
                o.set(i.contactPointB, 0, 0),
                o.set(i.t, 0, 0);
                for (var n = 0; n !== t; n++)(e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === s ? (o.add(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointA), o.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (o.sub(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointB), o.add(i.contactPointB, i.contactPointB, e.contactPointA)),
                i.contactEquations.push(e);
                var r = 1 / t;
                return o.scale(i.contactPointA, i.contactPointA, r),
                o.scale(i.contactPointB, i.contactPointB, r),
                o.normalize(i.t, i.t),
                o.rotate90cw(i.t, i.t),
                i
            },
            s.prototype[m.LINE | m.CONVEX] = s.prototype.convexLine = function(t, e, i, s, n, r, o, a, h) {
                return ! h && 0
            },
            s.prototype[m.LINE | m.BOX] = s.prototype.lineBox = function(t, e, i, s, n, r, o, a, h) {
                return ! h && 0
            };
            var N = new y({
                width: 1,
                height: 1
            }),
            X = o.create();
            s.prototype[m.CAPSULE | m.CONVEX] = s.prototype[m.CAPSULE | m.BOX] = s.prototype.convexCapsule = function(t, e, i, s, r, a, h, l, c) {
                var u = X;
                o.set(u, a.length / 2, 0),
                o.rotate(u, u, l),
                o.add(u, u, h);
                var d = this.circleConvex(r, a, u, l, t, e, i, s, c, a.radius);
                o.set(u, -a.length / 2, 0),
                o.rotate(u, u, l),
                o.add(u, u, h);
                var p = this.circleConvex(r, a, u, l, t, e, i, s, c, a.radius);
                if (c && (d || p)) return ! 0;
                var f = N;
                return n(f, a),
                this.convexConvex(t, e, i, s, r, f, h, l, c) + d + p
            },
            s.prototype[m.CAPSULE | m.LINE] = s.prototype.lineCapsule = function(t, e, i, s, n, r, o, a, h) {
                return ! h && 0
            };
            var W = o.create(),
            j = o.create(),
            V = new y({
                width: 1,
                height: 1
            });
            s.prototype[m.CAPSULE | m.CAPSULE] = s.prototype.capsuleCapsule = function(t, e, i, s, r, a, h, l, c) {
                for (var u = W,
                d = j,
                p = 0,
                f = 0; f < 2; f++) {
                    o.set(u, (0 === f ? -1 : 1) * e.length / 2, 0),
                    o.rotate(u, u, s),
                    o.add(u, u, i);
                    for (var g = 0; g < 2; g++) {
                        o.set(d, (0 === g ? -1 : 1) * a.length / 2, 0),
                        o.rotate(d, d, l),
                        o.add(d, d, h),
                        this.enableFrictionReduction && (x = this.enableFriction, this.enableFriction = !1);
                        var m = this.circleCircle(t, e, u, s, r, a, d, l, c, e.radius, a.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = x), c && m) return ! 0;
                        p += m
                    }
                }
                this.enableFrictionReduction && (x = this.enableFriction, this.enableFriction = !1);
                var y = V;
                n(y, e);
                var v = this.convexCapsule(t, y, i, s, r, a, h, l, c);
                if (this.enableFrictionReduction && (this.enableFriction = x), c && v) return ! 0;
                if (p += v, this.enableFrictionReduction) {
                    var x = this.enableFriction;
                    this.enableFriction = !1
                }
                n(y, a);
                var b = this.convexCapsule(r, y, h, l, t, e, i, s, c);
                return this.enableFrictionReduction && (this.enableFriction = x),
                !(!c || !b) || (p += b, this.enableFrictionReduction && p && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(p)), p)
            },
            s.prototype[m.LINE | m.LINE] = s.prototype.lineLine = function(t, e, i, s, n, r, o, a, h) {
                return ! h && 0
            },
            s.prototype[m.PLANE | m.LINE] = s.prototype.planeLine = function(t, e, i, s, n, r, c, u, d) {
                var p = x,
                f = b,
                g = _,
                m = w,
                y = T,
                E = P,
                M = C,
                R = S,
                L = A,
                B = D,
                I = 0;
                o.set(p, -r.length / 2, 0),
                o.set(f, r.length / 2, 0),
                o.rotate(g, p, u),
                o.rotate(m, f, u),
                h(g, g, c),
                h(m, m, c),
                o.copy(p, g),
                o.copy(f, m),
                a(y, f, p),
                o.normalize(E, y),
                o.rotate90cw(L, E),
                o.rotate(R, v, s),
                B[0] = p,
                B[1] = f;
                for (var O = 0; O < B.length; O++) {
                    var k = B[O];
                    a(M, k, i);
                    var F = l(M, R);
                    if (F < 0) {
                        if (d) return ! 0;
                        var U = this.createContactEquation(t, n, e, r);
                        I++,
                        o.copy(U.normalA, R),
                        o.normalize(U.normalA, U.normalA),
                        o.scale(M, R, F),
                        a(U.contactPointA, k, M),
                        a(U.contactPointA, U.contactPointA, t.position),
                        a(U.contactPointB, k, c),
                        h(U.contactPointB, U.contactPointB, c),
                        a(U.contactPointB, U.contactPointB, n.position),
                        this.contactEquations.push(U),
                        this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(U))
                    }
                }
                return ! d && (this.enableFrictionReduction || I && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(I)), I)
            },
            s.prototype[m.PARTICLE | m.CAPSULE] = s.prototype.particleCapsule = function(t, e, i, s, n, r, o, a, h) {
                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius, 0)
            },
            s.prototype[m.CIRCLE | m.LINE] = s.prototype.circleLine = function(t, e, i, s, n, r, c, u, d, p, f) {
                p = p || 0,
                f = void 0 !== f ? f: e.radius;
                var g = x,
                m = b,
                y = _,
                v = w,
                I = T,
                O = P,
                k = C,
                F = S,
                U = A,
                G = E,
                N = M,
                X = R,
                W = L,
                j = B,
                V = D;
                o.set(F, -r.length / 2, 0),
                o.set(U, r.length / 2, 0),
                o.rotate(G, F, u),
                o.rotate(N, U, u),
                h(G, G, c),
                h(N, N, c),
                o.copy(F, G),
                o.copy(U, N),
                a(O, U, F),
                o.normalize(k, O),
                o.rotate90cw(I, k),
                a(X, i, F);
                var H = l(X, I);
                a(v, F, c),
                a(W, i, c);
                var q = f + p;
                if (Math.abs(H) < q) {
                    o.scale(g, I, H),
                    a(y, i, g),
                    o.scale(m, I, l(I, W)),
                    o.normalize(m, m),
                    o.scale(m, m, p),
                    h(y, y, m);
                    var Y = l(k, y),
                    z = l(k, F),
                    K = l(k, U);
                    if (Y > z && Y < K) return !! d || (Z = this.createContactEquation(t, n, e, r), o.scale(Z.normalA, g, -1), o.normalize(Z.normalA, Z.normalA), o.scale(Z.contactPointA, Z.normalA, f), h(Z.contactPointA, Z.contactPointA, i), a(Z.contactPointA, Z.contactPointA, t.position), a(Z.contactPointB, y, c), h(Z.contactPointB, Z.contactPointB, c), a(Z.contactPointB, Z.contactPointB, n.position), this.contactEquations.push(Z), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z)), 1)
                }
                V[0] = F,
                V[1] = U;
                for (var J = 0; J < V.length; J++) {
                    var Q = V[J];
                    if (a(X, Q, i), o.squaredLength(X) < Math.pow(q, 2)) {
                        if (d) return ! 0;
                        var Z = this.createContactEquation(t, n, e, r);
                        return o.copy(Z.normalA, X),
                        o.normalize(Z.normalA, Z.normalA),
                        o.scale(Z.contactPointA, Z.normalA, f),
                        h(Z.contactPointA, Z.contactPointA, i),
                        a(Z.contactPointA, Z.contactPointA, t.position),
                        a(Z.contactPointB, Q, c),
                        o.scale(j, Z.normalA, -p),
                        h(Z.contactPointB, Z.contactPointB, j),
                        h(Z.contactPointB, Z.contactPointB, c),
                        a(Z.contactPointB, Z.contactPointB, n.position),
                        this.contactEquations.push(Z),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z)),
                        1
                    }
                }
                return 0
            },
            s.prototype[m.CIRCLE | m.CAPSULE] = s.prototype.circleCapsule = function(t, e, i, s, n, r, o, a, h) {
                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius)
            },
            s.prototype[m.CIRCLE | m.CONVEX] = s.prototype[m.CIRCLE | m.BOX] = s.prototype.circleConvex = function(t, e, i, s, n, l, c, u, d, p) {
                p = "number" == typeof p ? p: e.radius;
                for (var f = x,
                g = b,
                m = _,
                y = w,
                v = T,
                P = E,
                C = M,
                S = L,
                A = B,
                R = I,
                k = O,
                F = !1,
                D = Number.MAX_VALUE,
                U = l.vertices,
                G = 0; G !== U.length + 1; G++) {
                    var N = U[G % U.length],
                    X = U[(G + 1) % U.length];
                    if (o.rotate(f, N, u), o.rotate(g, X, u), h(f, f, c), h(g, g, c), a(m, g, f), o.normalize(y, m), o.rotate90cw(v, y), o.scale(A, v, -e.radius), h(A, A, i), r(A, l, c, u)) {
                        o.sub(R, f, A);
                        var W = Math.abs(o.dot(R, v));
                        W < D && (o.copy(k, A), D = W, o.scale(S, v, W), o.add(S, S, A), F = !0)
                    }
                }
                if (F) return !! d || (V = this.createContactEquation(t, n, e, l), o.sub(V.normalA, k, i), o.normalize(V.normalA, V.normalA), o.scale(V.contactPointA, V.normalA, p), h(V.contactPointA, V.contactPointA, i), a(V.contactPointA, V.contactPointA, t.position), a(V.contactPointB, S, c), h(V.contactPointB, V.contactPointB, c), a(V.contactPointB, V.contactPointB, n.position), this.contactEquations.push(V), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(V)), 1);
                if (p > 0) for (G = 0; G < U.length; G++) {
                    var j = U[G];
                    if (o.rotate(C, j, u), h(C, C, c), a(P, C, i), o.squaredLength(P) < Math.pow(p, 2)) {
                        if (d) return ! 0;
                        var V = this.createContactEquation(t, n, e, l);
                        return o.copy(V.normalA, P),
                        o.normalize(V.normalA, V.normalA),
                        o.scale(V.contactPointA, V.normalA, p),
                        h(V.contactPointA, V.contactPointA, i),
                        a(V.contactPointA, V.contactPointA, t.position),
                        a(V.contactPointB, C, c),
                        h(V.contactPointB, V.contactPointB, c),
                        a(V.contactPointB, V.contactPointB, n.position),
                        this.contactEquations.push(V),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(V)),
                        1
                    }
                }
                return 0
            };
            var H = o.create(),
            q = o.create(),
            Y = o.create(),
            z = o.create();
            s.prototype[m.PARTICLE | m.CONVEX] = s.prototype[m.PARTICLE | m.BOX] = s.prototype.particleConvex = function(t, e, i, s, n, c, u, d, p) {
                var f = x,
                g = b,
                m = _,
                y = w,
                v = T,
                S = P,
                A = C,
                M = E,
                R = L,
                B = k,
                I = F,
                O = Number.MAX_VALUE,
                D = !1,
                U = c.vertices;
                if (!r(i, c, u, d)) return 0;
                if (p) return ! 0;
                for (var G = 0; G !== U.length + 1; G++) {
                    var N = U[G % U.length],
                    X = U[(G + 1) % U.length];
                    o.rotate(f, N, d),
                    o.rotate(g, X, d),
                    h(f, f, u),
                    h(g, g, u),
                    a(m, g, f),
                    o.normalize(y, m),
                    o.rotate90cw(v, y),
                    a(M, i, f),
                    l(M, v),
                    a(S, f, u),
                    a(A, i, u),
                    o.sub(B, f, i);
                    var W = Math.abs(o.dot(B, v));
                    W < O && (O = W, o.scale(R, v, W), o.add(R, R, i), o.copy(I, v), D = !0)
                }
                if (D) {
                    var j = this.createContactEquation(t, n, e, c);
                    return o.scale(j.normalA, I, -1),
                    o.normalize(j.normalA, j.normalA),
                    o.set(j.contactPointA, 0, 0),
                    h(j.contactPointA, j.contactPointA, i),
                    a(j.contactPointA, j.contactPointA, t.position),
                    a(j.contactPointB, R, u),
                    h(j.contactPointB, j.contactPointB, u),
                    a(j.contactPointB, j.contactPointB, n.position),
                    this.contactEquations.push(j),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)),
                    1
                }
                return 0
            },
            s.prototype[m.CIRCLE] = s.prototype.circleCircle = function(t, e, i, s, n, r, l, c, u, d, p) {
                var f = x;
                d = d || e.radius,
                p = p || r.radius;
                a(f, i, l);
                var g = d + p;
                if (o.squaredLength(f) > Math.pow(g, 2)) return 0;
                if (u) return ! 0;
                var m = this.createContactEquation(t, n, e, r);
                return a(m.normalA, l, i),
                o.normalize(m.normalA, m.normalA),
                o.scale(m.contactPointA, m.normalA, d),
                o.scale(m.contactPointB, m.normalA, -p),
                h(m.contactPointA, m.contactPointA, i),
                a(m.contactPointA, m.contactPointA, t.position),
                h(m.contactPointB, m.contactPointB, l),
                a(m.contactPointB, m.contactPointB, n.position),
                this.contactEquations.push(m),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(m)),
                1
            },
            s.prototype[m.PLANE | m.CONVEX] = s.prototype[m.PLANE | m.BOX] = s.prototype.planeConvex = function(t, e, i, s, n, r, c, u, d) {
                var p = x,
                f = b,
                g = _,
                m = 0;
                o.rotate(f, v, s);
                for (var y = 0; y !== r.vertices.length; y++) {
                    var w = r.vertices[y];
                    if (o.rotate(p, w, u), h(p, p, c), a(g, p, i), l(g, f) <= 0) {
                        if (d) return ! 0;
                        m++;
                        var T = this.createContactEquation(t, n, e, r);
                        a(g, p, i),
                        o.copy(T.normalA, f);
                        var P = l(g, T.normalA);
                        o.scale(g, T.normalA, P),
                        a(T.contactPointB, p, n.position),
                        a(T.contactPointA, p, g),
                        a(T.contactPointA, T.contactPointA, t.position),
                        this.contactEquations.push(T),
                        this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(T))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && m && this.frictionEquations.push(this.createFrictionFromAverage(m)),
                m
            },
            s.prototype[m.PARTICLE | m.PLANE] = s.prototype.particlePlane = function(t, e, i, s, n, r, h, c, u) {
                var d = x,
                p = b;
                c = c || 0,
                a(d, i, h),
                o.rotate(p, v, c);
                var f = l(d, p);
                if (f > 0) return 0;
                if (u) return ! 0;
                var g = this.createContactEquation(n, t, r, e);
                return o.copy(g.normalA, p),
                o.scale(d, g.normalA, f),
                a(g.contactPointA, i, d),
                a(g.contactPointA, g.contactPointA, n.position),
                a(g.contactPointB, i, t.position),
                this.contactEquations.push(g),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g)),
                1
            },
            s.prototype[m.CIRCLE | m.PARTICLE] = s.prototype.circleParticle = function(t, e, i, s, n, r, l, c, u) {
                var d = x;
                if (a(d, l, i), o.squaredLength(d) > Math.pow(e.radius, 2)) return 0;
                if (u) return ! 0;
                var p = this.createContactEquation(t, n, e, r);
                return o.copy(p.normalA, d),
                o.normalize(p.normalA, p.normalA),
                o.scale(p.contactPointA, p.normalA, e.radius),
                h(p.contactPointA, p.contactPointA, i),
                a(p.contactPointA, p.contactPointA, t.position),
                a(p.contactPointB, l, n.position),
                this.contactEquations.push(p),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)),
                1
            };
            var K = new f({
                radius: 1
            }),
            J = o.create(),
            Q = o.create();
            o.create(),
            s.prototype[m.PLANE | m.CAPSULE] = s.prototype.planeCapsule = function(t, e, i, s, n, r, a, l, c) {
                var u, d = J,
                p = Q,
                f = K;
                o.set(d, -r.length / 2, 0),
                o.rotate(d, d, l),
                h(d, d, a),
                o.set(p, r.length / 2, 0),
                o.rotate(p, p, l),
                h(p, p, a),
                f.radius = r.radius,
                this.enableFrictionReduction && (u = this.enableFriction, this.enableFriction = !1);
                var g = this.circlePlane(n, f, d, 0, t, e, i, s, c),
                m = this.circlePlane(n, f, p, 0, t, e, i, s, c);
                if (this.enableFrictionReduction && (this.enableFriction = u), c) return g || m;
                var y = g + m;
                return this.enableFrictionReduction && y && this.frictionEquations.push(this.createFrictionFromAverage(y)),
                y
            },
            s.prototype[m.CIRCLE | m.PLANE] = s.prototype.circlePlane = function(t, e, i, s, n, r, c, u, d) {
                var p = t,
                f = e,
                g = i,
                m = n,
                y = c,
                w = u;
                w = w || 0;
                var T = x,
                P = b,
                C = _;
                a(T, g, y),
                o.rotate(P, v, w);
                var S = l(P, T);
                if (S > f.radius) return 0;
                if (d) return ! 0;
                var A = this.createContactEquation(m, p, r, e);
                return o.copy(A.normalA, P),
                o.scale(A.contactPointB, A.normalA, -f.radius),
                h(A.contactPointB, A.contactPointB, g),
                a(A.contactPointB, A.contactPointB, p.position),
                o.scale(C, A.normalA, S),
                a(A.contactPointA, T, C),
                h(A.contactPointA, A.contactPointA, y),
                a(A.contactPointA, A.contactPointA, m.position),
                this.contactEquations.push(A),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)),
                1
            },
            s.prototype[m.CONVEX] = s.prototype[m.CONVEX | m.BOX] = s.prototype[m.BOX] = s.prototype.convexConvex = function(t, e, i, n, r, c, u, d, p, f) {
                var g = x,
                m = b,
                y = _,
                v = w,
                P = T,
                E = C,
                M = S,
                R = A,
                L = 0;
                f = "number" == typeof f ? f: 0;
                if (!s.findSeparatingAxis(e, i, n, c, u, d, g)) return 0;
                a(M, u, i),
                l(g, M) > 0 && o.scale(g, g, -1);
                var B = s.getClosestEdge(e, n, g, !0),
                I = s.getClosestEdge(c, d, g);
                if ( - 1 === B || -1 === I) return 0;
                for (var O = 0; O < 2; O++) {
                    var k, F = B,
                    D = I,
                    U = e,
                    G = c,
                    N = i,
                    X = u,
                    W = n,
                    j = d,
                    V = t,
                    H = r;
                    if (0 === O) k = F,
                    F = D,
                    D = k,
                    k = U,
                    U = G,
                    G = k,
                    k = N,
                    N = X,
                    X = k,
                    k = W,
                    W = j,
                    j = k,
                    k = V,
                    V = H,
                    H = k;
                    for (var q = D; q < D + 2; q++) {
                        var Y = G.vertices[(q + G.vertices.length) % G.vertices.length];
                        o.rotate(m, Y, j),
                        h(m, m, X);
                        for (var z = 0,
                        K = F - 1; K < F + 2; K++) {
                            var J = U.vertices[(K + U.vertices.length) % U.vertices.length],
                            Q = U.vertices[(K + 1 + U.vertices.length) % U.vertices.length];
                            o.rotate(y, J, W),
                            o.rotate(v, Q, W),
                            h(y, y, N),
                            h(v, v, N),
                            a(P, v, y),
                            o.rotate90cw(R, P),
                            o.normalize(R, R),
                            a(M, m, y),
                            $ = l(R, M),
                            (K === F && $ <= f || K !== F && $ <= 0) && z++
                        }
                        if (z >= 3) {
                            if (p) return ! 0;
                            var Z = this.createContactEquation(V, H, U, G);
                            L++;
                            J = U.vertices[F % U.vertices.length],
                            Q = U.vertices[(F + 1) % U.vertices.length];
                            o.rotate(y, J, W),
                            o.rotate(v, Q, W),
                            h(y, y, N),
                            h(v, v, N),
                            a(P, v, y),
                            o.rotate90cw(Z.normalA, P),
                            o.normalize(Z.normalA, Z.normalA),
                            a(M, m, y);
                            var $ = l(Z.normalA, M);
                            o.scale(E, Z.normalA, $),
                            a(Z.contactPointA, m, N),
                            a(Z.contactPointA, Z.contactPointA, E),
                            h(Z.contactPointA, Z.contactPointA, N),
                            a(Z.contactPointA, Z.contactPointA, V.position),
                            a(Z.contactPointB, m, X),
                            h(Z.contactPointB, Z.contactPointB, X),
                            a(Z.contactPointB, Z.contactPointB, H.position),
                            this.contactEquations.push(Z),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && L && this.frictionEquations.push(this.createFrictionFromAverage(L)),
                L
            };
            var Z = o.fromValues(0, 0);
            s.projectConvexOntoAxis = function(t, e, i, s, n) {
                var r, a, h = null,
                c = null,
                u = Z;
                o.rotate(u, s, -i);
                for (var d = 0; d < t.vertices.length; d++) r = t.vertices[d],
                a = l(r, u),
                (null === h || a > h) && (h = a),
                (null === c || a < c) && (c = a);
                if (c > h) {
                    var p = c;
                    c = h,
                    h = p
                }
                var f = l(e, s);
                o.set(n, c + f, h + f)
            };
            var $ = o.fromValues(0, 0),
            tt = o.fromValues(0, 0),
            et = o.fromValues(0, 0),
            it = o.fromValues(0, 0),
            st = o.fromValues(0, 0),
            nt = o.fromValues(0, 0);
            s.findSeparatingAxis = function(t, e, i, n, r, h, l) {
                var c = null,
                u = !1,
                d = !1,
                p = $,
                f = tt,
                g = et,
                m = it,
                v = st,
                x = nt;
                if (t instanceof y && n instanceof y) for (P = 0; 2 !== P; P++) {
                    var b = t,
                    _ = i;
                    for (1 === P && (b = n, _ = h), C = 0; 2 !== C; C++) {
                        0 === C ? o.set(m, 0, 1) : 1 === C && o.set(m, 1, 0),
                        0 !== _ && o.rotate(m, m, _),
                        s.projectConvexOntoAxis(t, e, i, m, v),
                        s.projectConvexOntoAxis(n, r, h, m, x);
                        var w = v,
                        T = x;
                        v[0] > x[0] && (T = v, w = x),
                        u = (S = T[0] - w[1]) <= 0,
                        (null === c || S > c) && (o.copy(l, m), c = S, d = u)
                    }
                } else for (var P = 0; 2 !== P; P++) {
                    b = t,
                    _ = i;
                    1 === P && (b = n, _ = h);
                    for (var C = 0; C !== b.vertices.length; C++) {
                        o.rotate(f, b.vertices[C], _),
                        o.rotate(g, b.vertices[(C + 1) % b.vertices.length], _),
                        a(p, g, f),
                        o.rotate90cw(m, p),
                        o.normalize(m, m),
                        s.projectConvexOntoAxis(t, e, i, m, v),
                        s.projectConvexOntoAxis(n, r, h, m, x);
                        w = v,
                        T = x;
                        v[0] > x[0] && (T = v, w = x);
                        var S = T[0] - w[1];
                        u = S <= 0,
                        (null === c || S > c) && (o.copy(l, m), c = S, d = u)
                    }
                }
                return d
            };
            var rt = o.fromValues(0, 0),
            ot = o.fromValues(0, 0),
            at = o.fromValues(0, 0);
            s.getClosestEdge = function(t, e, i, s) {
                var n = rt,
                r = ot,
                h = at;
                o.rotate(n, i, -e),
                s && o.scale(n, n, -1);
                for (var c = -1,
                u = t.vertices.length,
                d = -1,
                p = 0; p !== u; p++) {
                    a(r, t.vertices[(p + 1) % u], t.vertices[p % u]),
                    o.rotate90cw(h, r),
                    o.normalize(h, h);
                    var f = l(h, n); ( - 1 === c || f > d) && (c = p % u, d = f)
                }
                return c
            };
            var ht = o.create(),
            lt = o.create(),
            ct = o.create(),
            ut = o.create(),
            dt = o.create(),
            pt = o.create(),
            ft = o.create();
            s.prototype[m.CIRCLE | m.HEIGHTFIELD] = s.prototype.circleHeightfield = function(t, e, i, s, n, r, l, c, u, d) {
                var p = r.heights,
                f = (d = d || e.radius, r.elementWidth),
                g = lt,
                m = ht,
                y = dt,
                v = ft,
                x = pt,
                b = ct,
                _ = ut,
                w = Math.floor((i[0] - d - l[0]) / f),
                T = Math.ceil((i[0] + d - l[0]) / f);
                w < 0 && (w = 0),
                T >= p.length && (T = p.length - 1);
                for (var P = p[w], C = p[T], S = w; S < T; S++) p[S] < C && (C = p[S]),
                p[S] > P && (P = p[S]);
                if (i[1] - d > P) return ! u && 0;
                var A = !1;
                for (S = w; S < T; S++) {
                    o.set(b, S * f, p[S]),
                    o.set(_, (S + 1) * f, p[S + 1]),
                    o.add(b, b, l),
                    o.add(_, _, l),
                    o.sub(x, _, b),
                    o.rotate(x, x, Math.PI / 2),
                    o.normalize(x, x),
                    o.scale(m, x, -d),
                    o.add(m, m, i),
                    o.sub(g, m, b);
                    var E = o.dot(g, x);
                    if (m[0] >= b[0] && m[0] < _[0] && E <= 0) {
                        if (u) return ! 0;
                        A = !0,
                        o.scale(g, x, -E),
                        o.add(y, m, g),
                        o.copy(v, x),
                        M = this.createContactEquation(n, t, r, e),
                        o.copy(M.normalA, v),
                        o.scale(M.contactPointB, M.normalA, -d),
                        h(M.contactPointB, M.contactPointB, i),
                        a(M.contactPointB, M.contactPointB, t.position),
                        o.copy(M.contactPointA, y),
                        o.sub(M.contactPointA, M.contactPointA, n.position),
                        this.contactEquations.push(M),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                    }
                }
                if (A = !1, d > 0) for (S = w; S <= T; S++) if (o.set(b, S * f, p[S]), o.add(b, b, l), o.sub(g, i, b), o.squaredLength(g) < Math.pow(d, 2)) {
                    if (u) return ! 0;
                    A = !0;
                    var M = this.createContactEquation(n, t, r, e);
                    o.copy(M.normalA, g),
                    o.normalize(M.normalA, M.normalA),
                    o.scale(M.contactPointB, M.normalA, -d),
                    h(M.contactPointB, M.contactPointB, i),
                    a(M.contactPointB, M.contactPointB, t.position),
                    a(M.contactPointA, b, l),
                    h(M.contactPointA, M.contactPointA, l),
                    a(M.contactPointA, M.contactPointA, n.position),
                    this.contactEquations.push(M),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                }
                return A ? 1 : 0
            };
            var gt = o.create(),
            mt = o.create(),
            yt = o.create(),
            vt = new g({
                vertices: [o.create(), o.create(), o.create(), o.create()]
            });
            s.prototype[m.BOX | m.HEIGHTFIELD] = s.prototype[m.CONVEX | m.HEIGHTFIELD] = s.prototype.convexHeightfield = function(t, e, i, s, n, r, a, h, l) {
                var c = r.heights,
                u = r.elementWidth,
                d = gt,
                p = mt,
                f = yt,
                g = vt,
                m = Math.floor((t.aabb.lowerBound[0] - a[0]) / u),
                y = Math.ceil((t.aabb.upperBound[0] - a[0]) / u);
                m < 0 && (m = 0),
                y >= c.length && (y = c.length - 1);
                for (var v = c[m], x = c[y], b = m; b < y; b++) c[b] < x && (x = c[b]),
                c[b] > v && (v = c[b]);
                if (t.aabb.lowerBound[1] > v) return ! l && 0;
                var _ = 0;
                for (b = m; b < y; b++) o.set(d, b * u, c[b]),
                o.set(p, (b + 1) * u, c[b + 1]),
                o.add(d, d, a),
                o.add(p, p, a),
                o.set(f, .5 * (p[0] + d[0]), .5 * (p[1] + d[1] - 100)),
                o.sub(g.vertices[0], p, f),
                o.sub(g.vertices[1], d, f),
                o.copy(g.vertices[2], g.vertices[1]),
                o.copy(g.vertices[3], g.vertices[0]),
                g.vertices[2][1] -= 100,
                g.vertices[3][1] -= 100,
                _ += this.convexConvex(t, e, i, s, n, g, f, 0, l);
                return _
            }
        },
        {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11 : [function(t, e, i) {
            function s(t) {
                t = t || {},
                this.from = t.from ? r.fromValues(t.from[0], t.from[1]) : r.create(),
                this.to = t.to ? r.fromValues(t.to[0], t.to[1]) : r.create(),
                this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse,
                this.skipBackfaces = !!t.skipBackfaces,
                this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask: -1,
                this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup: -1,
                this.mode = void 0 !== t.mode ? t.mode: s.ANY,
                this.callback = t.callback ||
                function(t) {},
                this.direction = r.create(),
                this.length = 1,
                this.update()
            }
            function n(t, e, i) {
                r.sub(a, i, t);
                var s = r.dot(a, e);
                return r.scale(h, e, s),
                r.add(h, h, t),
                r.squaredDistance(i, h)
            }
            e.exports = s;
            var r = t("../math/vec2");
            t("../collision/RaycastResult"),
            t("../shapes/Shape"),
            t("../collision/AABB"),
            s.prototype.constructor = s,
            s.CLOSEST = 1,
            s.ANY = 2,
            s.ALL = 4,
            s.prototype.update = function() {
                var t = this.direction;
                r.sub(t, this.to, this.from),
                this.length = r.length(t),
                r.normalize(t, t)
            },
            s.prototype.intersectBodies = function(t, e) {
                for (var i = 0,
                s = e.length; ! t.shouldStop(this) && i < s; i++) {
                    var n = e[i],
                    r = n.getAABB(); (r.overlapsRay(this) >= 0 || r.containsPoint(this.from)) && this.intersectBody(t, n)
                }
            };
            var o = r.create();
            s.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse) for (var s = o,
                n = 0,
                a = e.shapes.length; n < a; n++) {
                    var h = e.shapes[n];
                    if ((!i || h.collisionResponse) && 0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask)) {
                        r.rotate(s, h.position, e.angle),
                        r.add(s, s, e.position);
                        var l = h.angle + e.angle;
                        if (this.intersectShape(t, h, l, s, e), t.shouldStop(this)) break
                    }
                }
            },
            s.prototype.intersectShape = function(t, e, i, s, r) {
                n(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = r, this._currentShape = e, e.raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            },
            s.prototype.getAABB = function(t) {
                var e = this.to,
                i = this.from;
                r.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])),
                r.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            },
            r.create(),
            s.prototype.reportIntersection = function(t, e, i, n) {
                this.from,
                this.to;
                var o = this._currentShape,
                a = this._currentBody;
                if (! (this.skipBackfaces && r.dot(i, this.direction) > 0)) switch (this.mode) {
                case s.ALL:
                    t.set(i, o, a, e, n),
                    this.callback(t);
                    break;
                case s.CLOSEST:
                    (e < t.fraction || !t.hasHit()) && t.set(i, o, a, e, n);
                    break;
                case s.ANY:
                    t.set(i, o, a, e, n)
                }
            };
            var a = r.create(),
            h = r.create()
        },
        {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12 : [function(t, e, i) {
            function s() {
                this.normal = n.create(),
                this.shape = null,
                this.body = null,
                this.faceIndex = -1,
                this.fraction = -1,
                this.isStopped = !1
            }
            var n = t("../math/vec2"),
            r = t("../collision/Ray");
            e.exports = s,
            s.prototype.reset = function() {
                n.set(this.normal, 0, 0),
                this.shape = null,
                this.body = null,
                this.faceIndex = -1,
                this.fraction = -1,
                this.isStopped = !1
            },
            s.prototype.getHitDistance = function(t) {
                return n.distance(t.from, t.to) * this.fraction
            },
            s.prototype.hasHit = function() {
                return - 1 !== this.fraction
            },
            s.prototype.getHitPoint = function(t, e) {
                n.lerp(t, e.from, e.to, this.fraction)
            },
            s.prototype.stop = function() {
                this.isStopped = !0
            },
            s.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === r.ANY
            },
            s.prototype.set = function(t, e, i, s, r) {
                n.copy(this.normal, t),
                this.shape = e,
                this.body = i,
                this.fraction = s,
                this.faceIndex = r
            }
        },
        {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13 : [function(t, e, i) {
            function s() {
                r.call(this, r.SAP),
                this.axisList = [],
                this.axisIndex = 0;
                var t = this;
                this._addBodyHandler = function(e) {
                    t.axisList.push(e.body)
                },
                this._removeBodyHandler = function(e) {
                    var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1)
                }
            }
            var n = t("../utils/Utils"),
            r = t("../collision/Broadphase");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.setWorld = function(t) {
                this.axisList.length = 0,
                n.appendArray(this.axisList, t.bodies),
                t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler),
                t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler),
                this.world = t
            },
            s.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1,
                s = t.length; i < s; i++) {
                    for (var n = t[i], r = i - 1; r >= 0 && !(t[r].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); r--) t[r + 1] = t[r];
                    t[r + 1] = n
                }
                return t
            },
            s.prototype.sortList = function() {
                var t = this.axisList,
                e = this.axisIndex;
                s.sortAxisList(t, e)
            },
            s.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                i = this.result,
                s = this.axisIndex;
                i.length = 0;
                for (var n = e.length; n--;) {
                    var o = e[n];
                    o.aabbNeedsUpdate && o.updateAABB()
                }
                this.sortList();
                for (var a = 0,
                h = 0 | e.length; a !== h; a++) for (var l = e[a], c = a + 1; c < h; c++) {
                    var u = e[c];
                    if (! (u.aabb.lowerBound[s] <= l.aabb.upperBound[s])) break;
                    r.canCollide(l, u) && this.boundingVolumeCheck(l, u) && i.push(l, u)
                }
                return i
            },
            s.prototype.aabbQuery = function(t, e, i) {
                i = i || [],
                this.sortList();
                var s = this.axisIndex,
                n = "x";
                1 === s && (n = "y"),
                2 === s && (n = "z");
                for (var r = this.axisList,
                o = (e.lowerBound[n], e.upperBound[n], 0); o < r.length; o++) {
                    var a = r[o];
                    a.aabbNeedsUpdate && a.updateAABB(),
                    a.aabb.overlaps(e) && i.push(a)
                }
                return i
            }
        },
        {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14 : [function(t, e, i) {
            function s(t, e, i, s) {
                this.type = i,
                s = n.defaults(s, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }),
                this.equations = [],
                this.bodyA = t,
                this.bodyB = e,
                this.collideConnected = s.collideConnected,
                s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            e.exports = s;
            var n = t("../utils/Utils");
            s.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            },
            s.DISTANCE = 1,
            s.GEAR = 2,
            s.LOCK = 3,
            s.PRISMATIC = 4,
            s.REVOLUTE = 5,
            s.prototype.setStiffness = function(t) {
                for (var e = this.equations,
                i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.stiffness = t,
                    s.needsUpdate = !0
                }
            },
            s.prototype.setRelaxation = function(t) {
                for (var e = this.equations,
                i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.relaxation = t,
                    s.needsUpdate = !0
                }
            }
        },
        {
            "../utils/Utils": 57
        }],
        15 : [function(t, e, i) {
            function s(t, e, i) {
                i = a.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }),
                n.call(this, t, e, n.DISTANCE, i),
                this.localAnchorA = o.fromValues(i.localAnchorA[0], i.localAnchorA[1]),
                this.localAnchorB = o.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var s, h = this.localAnchorA,
                l = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var c = o.create(),
                    u = o.create(),
                    d = o.create();
                    o.rotate(c, h, t.angle),
                    o.rotate(u, l, e.angle),
                    o.add(d, e.position, u),
                    o.sub(d, d, c),
                    o.sub(d, d, t.position),
                    this.distance = o.length(d)
                }
                s = void 0 === i.maxForce ? Number.MAX_VALUE: i.maxForce;
                var p = new r(t, e, -s, s);
                this.equations = [p],
                this.maxForce = s;
                d = o.create();
                var f = o.create(),
                g = o.create(),
                m = this;
                p.computeGq = function() {
                    var t = this.bodyA,
                    e = this.bodyB,
                    i = t.position,
                    s = e.position;
                    return o.rotate(f, h, t.angle),
                    o.rotate(g, l, e.angle),
                    o.add(d, s, g),
                    o.sub(d, d, f),
                    o.sub(d, d, i),
                    o.length(d) - m.distance
                },
                this.setMaxForce(s),
                this.upperLimitEnabled = !1,
                this.upperLimit = 1,
                this.lowerLimitEnabled = !1,
                this.lowerLimit = 0,
                this.position = 0
            }
            var n = t("./Constraint"),
            r = t("../equations/Equation"),
            o = t("../math/vec2"),
            a = t("../utils/Utils");
            e.exports = s,
            (s.prototype = new n).constructor = s;
            var h = o.create(),
            l = o.create(),
            c = o.create();
            s.prototype.update = function() {
                var t = this.equations[0],
                e = this.bodyA,
                i = this.bodyB,
                s = (this.distance, e.position),
                n = i.position,
                r = this.equations[0],
                a = t.G;
                o.rotate(l, this.localAnchorA, e.angle),
                o.rotate(c, this.localAnchorB, i.angle),
                o.add(h, n, c),
                o.sub(h, h, l),
                o.sub(h, h, s),
                this.position = o.length(h);
                var u = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (r.maxForce = 0, r.minForce = -this.maxForce, this.distance = this.upperLimit, u = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (r.maxForce = this.maxForce, r.minForce = 0, this.distance = this.lowerLimit, u = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || u) {
                    r.enabled = !0,
                    o.normalize(h, h);
                    var d = o.crossLength(l, h),
                    p = o.crossLength(c, h);
                    a[0] = -h[0],
                    a[1] = -h[1],
                    a[2] = -d,
                    a[3] = h[0],
                    a[4] = h[1],
                    a[5] = p
                } else r.enabled = !1
            },
            s.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t,
                e.maxForce = t
            },
            s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        },
        {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, n.GEAR, i),
                this.ratio = void 0 !== i.ratio ? i.ratio: 1,
                this.angle = void 0 !== i.angle ? i.angle: e.angle - this.ratio * t.angle,
                i.angle = this.angle,
                i.ratio = this.ratio,
                this.equations = [new r(t, e, i)],
                void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }
            var n = t("./Constraint"),
            r = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio),
                t.angle = this.angle
            },
            s.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            },
            s.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        },
        {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, n.LOCK, i);
                var s = void 0 === i.maxForce ? Number.MAX_VALUE: i.maxForce,
                a = (i.localAngleB, new o(t, e, -s, s)),
                h = new o(t, e, -s, s),
                l = new o(t, e, -s, s),
                c = r.create(),
                u = r.create(),
                d = this;
                a.computeGq = function() {
                    return r.rotate(c, d.localOffsetB, t.angle),
                    r.sub(u, e.position, t.position),
                    r.sub(u, u, c),
                    u[0]
                },
                h.computeGq = function() {
                    return r.rotate(c, d.localOffsetB, t.angle),
                    r.sub(u, e.position, t.position),
                    r.sub(u, u, c),
                    u[1]
                };
                var p = r.create(),
                f = r.create();
                l.computeGq = function() {
                    return r.rotate(p, d.localOffsetB, e.angle - d.localAngleB),
                    r.scale(p, p, -1),
                    r.sub(u, t.position, e.position),
                    r.add(u, u, p),
                    r.rotate(f, p, -Math.PI / 2),
                    r.normalize(f, f),
                    r.dot(u, f)
                },
                this.localOffsetB = r.create(),
                i.localOffsetB ? r.copy(this.localOffsetB, i.localOffsetB) : (r.sub(this.localOffsetB, e.position, t.position), r.rotate(this.localOffsetB, this.localOffsetB, -t.angle)),
                this.localAngleB = 0,
                "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB: this.localAngleB = e.angle - t.angle,
                this.equations.push(a, h, l),
                this.setMaxForce(s)
            }
            var n = t("./Constraint"),
            r = t("../math/vec2"),
            o = t("../equations/Equation");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.setMaxForce = function(t) {
                for (var e = this.equations,
                i = 0; i < this.equations.length; i++) e[i].maxForce = t,
                e[i].minForce = -t
            },
            s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var a = r.create(),
            h = r.create(),
            l = r.create(),
            c = r.fromValues(1, 0),
            u = r.fromValues(0, 1);
            s.prototype.update = function() {
                var t = this.equations[0],
                e = this.equations[1],
                i = this.equations[2],
                s = this.bodyA,
                n = this.bodyB;
                r.rotate(a, this.localOffsetB, s.angle),
                r.rotate(h, this.localOffsetB, n.angle - this.localAngleB),
                r.scale(h, h, -1),
                r.rotate(l, h, Math.PI / 2),
                r.normalize(l, l),
                t.G[0] = -1,
                t.G[1] = 0,
                t.G[2] = -r.crossLength(a, c),
                t.G[3] = 1,
                e.G[0] = 0,
                e.G[1] = -1,
                e.G[2] = -r.crossLength(a, u),
                e.G[4] = 1,
                i.G[0] = -l[0],
                i.G[1] = -l[1],
                i.G[3] = l[0],
                i.G[4] = l[1],
                i.G[5] = r.crossLength(h, l)
            }
        },
        {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, n.PRISMATIC, i);
                var s = a.fromValues(0, 0),
                l = a.fromValues(1, 0),
                c = a.fromValues(0, 0);
                i.localAnchorA && a.copy(s, i.localAnchorA),
                i.localAxisA && a.copy(l, i.localAxisA),
                i.localAnchorB && a.copy(c, i.localAnchorB),
                this.localAnchorA = s,
                this.localAnchorB = c,
                this.localAxisA = l;
                var u = this.maxForce = void 0 !== i.maxForce ? i.maxForce: Number.MAX_VALUE,
                d = new o(t, e, -u, u),
                p = new a.create,
                f = new a.create,
                g = new a.create,
                m = new a.create;
                if (d.computeGq = function() {
                    return a.dot(g, m)
                },
                d.updateJacobian = function() {
                    var i = this.G,
                    n = t.position,
                    r = e.position;
                    a.rotate(p, s, t.angle),
                    a.rotate(f, c, e.angle),
                    a.add(g, r, f),
                    a.sub(g, g, n),
                    a.sub(g, g, p),
                    a.rotate(m, l, t.angle + Math.PI / 2),
                    i[0] = -m[0],
                    i[1] = -m[1],
                    i[2] = -a.crossLength(p, m) + a.crossLength(m, g),
                    i[3] = m[0],
                    i[4] = m[1],
                    i[5] = a.crossLength(f, m)
                },
                this.equations.push(d), !i.disableRotationalLock) {
                    var y = new h(t, e, -u, u);
                    this.equations.push(y)
                }
                this.position = 0,
                this.velocity = 0,
                this.lowerLimitEnabled = void 0 !== i.lowerLimit,
                this.upperLimitEnabled = void 0 !== i.upperLimit,
                this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit: 0,
                this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit: 1,
                this.upperLimitEquation = new r(t, e),
                this.lowerLimitEquation = new r(t, e),
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0,
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = u,
                this.motorEquation = new o(t, e),
                this.motorEnabled = !1,
                this.motorSpeed = 0;
                var v = this,
                x = this.motorEquation;
                x.computeGW,
                x.computeGq = function() {
                    return 0
                },
                x.computeGW = function() {
                    var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.velocity,
                    n = i.velocity,
                    r = e.angularVelocity,
                    o = i.angularVelocity;
                    return this.gmult(t, s, r, n, o) + v.motorSpeed
                }
            }
            var n = t("./Constraint"),
            r = t("../equations/ContactEquation"),
            o = t("../equations/Equation"),
            a = t("../math/vec2"),
            h = t("../equations/RotationalLockEquation");
            e.exports = s,
            (s.prototype = new n).constructor = s;
            var l = a.create(),
            c = a.create(),
            u = a.create(),
            d = a.create(),
            p = a.create(),
            f = a.create();
            s.prototype.update = function() {
                var t = this.equations,
                e = t[0],
                i = this.upperLimit,
                s = this.lowerLimit,
                n = this.upperLimitEquation,
                r = this.lowerLimitEquation,
                o = this.bodyA,
                h = this.bodyB,
                g = this.localAxisA,
                m = this.localAnchorA,
                y = this.localAnchorB;
                e.updateJacobian(),
                a.rotate(l, g, o.angle),
                a.rotate(d, m, o.angle),
                a.add(c, d, o.position),
                a.rotate(p, y, h.angle),
                a.add(u, p, h.position);
                var v = this.position = a.dot(u, l) - a.dot(c, l);
                if (this.motorEnabled) {
                    var x = this.motorEquation.G;
                    x[0] = l[0],
                    x[1] = l[1],
                    x[2] = a.crossLength(l, p),
                    x[3] = -l[0],
                    x[4] = -l[1],
                    x[5] = -a.crossLength(l, d)
                }
                if (this.upperLimitEnabled && v > i ? (a.scale(n.normalA, l, -1), a.sub(n.contactPointA, c, o.position), a.sub(n.contactPointB, u, h.position), a.scale(f, l, i), a.add(n.contactPointA, n.contactPointA, f), -1 === t.indexOf(n) && t.push(n)) : -1 !== (b = t.indexOf(n)) && t.splice(b, 1), this.lowerLimitEnabled && v < s) a.scale(r.normalA, l, 1),
                a.sub(r.contactPointA, c, o.position),
                a.sub(r.contactPointB, u, h.position),
                a.scale(f, l, s),
                a.sub(r.contactPointB, r.contactPointB, f),
                -1 === t.indexOf(r) && t.push(r);
                else {
                    var b = t.indexOf(r); - 1 !== b && t.splice(b, 1)
                }
            },
            s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            },
            s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1),
                    this.motorEnabled = !1
                }
            },
            s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1),
                "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }
        },
        {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, n.REVOLUTE, i);
                var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce: Number.MAX_VALUE;
                this.pivotA = h.create(),
                this.pivotB = h.create(),
                i.worldPivot ? (h.sub(this.pivotA, i.worldPivot, t.position), h.sub(this.pivotB, i.worldPivot, e.position), h.rotate(this.pivotA, this.pivotA, -t.angle), h.rotate(this.pivotB, this.pivotB, -e.angle)) : (h.copy(this.pivotA, i.localPivotA), h.copy(this.pivotB, i.localPivotB));
                var f = this.equations = [new r(t, e, -s, s), new r(t, e, -s, s)],
                g = f[0],
                m = f[1],
                y = this;
                g.computeGq = function() {
                    return h.rotate(l, y.pivotA, t.angle),
                    h.rotate(c, y.pivotB, e.angle),
                    h.add(p, e.position, c),
                    h.sub(p, p, t.position),
                    h.sub(p, p, l),
                    h.dot(p, u)
                },
                m.computeGq = function() {
                    return h.rotate(l, y.pivotA, t.angle),
                    h.rotate(c, y.pivotB, e.angle),
                    h.add(p, e.position, c),
                    h.sub(p, p, t.position),
                    h.sub(p, p, l),
                    h.dot(p, d)
                },
                m.minForce = g.minForce = -s,
                m.maxForce = g.maxForce = s,
                this.motorEquation = new o(t, e),
                this.motorEnabled = !1,
                this.angle = 0,
                this.lowerLimitEnabled = !1,
                this.upperLimitEnabled = !1,
                this.lowerLimit = 0,
                this.upperLimit = 0,
                this.upperLimitEquation = new a(t, e),
                this.lowerLimitEquation = new a(t, e),
                this.upperLimitEquation.minForce = 0,
                this.lowerLimitEquation.maxForce = 0
            }
            var n = t("./Constraint"),
            r = t("../equations/Equation"),
            o = t("../equations/RotationalVelocityEquation"),
            a = t("../equations/RotationalLockEquation"),
            h = t("../math/vec2");
            e.exports = s;
            var l = h.create(),
            c = h.create(),
            u = h.fromValues(1, 0),
            d = h.fromValues(0, 1),
            p = h.create(); (s.prototype = new n).constructor = s,
            s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1),
                "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            },
            s.prototype.update = function() {
                var t = this.bodyA,
                e = this.bodyB,
                i = this.pivotA,
                s = this.pivotB,
                n = this.equations,
                r = (n[0], n[1], n[0]),
                o = n[1],
                a = this.upperLimit,
                p = this.lowerLimit,
                f = this.upperLimitEquation,
                g = this.lowerLimitEquation,
                m = this.angle = e.angle - t.angle;
                if (this.upperLimitEnabled && m > a ? (f.angle = a, -1 === n.indexOf(f) && n.push(f)) : -1 !== (y = n.indexOf(f)) && n.splice(y, 1), this.lowerLimitEnabled && m < p) g.angle = p,
                -1 === n.indexOf(g) && n.push(g);
                else {
                    var y = n.indexOf(g); - 1 !== y && n.splice(y, 1)
                }
                h.rotate(l, i, t.angle),
                h.rotate(c, s, e.angle),
                r.G[0] = -1,
                r.G[1] = 0,
                r.G[2] = -h.crossLength(l, u),
                r.G[3] = 1,
                r.G[4] = 0,
                r.G[5] = h.crossLength(c, u),
                o.G[0] = 0,
                o.G[1] = -1,
                o.G[2] = -h.crossLength(l, d),
                o.G[3] = 0,
                o.G[4] = 1,
                o.G[5] = h.crossLength(c, d)
            },
            s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            },
            s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1),
                    this.motorEnabled = !1
                }
            },
            s.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            },
            s.prototype.getMotorSpeed = function() {
                return !! this.motorEnabled && this.motorEquation.relativeVelocity
            }
        },
        {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.angle = i.angle || 0,
                this.ratio = "number" == typeof i.ratio ? i.ratio: 1,
                this.setRatio(this.ratio)
            }
            var n = t("./Equation");
            t("../math/vec2"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            },
            s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t,
                e[5] = -1,
                this.ratio = t
            },
            s.prototype.setMaxTorque = function(t) {
                this.maxForce = t,
                this.minForce = -t
            }
        },
        {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21 : [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, 0, Number.MAX_VALUE),
                this.contactPointA = r.create(),
                this.penetrationVec = r.create(),
                this.contactPointB = r.create(),
                this.normalA = r.create(),
                this.restitution = 0,
                this.firstImpact = !1,
                this.shapeA = null,
                this.shapeB = null
            }
            var n = t("./Equation"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeB = function(t, e, i) {
                var s, n, o = this.bodyA,
                a = this.bodyB,
                h = this.contactPointA,
                l = this.contactPointB,
                c = o.position,
                u = a.position,
                d = this.penetrationVec,
                p = this.normalA,
                f = this.G,
                g = r.crossLength(h, p),
                m = r.crossLength(l, p);
                return f[0] = -p[0],
                f[1] = -p[1],
                f[2] = -g,
                f[3] = p[0],
                f[4] = p[1],
                f[5] = m,
                r.add(d, u, l),
                r.sub(d, d, c),
                r.sub(d, d, h),
                this.firstImpact && 0 !== this.restitution ? (n = 0, s = 1 / e * (1 + this.restitution) * this.computeGW()) : (n = r.dot(p, d) + this.offset, s = this.computeGW()),
                -n * t - s * e - i * this.computeGiMf()
            };
            var o = r.create(),
            a = r.create(),
            h = r.create();
            s.prototype.getVelocityAlongNormal = function() {
                return this.bodyA.getVelocityAtPoint(o, this.contactPointA),
                this.bodyB.getVelocityAtPoint(a, this.contactPointB),
                r.subtract(h, o, a),
                r.dot(this.normalA, h)
            }
        },
        {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22 : [function(t, e, i) {
            function s(t, e, i, n) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE: i,
                this.maxForce = void 0 === n ? Number.MAX_VALUE: n,
                this.bodyA = t,
                this.bodyB = e,
                this.stiffness = s.DEFAULT_STIFFNESS,
                this.relaxation = s.DEFAULT_RELAXATION,
                this.G = new r.ARRAY_TYPE(6);
                for (var o = 0; o < 6; o++) this.G[o] = 0;
                this.offset = 0,
                this.a = 0,
                this.b = 0,
                this.epsilon = 0,
                this.timeStep = 1 / 60,
                this.needsUpdate = !0,
                this.multiplier = 0,
                this.relativeVelocity = 0,
                this.enabled = !0
            }
            e.exports = s;
            var n = t("../math/vec2"),
            r = t("../utils/Utils");
            t("../objects/Body"),
            s.prototype.constructor = s,
            s.DEFAULT_STIFFNESS = 1e6,
            s.DEFAULT_RELAXATION = 4,
            s.prototype.update = function() {
                var t = this.stiffness,
                e = this.relaxation,
                i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)),
                this.b = 4 * e / (1 + 4 * e),
                this.epsilon = 4 / (i * i * t * (1 + 4 * e)),
                this.needsUpdate = !1
            },
            s.prototype.gmult = function(t, e, i, s, n) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
            },
            s.prototype.computeB = function(t, e, i) {
                var s = this.computeGW();
                return - this.computeGq() * t - s * e - this.computeGiMf() * i
            };
            var o = n.create(),
            a = n.create();
            s.prototype.computeGq = function() {
                var t = this.G,
                e = this.bodyA,
                i = this.bodyB,
                s = (e.position, i.position, e.angle),
                n = i.angle;
                return this.gmult(t, o, s, a, n) + this.offset
            },
            s.prototype.computeGW = function() {
                var t = this.G,
                e = this.bodyA,
                i = this.bodyB,
                s = e.velocity,
                n = i.velocity,
                r = e.angularVelocity,
                o = i.angularVelocity;
                return this.gmult(t, s, r, n, o) + this.relativeVelocity
            },
            s.prototype.computeGWlambda = function() {
                var t = this.G,
                e = this.bodyA,
                i = this.bodyB,
                s = e.vlambda,
                n = i.vlambda,
                r = e.wlambda,
                o = i.wlambda;
                return this.gmult(t, s, r, n, o)
            };
            var h = n.create(),
            l = n.create();
            s.prototype.computeGiMf = function() {
                var t = this.bodyA,
                e = this.bodyB,
                i = t.force,
                s = t.angularForce,
                r = e.force,
                o = e.angularForce,
                a = t.invMassSolve,
                c = e.invMassSolve,
                u = t.invInertiaSolve,
                d = e.invInertiaSolve,
                p = this.G;
                return n.scale(h, i, a),
                n.multiply(h, t.massMultiplier, h),
                n.scale(l, r, c),
                n.multiply(l, e.massMultiplier, l),
                this.gmult(p, h, s * u, l, o * d)
            },
            s.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                e = this.bodyB,
                i = t.invMassSolve,
                s = e.invMassSolve,
                n = t.invInertiaSolve,
                r = e.invInertiaSolve,
                o = this.G;
                return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * n + o[3] * o[3] * s * e.massMultiplier[0] + o[4] * o[4] * s * e.massMultiplier[1] + o[5] * o[5] * r
            };
            var c = n.create(),
            u = n.create(),
            d = n.create();
            n.create(),
            n.create(),
            n.create(),
            s.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                i = this.bodyB,
                s = c,
                r = u,
                o = d,
                a = e.invMassSolve,
                h = i.invMassSolve,
                l = e.invInertiaSolve,
                p = i.invInertiaSolve,
                f = this.G;
                r[0] = f[0],
                r[1] = f[1],
                o[0] = f[3],
                o[1] = f[4],
                n.scale(s, r, a * t),
                n.multiply(s, s, e.massMultiplier),
                n.add(e.vlambda, e.vlambda, s),
                e.wlambda += l * f[2] * t,
                n.scale(s, o, h * t),
                n.multiply(s, s, i.massMultiplier),
                n.add(i.vlambda, i.vlambda, s),
                i.wlambda += p * f[5] * t
            },
            s.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        },
        {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23 : [function(t, e, i) {
            function s(t, e, i) {
                r.call(this, t, e, -i, i),
                this.contactPointA = n.create(),
                this.contactPointB = n.create(),
                this.t = n.create(),
                this.contactEquations = [],
                this.shapeA = null,
                this.shapeB = null,
                this.frictionCoefficient = .3
            }
            var n = t("../math/vec2"),
            r = t("./Equation");
            t("../utils/Utils"),
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.setSlipForce = function(t) {
                this.maxForce = t,
                this.minForce = -t
            },
            s.prototype.getSlipForce = function() {
                return this.maxForce
            },
            s.prototype.computeB = function(t, e, i) {
                this.bodyA,
                this.bodyB;
                var s = this.contactPointA,
                r = this.contactPointB,
                o = this.t,
                a = this.G;
                return a[0] = -o[0],
                a[1] = -o[1],
                a[2] = -n.crossLength(s, o),
                a[3] = o[0],
                a[4] = o[1],
                a[5] = n.crossLength(r, o),
                -this.computeGW() * e - i * this.computeGiMf()
            }
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.angle = i.angle || 0;
                var s = this.G;
                s[2] = 1,
                s[5] = -1
            }
            var n = t("./Equation"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s;
            var o = r.create(),
            a = r.create(),
            h = r.fromValues(1, 0),
            l = r.fromValues(0, 1);
            s.prototype.computeGq = function() {
                return r.rotate(o, h, this.bodyA.angle + this.angle),
                r.rotate(a, l, this.bodyB.angle),
                r.dot(o, a)
            }
        },
        {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25 : [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.relativeVelocity = 1,
                this.ratio = 1
            }
            var n = t("./Equation");
            t("../math/vec2"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeB = function(t, e, i) {
                var s = this.G;
                s[2] = -1,
                s[5] = this.ratio;
                var n = this.computeGiMf();
                return - this.computeGW() * e - i * n
            }
        },
        {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26 : [function(t, e, i) {
            var s = function() {};
            e.exports = s,
            s.prototype = {
                constructor: s,
                on: function(t, e, i) {
                    e.context = i || this,
                    void 0 === this._listeners && (this._listeners = {});
                    var s = this._listeners;
                    return void 0 === s[t] && (s[t] = []),
                    -1 === s[t].indexOf(e) && s[t].push(e),
                    this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return ! 1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return ! 0
                    } else if (void 0 !== i[t]) return ! 0;
                    return ! 1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                    s = i[t].indexOf(e);
                    return - 1 !== s && i[t].splice(s, 1),
                    this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0,
                        s = e.length; i < s; i++) {
                            var n = e[i];
                            n.call(n.context, t)
                        }
                    }
                    return this
                }
            }
        },
        {}],
        27 : [function(t, e, i) {
            function s(t, e, i) {
                if (i = i || {},
                !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                this.id = s.idCounter++,
                this.materialA = t,
                this.materialB = e,
                this.friction = void 0 !== i.friction ? Number(i.friction) : .3,
                this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0,
                this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : r.DEFAULT_STIFFNESS,
                this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : r.DEFAULT_RELAXATION,
                this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : r.DEFAULT_STIFFNESS,
                this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : r.DEFAULT_RELAXATION,
                this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0,
                this.contactSkinSize = .005
            }
            var n = t("./Material"),
            r = t("../equations/Equation");
            e.exports = s,
            s.idCounter = 0
        },
        {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28 : [function(t, e, i) {
            function s(t) {
                this.id = t || s.idCounter++
            }
            e.exports = s,
            s.idCounter = 0
        },
        {}],
        29 : [function(t, e, i) {
            var s = {
                GetArea: function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2,
                    i = 0,
                    s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                    return.5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
                },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], n = [], r = 0; r < e; r++) n.push(r);
                    r = 0;
                    for (var o = e; o > 3;) {
                        var a = n[(r + 0) % o],
                        h = n[(r + 1) % o],
                        l = n[(r + 2) % o],
                        c = t[2 * a],
                        u = t[2 * a + 1],
                        d = t[2 * h],
                        p = t[2 * h + 1],
                        f = t[2 * l],
                        g = t[2 * l + 1],
                        m = !1;
                        if (s._convex(c, u, d, p, f, g)) {
                            m = !0;
                            for (var y = 0; y < o; y++) {
                                var v = n[y];
                                if (v != a && v != h && v != l && s._PointInTriangle(t[2 * v], t[2 * v + 1], c, u, d, p, f, g)) {
                                    m = !1;
                                    break
                                }
                            }
                        }
                        if (m) i.push(a, h, l),
                        n.splice((r + 1) % o, 1),
                        o--,
                        r = 0;
                        else if (r++>3 * o) break
                    }
                    return i.push(n[0], n[1], n[2]),
                    i
                },
                _PointInTriangle: function(t, e, i, s, n, r, o, a) {
                    var h = o - i,
                    l = a - s,
                    c = n - i,
                    u = r - s,
                    d = t - i,
                    p = e - s,
                    f = h * h + l * l,
                    g = h * c + l * u,
                    m = h * d + l * p,
                    y = c * c + u * u,
                    v = c * d + u * p,
                    x = 1 / (f * y - g * g),
                    b = (y * m - g * v) * x,
                    _ = (f * v - g * m) * x;
                    return b >= 0 && _ >= 0 && b + _ < 1
                },
                _convex: function(t, e, i, s, n, r) {
                    return (e - s) * (n - i) + (i - t) * (r - s) >= 0
                }
            };
            e.exports = s
        },
        {}],
        30 : [function(t, e, i) {
            var s = e.exports = {},
            n = t("../utils/Utils");
            s.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            },
            s.crossVZ = function(t, e, i) {
                return s.rotate(t, e, -Math.PI / 2),
                s.scale(t, t, i),
                t
            },
            s.crossZV = function(t, e, i) {
                return s.rotate(t, i, Math.PI / 2),
                s.scale(t, t, e),
                t
            },
            s.rotate = function(t, e, i) {
                if (0 !== i) {
                    var s = Math.cos(i),
                    n = Math.sin(i),
                    r = e[0],
                    o = e[1];
                    t[0] = s * r - n * o,
                    t[1] = n * r + s * o
                } else t[0] = e[0],
                t[1] = e[1]
            },
            s.rotate90cw = function(t, e) {
                var i = e[0],
                s = e[1];
                t[0] = s,
                t[1] = -i
            },
            s.toLocalFrame = function(t, e, i, n) {
                s.copy(t, e),
                s.sub(t, t, i),
                s.rotate(t, t, -n)
            },
            s.toGlobalFrame = function(t, e, i, n) {
                s.copy(t, e),
                s.rotate(t, t, n),
                s.add(t, t, i)
            },
            s.vectorToLocalFrame = function(t, e, i) {
                s.rotate(t, e, -i)
            },
            s.vectorToGlobalFrame = function(t, e, i) {
                s.rotate(t, e, i)
            },
            s.centroid = function(t, e, i, n) {
                return s.add(t, e, i),
                s.add(t, t, n),
                s.scale(t, t, 1 / 3),
                t
            },
            s.create = function() {
                var t = new n.ARRAY_TYPE(2);
                return t[0] = 0,
                t[1] = 0,
                t
            },
            s.clone = function(t) {
                var e = new n.ARRAY_TYPE(2);
                return e[0] = t[0],
                e[1] = t[1],
                e
            },
            s.fromValues = function(t, e) {
                var i = new n.ARRAY_TYPE(2);
                return i[0] = t,
                i[1] = e,
                i
            },
            s.copy = function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t
            },
            s.set = function(t, e, i) {
                return t[0] = e,
                t[1] = i,
                t
            },
            s.add = function(t, e, i) {
                return t[0] = e[0] + i[0],
                t[1] = e[1] + i[1],
                t
            },
            s.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0],
                t[1] = e[1] - i[1],
                t
            },
            s.sub = s.subtract,
            s.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0],
                t[1] = e[1] * i[1],
                t
            },
            s.mul = s.multiply,
            s.divide = function(t, e, i) {
                return t[0] = e[0] / i[0],
                t[1] = e[1] / i[1],
                t
            },
            s.div = s.divide,
            s.scale = function(t, e, i) {
                return t[0] = e[0] * i,
                t[1] = e[1] * i,
                t
            },
            s.distance = function(t, e) {
                var i = e[0] - t[0],
                s = e[1] - t[1];
                return Math.sqrt(i * i + s * s)
            },
            s.dist = s.distance,
            s.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                s = e[1] - t[1];
                return i * i + s * s
            },
            s.sqrDist = s.squaredDistance,
            s.length = function(t) {
                var e = t[0],
                i = t[1];
                return Math.sqrt(e * e + i * i)
            },
            s.len = s.length,
            s.squaredLength = function(t) {
                var e = t[0],
                i = t[1];
                return e * e + i * i
            },
            s.sqrLen = s.squaredLength,
            s.negate = function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t
            },
            s.normalize = function(t, e) {
                var i = e[0],
                s = e[1],
                n = i * i + s * s;
                return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n),
                t
            },
            s.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            },
            s.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            },
            s.lerp = function(t, e, i, s) {
                var n = e[0],
                r = e[1];
                return t[0] = n + s * (i[0] - n),
                t[1] = r + s * (i[1] - r),
                t
            },
            s.reflect = function(t, e, i) {
                var s = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * s,
                t[1] = e[1] - 2 * i[1] * s
            },
            s.getLineSegmentsIntersection = function(t, e, i, n, r) {
                var o = s.getLineSegmentsIntersectionFraction(e, i, n, r);
                return ! (o < 0 || (t[0] = e[0] + o * (i[0] - e[0]), t[1] = e[1] + o * (i[1] - e[1]), 0))
            },
            s.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                var n, r, o = e[0] - t[0],
                a = e[1] - t[1],
                h = s[0] - i[0],
                l = s[1] - i[1];
                return n = ( - a * (t[0] - i[0]) + o * (t[1] - i[1])) / ( - h * a + o * l),
                r = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / ( - h * a + o * l),
                n >= 0 && n <= 1 && r >= 0 && r <= 1 ? r: -1
            }
        },
        {
            "../utils/Utils": 57
        }],
        31 : [function(t, e, i) {
            function s(t) {
                t = t || {},
                c.call(this),
                this.id = t.id || ++s._idCounter,
                this.world = null,
                this.shapes = [],
                this.mass = t.mass || 0,
                this.invMass = 0,
                this.inertia = 0,
                this.invInertia = 0,
                this.invMassSolve = 0,
                this.invInertiaSolve = 0,
                this.fixedRotation = !!t.fixedRotation,
                this.fixedX = !!t.fixedX,
                this.fixedY = !!t.fixedY,
                this.massMultiplier = n.create(),
                this.position = n.fromValues(0, 0),
                t.position && n.copy(this.position, t.position),
                this.interpolatedPosition = n.fromValues(0, 0),
                this.interpolatedAngle = 0,
                this.previousPosition = n.fromValues(0, 0),
                this.previousAngle = 0,
                this.velocity = n.fromValues(0, 0),
                t.velocity && n.copy(this.velocity, t.velocity),
                this.vlambda = n.fromValues(0, 0),
                this.wlambda = 0,
                this.angle = t.angle || 0,
                this.angularVelocity = t.angularVelocity || 0,
                this.force = n.create(),
                t.force && n.copy(this.force, t.force),
                this.angularForce = t.angularForce || 0,
                this.damping = "number" == typeof t.damping ? t.damping: .1,
                this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping: .1,
                this.type = s.STATIC,
                void 0 !== t.type ? this.type = t.type: t.mass ? this.type = s.DYNAMIC: this.type = s.STATIC,
                this.boundingRadius = 0,
                this.aabb = new l,
                this.aabbNeedsUpdate = !0,
                this.allowSleep = void 0 === t.allowSleep || t.allowSleep,
                this.wantsToSleep = !1,
                this.sleepState = s.AWAKE,
                this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit: .2,
                this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit: 1,
                this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale: 1,
                this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                this.idleTime = 0,
                this.timeLastSleepy = 0,
                this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold: -1,
                this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations: 10,
                this.concavePath = null,
                this._wakeUpAfterNarrowphase = !1,
                this.updateMassProperties()
            }
            var n = t("../math/vec2"),
            r = t("poly-decomp"),
            o = t("../shapes/Convex"),
            a = t("../collision/RaycastResult"),
            h = t("../collision/Ray"),
            l = t("../collision/AABB"),
            c = t("../events/EventEmitter");
            e.exports = s,
            s.prototype = new c,
            s.prototype.constructor = s,
            s._idCounter = 0,
            s.prototype.updateSolveMassProperties = function() {
                this.sleepState === s.SLEEPING || this.type === s.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            },
            s.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t,
                this.updateMassProperties()
            },
            s.prototype.getArea = function() {
                for (var t = 0,
                e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            },
            s.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(),
                this.aabb
            };
            var u = new l,
            d = n.create();
            s.prototype.updateAABB = function() {
                for (var t = this.shapes,
                e = t.length,
                i = d,
                s = this.angle,
                r = 0; r !== e; r++) {
                    var o = t[r],
                    a = o.angle + s;
                    n.rotate(i, o.position, s),
                    n.add(i, i, this.position),
                    o.computeAABB(u, i, a),
                    0 === r ? this.aabb.copy(u) : this.aabb.extend(u)
                }
                this.aabbNeedsUpdate = !1
            },
            s.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes,
                e = t.length,
                i = 0,
                s = 0; s !== e; s++) {
                    var r = t[s],
                    o = n.length(r.position),
                    a = r.boundingRadius;
                    o + a > i && (i = o + a)
                }
                this.boundingRadius = i
            },
            s.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this,
                e ? n.copy(t.position, e) : n.set(t.position, 0, 0),
                t.angle = i || 0,
                this.shapes.push(t),
                this.updateMassProperties(),
                this.updateBoundingRadius(),
                this.aabbNeedsUpdate = !0
            },
            s.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return - 1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0)
            },
            s.prototype.updateMassProperties = function() {
                if (this.type === s.STATIC || this.type === s.KINEMATIC) this.mass = Number.MAX_VALUE,
                this.invMass = 0,
                this.inertia = Number.MAX_VALUE,
                this.invInertia = 0;
                else {
                    var t = this.shapes,
                    e = t.length,
                    i = this.mass / e,
                    r = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE,
                    this.invInertia = 0;
                    else {
                        for (var o = 0; o < e; o++) {
                            var a = t[o],
                            h = n.squaredLength(a.position);
                            r += a.computeMomentOfInertia(i) + i * h
                        }
                        this.inertia = r,
                        this.invInertia = r > 0 ? 1 / r: 0
                    }
                    this.invMass = 1 / this.mass,
                    n.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            },
            n.create(),
            s.prototype.applyForce = function(t, e) {
                if (n.add(this.force, this.force, t), e) {
                    var i = n.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var p = n.create(),
            f = n.create(),
            g = n.create();
            s.prototype.applyForceLocal = function(t, e) {
                e = e || g;
                var i = p,
                s = f;
                this.vectorToWorldFrame(i, t),
                this.vectorToWorldFrame(s, e),
                this.applyForce(i, s)
            };
            var m = n.create();
            s.prototype.applyImpulse = function(t, e) {
                if (this.type === s.DYNAMIC) {
                    var i = m;
                    if (n.scale(i, t, this.invMass), n.multiply(i, this.massMultiplier, i), n.add(this.velocity, i, this.velocity), e) {
                        var r = n.crossLength(e, t);
                        r *= this.invInertia,
                        this.angularVelocity += r
                    }
                }
            };
            var y = n.create(),
            v = n.create(),
            x = n.create();
            s.prototype.applyImpulseLocal = function(t, e) {
                e = e || x;
                var i = y,
                s = v;
                this.vectorToWorldFrame(i, t),
                this.vectorToWorldFrame(s, e),
                this.applyImpulse(i, s)
            },
            s.prototype.toLocalFrame = function(t, e) {
                n.toLocalFrame(t, e, this.position, this.angle)
            },
            s.prototype.toWorldFrame = function(t, e) {
                n.toGlobalFrame(t, e, this.position, this.angle)
            },
            s.prototype.vectorToLocalFrame = function(t, e) {
                n.vectorToLocalFrame(t, e, this.angle)
            },
            s.prototype.vectorToWorldFrame = function(t, e) {
                n.vectorToGlobalFrame(t, e, this.angle)
            },
            s.prototype.fromPolygon = function(t, e) {
                for (e = e || {},
                h = this.shapes.length; h >= 0; --h) this.removeShape(this.shapes[h]);
                var i, s = new r.Polygon;
                if (s.vertices = t, s.makeCCW(), "number" == typeof e.removeCollinearPoints && s.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !s.isSimple()) return ! 1;
                for (this.concavePath = s.vertices.slice(0), h = 0; h < this.concavePath.length; h++) u = [0, 0],
                n.copy(u, this.concavePath[h]),
                this.concavePath[h] = u;
                i = e.optimalDecomp ? s.decomp() : s.quickDecomp();
                for (var a = n.create(), h = 0; h !== i.length; h++) {
                    for (var l = new o({
                        vertices: i[h].vertices
                    }), c = 0; c !== l.vertices.length; c++) {
                        var u = l.vertices[c];
                        n.sub(u, u, l.centerOfMass)
                    }
                    n.scale(a, l.centerOfMass, 1),
                    l.updateTriangles(),
                    l.updateCenterOfMass(),
                    l.updateBoundingRadius(),
                    this.addShape(l, a)
                }
                return this.adjustCenterOfMass(),
                this.aabbNeedsUpdate = !0,
                !0
            },
            n.fromValues(0, 0);
            var b = n.fromValues(0, 0),
            _ = n.fromValues(0, 0),
            w = n.fromValues(0, 0);
            s.prototype.adjustCenterOfMass = function() {
                var t = b,
                e = _,
                i = w,
                s = 0;
                for (n.set(e, 0, 0), o = 0; o !== this.shapes.length; o++) r = this.shapes[o],
                n.scale(t, r.position, r.area),
                n.add(e, e, t),
                s += r.area;
                for (n.scale(i, e, 1 / s), o = 0; o !== this.shapes.length; o++) {
                    var r = this.shapes[o];
                    n.sub(r.position, r.position, i)
                }
                n.add(this.position, this.position, i);
                for (var o = 0; this.concavePath && o < this.concavePath.length; o++) n.sub(this.concavePath[o], this.concavePath[o], i);
                this.updateMassProperties(),
                this.updateBoundingRadius()
            },
            s.prototype.setZeroForce = function() {
                n.set(this.force, 0, 0),
                this.angularForce = 0
            },
            s.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                n.set(t, 0, 0),
                this.wlambda = 0
            },
            s.prototype.addConstraintVelocity = function() {
                var t = this,
                e = t.velocity;
                n.add(e, e, t.vlambda),
                t.angularVelocity += t.wlambda
            },
            s.prototype.applyDamping = function(t) {
                if (this.type === s.DYNAMIC) {
                    var e = this.velocity;
                    n.scale(e, e, Math.pow(1 - this.damping, t)),
                    this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            },
            s.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = s.AWAKE,
                this.idleTime = 0,
                t !== s.AWAKE && this.emit(s.wakeUpEvent)
            },
            s.prototype.sleep = function() {
                this.sleepState = s.SLEEPING,
                this.angularVelocity = 0,
                this.angularForce = 0,
                n.set(this.velocity, 0, 0),
                n.set(this.force, 0, 0),
                this.emit(s.sleepEvent)
            },
            s.prototype.sleepTick = function(t, e, i) {
                this.allowSleep && this.type !== s.SLEEPING && (this.wantsToSleep = !1, this.sleepState, n.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = s.AWAKE) : (this.idleTime += i, this.sleepState = s.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep()))
            },
            s.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var T = n.create(),
            P = n.create();
            s.prototype.integrate = function(t) {
                var e = this.invMass,
                i = this.force,
                s = this.position,
                r = this.velocity;
                n.copy(this.previousPosition, this.position),
                this.previousAngle = this.angle,
                this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t),
                n.scale(T, i, t * e),
                n.multiply(T, this.massMultiplier, T),
                n.add(r, T, r),
                this.integrateToTimeOfImpact(t) || (n.scale(P, r, t), n.add(s, s, P), this.fixedRotation || (this.angle += this.angularVelocity * t)),
                this.aabbNeedsUpdate = !0
            };
            var C = new a,
            S = new h({
                mode: h.ALL
            }),
            A = n.create(),
            E = n.create(),
            M = n.create(),
            R = n.create();
            s.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || n.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return ! 1;
                n.normalize(A, this.velocity),
                n.scale(E, this.velocity, t),
                n.add(E, E, this.position),
                n.sub(M, E, this.position);
                var e, i = this.angularVelocity * t,
                s = n.length(M),
                r = 1,
                o = this;
                if (C.reset(), S.callback = function(t) {
                    t.body !== o && (e = t.body, t.getHitPoint(E, S), n.sub(M, E, o.position), r = n.length(M) / s, t.stop())
                },
                n.copy(S.from, this.position), n.copy(S.to, E), S.update(), this.world.raycast(C, S), !e) return ! 1;
                var a = this.angle;
                n.copy(R, this.position);
                for (var h = 0,
                l = 0,
                c = 0,
                u = r; u >= l && h < this.ccdIterations;) h++,
                c = (u - l) / 2,
                n.scale(P, M, r),
                n.add(this.position, R, P),
                this.angle = a + i * r,
                this.updateAABB(),
                this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? l = c: u = c;
                return r = c,
                n.copy(this.position, R),
                this.angle = a,
                n.scale(P, M, r),
                n.add(this.position, this.position, P),
                this.fixedRotation || (this.angle += i * r),
                !0
            },
            s.prototype.getVelocityAtPoint = function(t, e) {
                return n.crossVZ(t, e, this.angularVelocity),
                n.subtract(t, this.velocity, t),
                t
            },
            s.sleepyEvent = {
                type: "sleepy"
            },
            s.sleepEvent = {
                type: "sleep"
            },
            s.wakeUpEvent = {
                type: "wakeup"
            },
            s.DYNAMIC = 1,
            s.STATIC = 2,
            s.KINEMATIC = 4,
            s.AWAKE = 0,
            s.SLEEPY = 1,
            s.SLEEPING = 2
        },
        {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                r.call(this, t, e, i),
                this.localAnchorA = n.fromValues(0, 0),
                this.localAnchorB = n.fromValues(0, 0),
                i.localAnchorA && n.copy(this.localAnchorA, i.localAnchorA),
                i.localAnchorB && n.copy(this.localAnchorB, i.localAnchorB),
                i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA),
                i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var s = n.create(),
                o = n.create();
                this.getWorldAnchorA(s),
                this.getWorldAnchorB(o);
                var a = n.distance(s, o);
                this.restLength = "number" == typeof i.restLength ? i.restLength: a
            }
            var n = t("../math/vec2"),
            r = t("./Spring");
            t("../utils/Utils"),
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            },
            s.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            },
            s.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            },
            s.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var o = n.create(),
            a = n.create(),
            h = n.create(),
            l = n.create(),
            c = n.create(),
            u = n.create(),
            d = n.create(),
            p = n.create(),
            f = n.create();
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                e = this.damping,
                i = this.restLength,
                s = this.bodyA,
                r = this.bodyB,
                g = o,
                m = a,
                y = h,
                v = l,
                x = f,
                b = c,
                _ = u,
                w = d,
                T = p;
                this.getWorldAnchorA(b),
                this.getWorldAnchorB(_),
                n.sub(w, b, s.position),
                n.sub(T, _, r.position),
                n.sub(g, _, b);
                var P = n.len(g);
                n.normalize(m, g),
                n.sub(y, r.velocity, s.velocity),
                n.crossZV(x, r.angularVelocity, T),
                n.add(y, y, x),
                n.crossZV(x, s.angularVelocity, w),
                n.sub(y, y, x),
                n.scale(v, m, -t * (P - i) - e * n.dot(y, m)),
                n.sub(s.force, s.force, v),
                n.add(r.force, r.force, v);
                var C = n.crossLength(w, v),
                S = n.crossLength(T, v);
                s.angularForce -= C,
                r.angularForce += S
            }
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33 : [function(t, e, i) {
            function s(t, e, i) {
                i = i || {},
                n.call(this, t, e, i),
                this.restAngle = "number" == typeof i.restAngle ? i.restAngle: e.angle - t.angle
            }
            t("../math/vec2");
            var n = t("./Spring");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                e = this.damping,
                i = this.restAngle,
                s = this.bodyA,
                n = this.bodyB,
                r = -t * (n.angle - s.angle - i) - e * (n.angularVelocity - s.angularVelocity) * 0;
                s.angularForce -= r,
                n.angularForce += r
            }
        },
        {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34 : [function(t, e, i) {
            function s(t, e, i) {
                i = n.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }),
                this.stiffness = i.stiffness,
                this.damping = i.damping,
                this.bodyA = t,
                this.bodyB = e
            }
            t("../math/vec2");
            var n = t("../utils/Utils");
            e.exports = s,
            s.prototype.applyForce = function() {}
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35 : [function(t, e, i) {
            function s(t, e) {
                e = e || {},
                this.chassisBody = t,
                this.wheels = [],
                this.groundBody = new h({
                    mass: 0
                }),
                this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }
            function n(t, e) {
                e = e || {},
                this.vehicle = t,
                this.forwardEquation = new a(t.chassisBody, t.groundBody),
                this.sideEquation = new a(t.chassisBody, t.groundBody),
                this.steerValue = 0,
                this.engineForce = 0,
                this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction: 5),
                this.localForwardVector = r.fromValues(0, 1),
                e.localForwardVector && r.copy(this.localForwardVector, e.localForwardVector),
                this.localPosition = r.fromValues(0, 0),
                e.localPosition && r.copy(this.localPosition, e.localPosition),
                o.apply(this, t.chassisBody, t.groundBody),
                this.equations.push(this.forwardEquation, this.sideEquation),
                this.setBrakeForce(0)
            }
            var r = t("../math/vec2"),
            o = (t("../utils/Utils"), t("../constraints/Constraint")),
            a = t("../equations/FrictionEquation"),
            h = t("../objects/Body");
            e.exports = s,
            s.prototype.addToWorld = function(t) {
                this.world = t,
                t.addBody(this.groundBody),
                t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            },
            s.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody),
                t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            },
            s.prototype.addWheel = function(t) {
                var e = new n(this, t);
                return this.wheels.push(e),
                e
            },
            s.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            },
            (n.prototype = new o).setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            },
            n.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = r.create(),
            c = r.create();
            n.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector),
                this.vehicle.chassisBody.getVelocityAtPoint(l, c),
                r.dot(l, c)
            };
            var u = r.create();
            n.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector),
                r.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2),
                this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t),
                r.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue),
                r.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue),
                this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition),
                r.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB),
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition),
                r.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA),
                r.normalize(u, this.forwardEquation.t),
                r.scale(u, u, this.engineForce),
                this.vehicle.chassisBody.applyForce(u, this.forwardEquation.contactPointA)
            }
        },
        {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36 : [function(t, e, i) {
            var s = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(s, "Rectangle", {
                get: function() {
                    return console.warn("The Rectangle class has been renamed to Box."),
                    this.Box
                }
            })
        },
        {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37 : [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    width: arguments[0],
                    height: arguments[1]
                },
                console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")),
                t = t || {};
                var e = this.width = t.width || 1,
                i = this.height = t.height || 1,
                s = [n.fromValues( - e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues( - e / 2, i / 2)],
                a = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = s,
                t.axes = a,
                t.type = r.BOX,
                o.call(this, t)
            }
            var n = t("../math/vec2"),
            r = t("./Shape"),
            o = t("./Convex");
            e.exports = s,
            (s.prototype = new o).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                i = this.height;
                return t * (i * i + e * e) / 12
            },
            s.prototype.updateBoundingRadius = function() {
                var t = this.width,
                e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            },
            n.create(),
            n.create(),
            n.create(),
            n.create(),
            s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            },
            s.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        },
        {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38 : [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    length: arguments[0],
                    radius: arguments[1]
                },
                console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")),
                t = t || {},
                this.length = t.length || 1,
                this.radius = t.radius || 1,
                t.type = n.CAPSULE,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                i = this.length + e,
                s = 2 * e;
                return t * (s * s + i * i) / 12
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            },
            s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var o = r.create();
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                r.set(o, this.length / 2, 0),
                0 !== i && r.rotate(o, o, i),
                r.set(t.upperBound, Math.max(o[0] + s, -o[0] + s), Math.max(o[1] + s, -o[1] + s)),
                r.set(t.lowerBound, Math.min(o[0] - s, -o[0] - s), Math.min(o[1] - s, -o[1] - s)),
                r.add(t.lowerBound, t.lowerBound, e),
                r.add(t.upperBound, t.upperBound, e)
            };
            var a = r.create(),
            h = r.create(),
            l = r.create(),
            c = r.create(),
            u = r.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                for (var n = e.from,
                o = e.to,
                d = (e.direction, a), p = h, f = l, g = c, m = this.length / 2, y = 0; y < 2; y++) {
                    var v = this.radius * (2 * y - 1);
                    if (r.set(f, -m, v), r.set(g, m, v), r.toGlobalFrame(f, f, i, s), r.toGlobalFrame(g, g, i, s), (T = r.getLineSegmentsIntersectionFraction(n, o, f, g)) >= 0 && (r.rotate(p, u, s), r.scale(p, p, 2 * y - 1), e.reportIntersection(t, T, p, -1), t.shouldStop(e))) return
                }
                var x = Math.pow(this.radius, 2) + Math.pow(m, 2);
                for (y = 0; y < 2; y++) {
                    r.set(f, m * (2 * y - 1), 0),
                    r.toGlobalFrame(f, f, i, s);
                    var b = Math.pow(o[0] - n[0], 2) + Math.pow(o[1] - n[1], 2),
                    _ = 2 * ((o[0] - n[0]) * (n[0] - f[0]) + (o[1] - n[1]) * (n[1] - f[1])),
                    w = Math.pow(n[0] - f[0], 2) + Math.pow(n[1] - f[1], 2) - Math.pow(this.radius, 2),
                    T = Math.pow(_, 2) - 4 * b * w;
                    if (! (T < 0)) if (0 === T) {
                        if (r.lerp(d, n, o, T), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, T, p, -1), t.shouldStop(e))) return
                    } else {
                        var P = Math.sqrt(T),
                        C = 1 / (2 * b),
                        S = ( - _ - P) * C,
                        A = ( - _ + P) * C;
                        if (S >= 0 && S <= 1 && (r.lerp(d, n, o, S), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, S, p, -1), t.shouldStop(e)))) return;
                        if (A >= 0 && A <= 1 && (r.lerp(d, n, o, A), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, A, p, -1), t.shouldStop(e)))) return
                    }
                }
            }
        },
        {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39 : [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    radius: arguments[0]
                },
                console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")),
                t = t || {},
                this.radius = t.radius || 1,
                t.type = n.CIRCLE,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            },
            s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            },
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                r.set(t.upperBound, s, s),
                r.set(t.lowerBound, -s, -s),
                e && (r.add(t.lowerBound, t.lowerBound, e), r.add(t.upperBound, t.upperBound, e))
            };
            var o = r.create(),
            a = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                h = e.to,
                l = this.radius,
                c = Math.pow(h[0] - n[0], 2) + Math.pow(h[1] - n[1], 2),
                u = 2 * ((h[0] - n[0]) * (n[0] - i[0]) + (h[1] - n[1]) * (n[1] - i[1])),
                d = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(l, 2),
                p = Math.pow(u, 2) - 4 * c * d,
                f = o,
                g = a;
                if (! (p < 0)) if (0 === p) r.lerp(f, n, h, p),
                r.sub(g, f, i),
                r.normalize(g, g),
                e.reportIntersection(t, p, g, -1);
                else {
                    var m = Math.sqrt(p),
                    y = 1 / (2 * c),
                    v = ( - u - m) * y,
                    x = ( - u + m) * y;
                    if (v >= 0 && v <= 1 && (r.lerp(f, n, h, v), r.sub(g, f, i), r.normalize(g, g), e.reportIntersection(t, v, g, -1), t.shouldStop(e))) return;
                    x >= 0 && x <= 1 && (r.lerp(f, n, h, x), r.sub(g, f, i), r.normalize(g, g), e.reportIntersection(t, x, g, -1))
                }
            }
        },
        {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40 : [function(t, e, i) {
            function s(t) {
                Array.isArray(arguments[0]) && (t = {
                    vertices: arguments[0],
                    axes: arguments[1]
                },
                console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")),
                t = t || {},
                this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices: [], i = 0; i < e.length; i++) {
                    var s = r.create();
                    r.copy(s, e[i]),
                    this.vertices.push(s)
                }
                if (this.axes = [], t.axes) for (i = 0; i < t.axes.length; i++) {
                    var o = r.create();
                    r.copy(o, t.axes[i]),
                    this.axes.push(o)
                } else for (i = 0; i < this.vertices.length; i++) {
                    var a = this.vertices[i],
                    h = this.vertices[(i + 1) % this.vertices.length],
                    l = r.create();
                    r.sub(l, h, a),
                    r.rotate90cw(l, l),
                    r.normalize(l, l),
                    this.axes.push(l)
                }
                if (this.centerOfMass = r.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = n.CONVEX, n.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var n = t("./Shape"),
            r = t("../math/vec2"),
            o = t("../math/polyk");
            t("poly-decomp"),
            e.exports = s,
            (s.prototype = new n).constructor = s;
            var a = r.create(),
            h = r.create();
            s.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, s, n = null,
                o = null,
                h = (t = a, 0); h < this.vertices.length; h++) i = this.vertices[h],
                s = r.dot(i, t),
                (null === n || s > n) && (n = s),
                (null === o || s < o) && (o = s);
                if (o > n) {
                    var l = o;
                    o = n,
                    n = l
                }
                r.set(e, o, n)
            },
            s.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                var n = h;
                this.projectOntoLocalAxis(t, s),
                0 !== i ? r.rotate(n, t, i) : n = t;
                var o = r.dot(e, n);
                r.set(s, s[0] + o, s[1] + o)
            },
            s.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var t = [], e = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                var s = o.Triangulate(t);
                for (e = 0; e < s.length; e += 3) {
                    var n = s[e],
                    r = s[e + 1],
                    a = s[e + 2];
                    this.triangles.push([n, r, a])
                }
            };
            var l = r.create(),
            c = r.create(),
            u = r.create(),
            d = r.create(),
            p = r.create();
            r.create(),
            r.create(),
            r.create(),
            r.create(),
            s.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                e = this.vertices,
                i = this.centerOfMass,
                n = l,
                o = u,
                a = d,
                h = p,
                f = c;
                r.set(i, 0, 0);
                for (var g = 0,
                m = 0; m !== t.length; m++) {
                    var y = t[m];
                    o = e[y[0]],
                    a = e[y[1]],
                    h = e[y[2]];
                    r.centroid(n, o, a, h);
                    var v = s.triangleArea(o, a, h);
                    g += v,
                    r.scale(f, n, v),
                    r.add(i, i, f)
                }
                r.scale(i, i, 1 / g)
            },
            s.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0,
                i = 0,
                s = this.vertices.length,
                n = s - 1,
                o = 0; o < s; n = o, o++) {
                    var a = this.vertices[n],
                    h = this.vertices[o],
                    l = Math.abs(r.crossLength(a, h));
                    e += l * (r.dot(h, h) + r.dot(h, a) + r.dot(a, a)),
                    i += l
                }
                return t / 6 * (e / i)
            },
            s.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices,
                e = 0,
                i = 0; i !== t.length; i++) {
                    var s = r.squaredLength(t[i]);
                    s > e && (e = s)
                }
                this.boundingRadius = Math.sqrt(e)
            },
            s.triangleArea = function(t, e, i) {
                return.5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            },
            s.prototype.updateArea = function() {
                this.updateTriangles(),
                this.area = 0;
                for (var t = this.triangles,
                e = this.vertices,
                i = 0; i !== t.length; i++) {
                    var n = t[i],
                    r = e[n[0]],
                    o = e[n[1]],
                    a = e[n[2]],
                    h = s.triangleArea(r, o, a);
                    this.area += h
                }
            },
            s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var f = r.create(),
            g = r.create(),
            m = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = f,
                o = g,
                a = m,
                h = this.vertices;
                r.toLocalFrame(n, e.from, i, s),
                r.toLocalFrame(o, e.to, i, s);
                for (var l = h.length,
                c = 0; c < l && !t.shouldStop(e); c++) {
                    var u = h[c],
                    d = h[(c + 1) % l],
                    p = r.getLineSegmentsIntersectionFraction(n, o, u, d);
                    p >= 0 && (r.sub(a, d, u), r.rotate(a, a, -Math.PI / 2 + s), r.normalize(a, a), e.reportIntersection(t, p, a, c))
                }
            }
        },
        {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41 : [function(t, e, i) {
            function s(t) {
                if (Array.isArray(arguments[0])) {
                    if (t = {
                        heights: arguments[0]
                    },
                    "object" == typeof arguments[1]) for (var e in arguments[1]) t[e] = arguments[1][e];
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                }
                t = t || {},
                this.heights = t.heights ? t.heights.slice(0) : [],
                this.maxValue = t.maxValue || null,
                this.minValue = t.minValue || null,
                this.elementWidth = t.elementWidth || .1,
                void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(),
                t.type = n.HEIGHTFIELD,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            t("../utils/Utils"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.updateMaxMinValues = function() {
                for (var t = this.heights,
                e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                    var n = t[s];
                    n > e && (e = n),
                    n < i && (i = n)
                }
                this.maxValue = e,
                this.minValue = i
            },
            s.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            },
            s.prototype.updateArea = function() {
                for (var t = this.heights,
                e = 0,
                i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var o = [r.create(), r.create(), r.create(), r.create()];
            s.prototype.computeAABB = function(t, e, i) {
                r.set(o[0], 0, this.maxValue),
                r.set(o[1], this.elementWidth * this.heights.length, this.maxValue),
                r.set(o[2], this.elementWidth * this.heights.length, this.minValue),
                r.set(o[3], 0, this.minValue),
                t.setFromPoints(o, e, i)
            },
            s.prototype.getLineSegment = function(t, e, i) {
                var s = this.heights,
                n = this.elementWidth;
                r.set(t, i * n, s[i]),
                r.set(e, (i + 1) * n, s[i + 1])
            },
            s.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            },
            s.prototype.getClampedSegmentIndex = function(t) {
                var e = this.getSegmentIndex(t);
                return Math.min(this.heights.length, Math.max(e, 0))
            },
            r.create();
            var a = r.create(),
            h = r.create(),
            l = r.create(),
            c = r.create(),
            u = r.create();
            r.fromValues(0, 1),
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                o = e.to,
                d = (e.direction, a),
                p = h,
                f = l,
                g = c,
                m = u;
                r.toLocalFrame(g, n, i, s),
                r.toLocalFrame(m, o, i, s);
                var y = this.getClampedSegmentIndex(g),
                v = this.getClampedSegmentIndex(m);
                if (y > v) {
                    var x = y;
                    y = v,
                    v = x
                }
                for (var b = 0; b < this.heights.length - 1; b++) {
                    this.getLineSegment(p, f, b);
                    var _ = r.getLineSegmentsIntersectionFraction(g, m, p, f);
                    if (_ >= 0 && (r.sub(d, f, p), r.rotate(d, d, s + Math.PI / 2), r.normalize(d, d), e.reportIntersection(t, _, d, -1), t.shouldStop(e))) return
                }
            }
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42 : [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    length: arguments[0]
                },
                console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")),
                t = t || {},
                this.length = t.length || 1,
                t.type = n.LINE,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var o = [r.create(), r.create()];
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.length / 2;
                r.set(o[0], -s, 0),
                r.set(o[1], s, 0),
                t.setFromPoints(o, e, i, 0)
            },
            r.create();
            var a = r.create(),
            h = r.create(),
            l = r.create(),
            c = r.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                o = e.to,
                u = h,
                d = l,
                p = this.length / 2;
                r.set(u, -p, 0),
                r.set(d, p, 0),
                r.toGlobalFrame(u, u, i, s),
                r.toGlobalFrame(d, d, i, s);
                var f = r.getLineSegmentsIntersectionFraction(u, d, n, o);
                if (f >= 0) {
                    var g = a;
                    r.rotate(g, c, s),
                    e.reportIntersection(t, f, g, -1)
                }
            }
        },
        {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43 : [function(t, e, i) {
            function s(t) { (t = t || {}).type = n.PARTICLE,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                return 0
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            },
            s.prototype.computeAABB = function(t, e, i) {
                r.copy(t.lowerBound, e),
                r.copy(t.upperBound, e)
            }
        },
        {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44 : [function(t, e, i) {
            function s(t) { (t = t || {}).type = n.PLANE,
                n.call(this, t)
            }
            var n = t("./Shape"),
            r = t("../math/vec2");
            t("../utils/Utils"),
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.computeMomentOfInertia = function(t) {
                return 0
            },
            s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            },
            s.prototype.computeAABB = function(t, e, i) {
                var s = i % (2 * Math.PI),
                n = r.set,
                o = t.lowerBound,
                a = t.upperBound;
                n(o, -1e7, -1e7),
                n(a, 1e7, 1e7),
                0 === s ? a[1] = 0 : s === Math.PI / 2 ? o[0] = 0 : s === Math.PI ? o[1] = 0 : s === 3 * Math.PI / 2 && (a[0] = 0)
            },
            s.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var o = r.create(),
            a = (r.create(), r.create(), r.create()),
            h = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                l = e.to,
                c = e.direction,
                u = o,
                d = a,
                p = h;
                r.set(d, 0, 1),
                r.rotate(d, d, s),
                r.sub(p, n, i);
                var f = r.dot(p, d);
                if (r.sub(p, l, i), !(f * r.dot(p, d) > 0 || r.squaredDistance(n, l) < f * f)) {
                    var g = r.dot(d, c);
                    r.sub(u, n, i);
                    var m = -r.dot(d, u) / g / e.length;
                    e.reportIntersection(t, m, d, -1)
                }
            }
        },
        {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45 : [function(t, e, i) {
            function s(t) {
                t = t || {},
                this.body = null,
                this.position = n.fromValues(0, 0),
                t.position && n.copy(this.position, t.position),
                this.angle = t.angle || 0,
                this.type = t.type || 0,
                this.id = s.idCounter++,
                this.boundingRadius = 0,
                this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup: 1,
                this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse,
                this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask: 1,
                this.material = t.material || null,
                this.area = 0,
                this.sensor = void 0 !== t.sensor && t.sensor,
                this.type && this.updateBoundingRadius(),
                this.updateArea()
            }
            e.exports = s;
            var n = t("../math/vec2");
            s.idCounter = 0,
            s.CIRCLE = 1,
            s.PARTICLE = 2,
            s.PLANE = 4,
            s.CONVEX = 8,
            s.LINE = 16,
            s.BOX = 32,
            s.CAPSULE = 64,
            s.HEIGHTFIELD = 128,
            s.prototype.computeMomentOfInertia = function(t) {},
            s.prototype.updateBoundingRadius = function() {},
            s.prototype.updateArea = function() {},
            s.prototype.computeAABB = function(t, e, i) {},
            s.prototype.raycast = function(t, e, i, s) {}
        },
        {
            "../math/vec2": 30
        }],
        46 : [function(t, e, i) {
            function s(t) {
                r.call(this, t, r.GS),
                t = t || {},
                this.iterations = t.iterations || 10,
                this.tolerance = t.tolerance || 1e-7,
                this.arrayStep = 30,
                this.lambda = new o.ARRAY_TYPE(this.arrayStep),
                this.Bs = new o.ARRAY_TYPE(this.arrayStep),
                this.invCs = new o.ARRAY_TYPE(this.arrayStep),
                this.useZeroRHS = !1,
                this.frictionIterations = void 0 !== t.frictionIterations ? 0 : t.frictionIterations,
                this.usedIterations = 0
            }
            var n = t("../math/vec2"),
            r = t("./Solver"),
            o = t("../utils/Utils"),
            a = t("../equations/FrictionEquation");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.solve = function(t, e) {
                this.sortEquations();
                var i, r, h, l = 0,
                c = this.iterations,
                u = this.frictionIterations,
                d = this.equations,
                p = d.length,
                f = Math.pow(this.tolerance * p, 2),
                g = e.bodies,
                m = e.bodies.length,
                y = (n.add, n.set, this.useZeroRHS),
                v = this.lambda;
                if (this.usedIterations = 0, p) for (_ = 0; _ !== m; _++)(w = g[_]).updateSolveMassProperties();
                v.length < p && (v = this.lambda = new o.ARRAY_TYPE(p + this.arrayStep), this.Bs = new o.ARRAY_TYPE(p + this.arrayStep), this.invCs = new o.ARRAY_TYPE(p + this.arrayStep)),
                function(t) {
                    for (var e = t.length; e--;) t[e] = 0
                } (v);
                for (var x = this.invCs,
                b = this.Bs,
                _ = (v = this.lambda, 0); _ !== d.length; _++)((i = d[_]).timeStep !== t || i.needsUpdate) && (i.timeStep = t, i.update()),
                b[_] = i.computeB(i.a, i.b, t),
                x[_] = i.computeInvC(i.epsilon);
                if (0 !== p) {
                    for (_ = 0; _ !== m; _++) {
                        var w = g[_];
                        w.resetConstraintVelocity()
                    }
                    if (u) {
                        for (l = 0; l !== u; l++) {
                            for (r = 0, h = 0; h !== p; h++) i = d[h],
                            S = s.iterateEquation(h, i, i.epsilon, b, x, v, y, t, l),
                            r += Math.abs(S);
                            if (this.usedIterations++, r * r <= f) break
                        }
                        for (s.updateMultipliers(d, v, 1 / t), h = 0; h !== p; h++) {
                            var T = d[h];
                            if (T instanceof a) {
                                for (var P = 0,
                                C = 0; C !== T.contactEquations.length; C++) P += T.contactEquations[C].multiplier;
                                P *= T.frictionCoefficient / T.contactEquations.length,
                                T.maxForce = P,
                                T.minForce = -P
                            }
                        }
                    }
                    for (l = 0; l !== c; l++) {
                        for (r = 0, h = 0; h !== p; h++) {
                            i = d[h];
                            var S = s.iterateEquation(h, i, i.epsilon, b, x, v, y, t, l);
                            r += Math.abs(S)
                        }
                        if (this.usedIterations++, r * r <= f) break
                    }
                    for (_ = 0; _ !== m; _++) g[_].addConstraintVelocity();
                    s.updateMultipliers(d, v, 1 / t)
                }
            },
            s.updateMultipliers = function(t, e, i) {
                for (var s = t.length; s--;) t[s].multiplier = e[s] * i
            },
            s.iterateEquation = function(t, e, i, s, n, r, o, a, h) {
                var l = s[t],
                c = n[t],
                u = r[t],
                d = e.computeGWlambda(),
                p = e.maxForce,
                f = e.minForce;
                o && (l = 0);
                var g = c * (l - d - i * u),
                m = u + g;
                return m < f * a ? g = f * a - u: m > p * a && (g = p * a - u),
                r[t] += g,
                e.addToWlambda(g),
                g
            }
        },
        {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47 : [function(t, e, i) {
            function s(t, e) {
                t = t || {},
                n.call(this),
                this.type = e,
                this.equations = [],
                this.equationSortFunction = t.equationSortFunction || !1
            }
            t("../utils/Utils");
            var n = t("../events/EventEmitter");
            e.exports = s,
            (s.prototype = new n).constructor = s,
            s.prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var r = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(),
                e.equations.length && (this.addEquations(e.equations), r.bodies.length = 0, e.getBodies(r.bodies), r.bodies.length && this.solve(t, r))
            },
            s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            },
            s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            },
            s.prototype.addEquations = function(t) {
                for (var e = 0,
                i = t.length; e !== i; e++) {
                    var s = t[e];
                    s.enabled && this.equations.push(s)
                }
            },
            s.prototype.removeEquation = function(t) {
                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
            },
            s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            },
            s.GS = 1,
            s.ISLAND = 2
        },
        {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48 : [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../equations/ContactEquation"),
            r = t("./Pool");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.create = function() {
                return new n
            },
            s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null,
                this
            }
        },
        {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49 : [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../equations/FrictionEquation"),
            r = t("./Pool");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.create = function() {
                return new n
            },
            s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null,
                this
            }
        },
        {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50 : [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../world/IslandNode"),
            r = t("./Pool");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.create = function() {
                return new n
            },
            s.prototype.destroy = function(t) {
                return t.reset(),
                this
            }
        },
        {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51 : [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../world/Island"),
            r = t("./Pool");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.create = function() {
                return new n
            },
            s.prototype.destroy = function(t) {
                return t.reset(),
                this
            }
        },
        {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52 : [function(t, e, i) {
            function s() {
                this.overlappingShapesLastState = new n,
                this.overlappingShapesCurrentState = new n,
                this.recordPool = new r({
                    size: 16
                }),
                this.tmpDict = new n,
                this.tmpArray1 = []
            }
            var n = t("./TupleDictionary"),
            r = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils"),
            e.exports = s,
            s.prototype.tick = function() {
                for (var t = this.overlappingShapesLastState,
                e = this.overlappingShapesCurrentState,
                i = t.keys.length; i--;) {
                    var s = t.keys[i],
                    n = t.getByKey(s);
                    e.getByKey(s),
                    n && this.recordPool.release(n)
                }
                t.reset(),
                t.copy(e),
                e.reset()
            },
            s.prototype.setOverlapping = function(t, e, i, s) {
                this.overlappingShapesLastState;
                var n = this.overlappingShapesCurrentState;
                if (!n.get(e.id, s.id)) {
                    var r = this.recordPool.get();
                    r.set(t, e, i, s),
                    n.set(e.id, s.id, r)
                }
            },
            s.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            },
            s.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            },
            s.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState,
                s = i.keys.length; s--;) {
                    var n = i.keys[s],
                    r = i.data[n];
                    if (r.bodyA === t && r.bodyB === e || r.bodyA === e && r.bodyB === t) return ! 0
                }
                return ! 1
            },
            s.prototype.getDiff = function(t, e, i) {
                var s = t,
                n = e; (i = i || []).length = 0;
                for (var r = n.keys.length; r--;) {
                    var o = n.keys[r],
                    a = n.data[o];
                    if (!a) throw new Error("Key " + o + " had no data!");
                    s.data[o] || i.push(a)
                }
                return i
            },
            s.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                s = 0 | e.id,
                n = this.overlappingShapesLastState,
                r = this.overlappingShapesCurrentState;
                return ! n.get(i, s) && !!r.get(i, s)
            },
            s.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            },
            s.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            },
            s.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict,
                s = t.length; s--;) {
                    var n = t[s];
                    i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                }
                for (s = i.keys.length; s--;)(n = i.getByKey(i.keys[s])) && e.push(n.bodyA, n.bodyB);
                return i.reset(),
                e
            }
        },
        {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53 : [function(t, e, i) {
            function s(t, e, i, s) {
                this.shapeA = e,
                this.shapeB = s,
                this.bodyA = t,
                this.bodyB = i
            }
            e.exports = s,
            s.prototype.set = function(t, e, i, n) {
                s.call(this, t, e, i, n)
            }
        },
        {}],
        54 : [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("./OverlapKeeperRecord"),
            r = t("./Pool");
            e.exports = s,
            (s.prototype = new r).constructor = s,
            s.prototype.create = function() {
                return new n
            },
            s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null,
                this
            }
        },
        {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55 : [function(t, e, i) {
            function s(t) {
                t = t || {},
                this.objects = [],
                void 0 !== t.size && this.resize(t.size)
            }
            e.exports = s,
            s.prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            },
            s.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            },
            s.prototype.release = function(t) {
                return this.destroy(t),
                this.objects.push(t),
                this
            }
        },
        {}],
        56 : [function(t, e, i) {
            function s() {
                this.data = {},
                this.keys = []
            }
            var n = t("./Utils");
            e.exports = s,
            s.prototype.getKey = function(t, e) {
                return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e: e << 16 | 65535 & t)
            },
            s.prototype.getByKey = function(t) {
                return t |= 0,
                this.data[t]
            },
            s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            },
            s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                var s = this.getKey(t, e);
                return this.data[s] || this.keys.push(s),
                this.data[s] = i,
                s
            },
            s.prototype.reset = function() {
                for (var t = this.data,
                e = this.keys,
                i = e.length; i--;) delete t[e[i]];
                e.length = 0
            },
            s.prototype.copy = function(t) {
                this.reset(),
                n.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        },
        {
            "./Utils": 57
        }],
        57 : [function(t, e, i) {
            function s() {}
            e.exports = s,
            s.appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else for (var i = 0,
                s = e.length; i !== s; ++i) t.push(e[i])
            },
            s.splice = function(t, e, i) {
                i = i || 1;
                for (var s = e,
                n = t.length - i; s < n; s++) t[s] = t[s + i];
                t.length = n
            },
            s.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE: "undefined" != typeof Float32Array ? Float32Array: Array,
            s.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            },
            s.defaults = function(t, e) {
                for (var i in t = t || {},
                e) i in t || (t[i] = e[i]);
                return t
            }
        },
        {}],
        58 : [function(t, e, i) {
            function s() {
                this.equations = [],
                this.bodies = []
            }
            var n = t("../objects/Body");
            e.exports = s,
            s.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var r = [];
            s.prototype.getBodies = function(t) {
                var e = t || [],
                i = this.equations;
                r.length = 0;
                for (var s = 0; s !== i.length; s++) {
                    var n = i[s]; - 1 === r.indexOf(n.bodyA.id) && (e.push(n.bodyA), r.push(n.bodyA.id)),
                    -1 === r.indexOf(n.bodyB.id) && (e.push(n.bodyB), r.push(n.bodyB.id))
                }
                return e
            },
            s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === n.DYNAMIC && !e.wantsToSleep) return ! 1
                }
                return ! 0
            },
            s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) this.bodies[t].sleep();
                return ! 0
            }
        },
        {
            "../objects/Body": 31
        }],
        59 : [function(t, e, i) {
            function s(t) {
                this.nodePool = new n({
                    size: 16
                }),
                this.islandPool = new r({
                    size: 8
                }),
                this.equations = [],
                this.islands = [],
                this.nodes = [],
                this.queue = []
            }
            t("../math/vec2"),
            t("./Island"),
            t("./IslandNode");
            var n = t("./../utils/IslandNodePool"),
            r = t("./../utils/IslandPool"),
            o = t("../objects/Body");
            e.exports = s,
            s.getUnvisitedNode = function(t) {
                for (var e = t.length,
                i = 0; i !== e; i++) {
                    var s = t[i];
                    if (!s.visited && s.body.type === o.DYNAMIC) return s
                }
                return ! 1
            },
            s.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var s = t.equations.length,
                n = 0; n !== s; n++) {
                    var r = t.equations[n]; - 1 === i.indexOf(r) && i.push(r)
                }
            },
            s.prototype.bfs = function(t, e, i) {
                var n = this.queue;
                for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, i); n.length;) for (var r, a = n.pop(); r = s.getUnvisitedNode(a.neighbors);) r.visited = !0,
                this.visit(r, e, i),
                r.body.type === o.DYNAMIC && n.push(r)
            },
            s.prototype.split = function(t) {
                for (var e = t.bodies,
                i = this.nodes,
                n = this.equations; i.length;) this.nodePool.release(i.pop());
                for (h = 0; h !== e.length; h++) {
                    var r = this.nodePool.get();
                    r.body = e[h],
                    i.push(r)
                }
                for (var o = 0; o !== n.length; o++) {
                    var a = n[o],
                    h = e.indexOf(a.bodyA),
                    l = e.indexOf(a.bodyB),
                    c = i[h],
                    u = i[l];
                    c.neighbors.push(u),
                    u.neighbors.push(c),
                    c.equations.push(a),
                    u.equations.push(a)
                }
                var d = this.islands;
                for (h = 0; h < d.length; h++) this.islandPool.release(d[h]);
                d.length = 0;
                for (var p; p = s.getUnvisitedNode(i);) {
                    var f = this.islandPool.get();
                    this.bfs(p, f.bodies, f.equations),
                    d.push(f)
                }
                return d
            }
        },
        {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60 : [function(t, e, i) {
            function s(t) {
                this.body = t,
                this.neighbors = [],
                this.equations = [],
                this.visited = !1
            }
            e.exports = s,
            s.prototype.reset = function() {
                this.equations.length = 0,
                this.neighbors.length = 0,
                this.visited = !1,
                this.body = null
            }
        },
        {}],
        61 : [function(t, e, i) {
            function s(t) {
                u.apply(this),
                t = t || {},
                this.springs = [],
                this.bodies = [],
                this.disabledBodyCollisionPairs = [],
                this.solver = t.solver || new n,
                this.narrowphase = new y(this),
                this.islandManager = new b,
                this.gravity = r.fromValues(0, -9.78),
                t.gravity && r.copy(this.gravity, t.gravity),
                this.frictionGravity = r.length(this.gravity) || 10,
                this.useWorldGravityAsFrictionGravity = !0,
                this.useFrictionGravityOnZeroGravity = !0,
                this.broadphase = t.broadphase || new m,
                this.broadphase.setWorld(this),
                this.constraints = [],
                this.defaultMaterial = new p,
                this.defaultContactMaterial = new f(this.defaultMaterial, this.defaultMaterial),
                this.lastTimeStep = 1 / 60,
                this.applySpringForces = !0,
                this.applyDamping = !0,
                this.applyGravity = !0,
                this.solveConstraints = !0,
                this.contactMaterials = [],
                this.time = 0,
                this.accumulator = 0,
                this.stepping = !1,
                this.bodiesToBeRemoved = [],
                this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit,
                this.emitImpactEvent = !0,
                this._constraintIdCounter = 0,
                this._bodyIdCounter = 0,
                this.postStepEvent = {
                    type: "postStep"
                },
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                },
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                },
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                },
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                },
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                },
                this.sleepMode = s.NO_SLEEPING,
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                },
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                },
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                },
                this.overlappingShapesLastState = {
                    keys: []
                },
                this.overlappingShapesCurrentState = {
                    keys: []
                },
                this.overlapKeeper = new x
            }
            var n = t("../solver/GSSolver"),
            r = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
            o = t("../shapes/Circle"),
            a = t("../shapes/Convex"),
            h = (t("../shapes/Line"), t("../shapes/Plane")),
            l = t("../shapes/Capsule"),
            c = t("../shapes/Particle"),
            u = t("../events/EventEmitter"),
            d = t("../objects/Body"),
            p = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
            f = t("../material/ContactMaterial"),
            g = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
            m = t("../collision/SAPBroadphase"),
            y = t("../collision/Narrowphase"),
            v = t("../utils/Utils"),
            x = t("../utils/OverlapKeeper"),
            b = t("./IslandManager");
            t("../objects/RotationalSpring"),
            e.exports = s,
            s.prototype = new Object(u.prototype),
            s.prototype.constructor = s,
            s.NO_SLEEPING = 1,
            s.BODY_SLEEPING = 2,
            s.ISLAND_SLEEPING = 4,
            s.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            },
            s.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            },
            s.prototype.removeContactMaterial = function(t) {
                var e = this.contactMaterials.indexOf(t); - 1 !== e && v.splice(this.contactMaterials, e, 1)
            },
            s.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials,
                s = 0,
                n = i.length; s !== n; s++) {
                    var r = i[s];
                    if (r.materialA.id === t.id && r.materialB.id === e.id || r.materialA.id === e.id && r.materialB.id === t.id) return r
                }
                return ! 1
            },
            s.prototype.removeConstraint = function(t) {
                var e = this.constraints.indexOf(t); - 1 !== e && v.splice(this.constraints, e, 1)
            },
            r.create(),
            r.create(),
            r.create(),
            r.create(),
            r.create(),
            r.create();
            var _ = r.create(),
            w = r.fromValues(0, 0),
            T = r.fromValues(0, 0);
            r.fromValues(0, 0),
            r.fromValues(0, 0),
            s.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t),
                this.time += t;
                else {
                    this.accumulator += e;
                    for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t),
                    this.time += t,
                    this.accumulator -= t,
                    s++;
                    for (var n = this.accumulator % t / t,
                    o = 0; o !== this.bodies.length; o++) {
                        var a = this.bodies[o];
                        r.lerp(a.interpolatedPosition, a.previousPosition, a.position, n),
                        a.interpolatedAngle = a.previousAngle + n * (a.angle - a.previousAngle)
                    }
                }
            };
            var P = [];
            s.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                i = this.springs,
                n = this.bodies,
                o = this.gravity,
                a = this.solver,
                h = this.bodies.length,
                l = this.broadphase,
                c = this.narrowphase,
                u = this.constraints,
                p = _,
                f = (r.scale, r.add),
                g = (r.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var m = r.length(this.gravity);
                    0 === m && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = m)
                }
                if (this.applyGravity) for (T = 0; T !== h; T++) {
                    var y = (x = n[T]).force;
                    x.type === d.DYNAMIC && x.sleepState !== d.SLEEPING && (r.scale(p, o, x.mass * x.gravityScale), f(y, y, p))
                }
                if (this.applySpringForces) for (T = 0; T !== e; T++) i[T].applyForce();
                if (this.applyDamping) for (T = 0; T !== h; T++) {
                    var x = n[T];
                    x.type === d.DYNAMIC && x.applyDamping(t)
                }
                for (var b = l.getCollisionPairs(this), w = this.disabledBodyCollisionPairs, T = w.length - 2; T >= 0; T -= 2) for (S = b.length - 2; S >= 0; S -= 2)(w[T] === b[S] && w[T + 1] === b[S + 1] || w[T + 1] === b[S] && w[T] === b[S + 1]) && b.splice(S, 2);
                for (H = u.length, T = 0; T !== H; T++) {
                    var C = u[T];
                    if (!C.collideConnected) for (var S = b.length - 2; S >= 0; S -= 2)(C.bodyA === b[S] && C.bodyB === b[S + 1] || C.bodyB === b[S] && C.bodyA === b[S + 1]) && b.splice(S, 2)
                }
                this.postBroadphaseEvent.pairs = b,
                this.emit(this.postBroadphaseEvent),
                this.postBroadphaseEvent.pairs = null,
                c.reset(this);
                T = 0;
                for (var A = b.length; T !== A; T += 2) for (var E = b[T], M = b[T + 1], R = 0, L = E.shapes.length; R !== L; R++) for (var B = E.shapes[R], I = B.position, O = B.angle, k = 0, F = M.shapes.length; k !== F; k++) {
                    var D = M.shapes[k],
                    U = D.position,
                    G = D.angle,
                    N = this.defaultContactMaterial;
                    if (B.material && D.material) {
                        var X = this.getContactMaterial(B.material, D.material);
                        X && (N = X)
                    }
                    this.runNarrowphase(c, E, B, I, O, M, D, U, G, N, this.frictionGravity)
                }
                for (T = 0; T !== h; T++)(q = n[T])._wakeUpAfterNarrowphase && (q.wakeUp(), q._wakeUpAfterNarrowphase = !1);
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(P);
                    var W = this.endContactEvent;
                    for (k = P.length; k--;) {
                        var j = P[k];
                        W.shapeA = j.shapeA,
                        W.shapeB = j.shapeB,
                        W.bodyA = j.bodyA,
                        W.bodyB = j.bodyB,
                        this.emit(W)
                    }
                    P.length = 0
                }
                var V = this.preSolveEvent;
                V.contactEquations = c.contactEquations,
                V.frictionEquations = c.frictionEquations,
                this.emit(V),
                V.contactEquations = V.frictionEquations = null;
                var H = u.length;
                for (T = 0; T !== H; T++) u[T].update();
                if (c.contactEquations.length || c.frictionEquations.length || H) if (this.islandSplit) {
                    for (g.equations.length = 0, v.appendArray(g.equations, c.contactEquations), v.appendArray(g.equations, c.frictionEquations), T = 0; T !== H; T++) v.appendArray(g.equations, u[T].equations);
                    for (g.split(this), T = 0; T !== g.islands.length; T++)(K = g.islands[T]).equations.length && a.solveIsland(t, K)
                } else {
                    for (a.addEquations(c.contactEquations), a.addEquations(c.frictionEquations), T = 0; T !== H; T++) a.addEquations(u[T].equations);
                    this.solveConstraints && a.solve(t, this),
                    a.removeAllEquations()
                }
                for (T = 0; T !== h; T++) {
                    var q = n[T];
                    q.integrate(t)
                }
                for (T = 0; T !== h; T++) n[T].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) {
                    var Y = this.impactEvent;
                    for (T = 0; T !== c.contactEquations.length; T++) {
                        var z = c.contactEquations[T];
                        z.firstImpact && (Y.bodyA = z.bodyA, Y.bodyB = z.bodyB, Y.shapeA = z.shapeA, Y.shapeB = z.shapeB, Y.contactEquation = z, this.emit(Y))
                    }
                }
                if (this.sleepMode === s.BODY_SLEEPING) for (T = 0; T !== h; T++) n[T].sleepTick(this.time, !1, t);
                else if (this.sleepMode === s.ISLAND_SLEEPING && this.islandSplit) {
                    for (T = 0; T !== h; T++) n[T].sleepTick(this.time, !0, t);
                    for (T = 0; T < this.islandManager.islands.length; T++) {
                        var K = this.islandManager.islands[T];
                        K.wantsToSleep() && K.sleep()
                    }
                }
                this.stepping = !1;
                var J = this.bodiesToBeRemoved;
                for (T = 0; T !== J.length; T++) this.removeBody(J[T]);
                J.length = 0,
                this.emit(this.postStepEvent)
            },
            s.prototype.runNarrowphase = function(t, e, i, s, n, o, a, h, l, c, u) {
                if (0 != (i.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & i.collisionMask)) {
                    r.rotate(w, s, e.angle),
                    r.rotate(T, h, o.angle),
                    r.add(w, w, e.position),
                    r.add(T, T, o.position);
                    var p, f = n + e.angle,
                    g = l + o.angle;
                    t.enableFriction = c.friction > 0,
                    t.frictionCoefficient = c.friction,
                    p = e.type === d.STATIC || e.type === d.KINEMATIC ? o.mass: o.type === d.STATIC || o.type === d.KINEMATIC ? e.mass: e.mass * o.mass / (e.mass + o.mass),
                    t.slipForce = c.friction * u * p,
                    t.restitution = c.restitution,
                    t.surfaceVelocity = c.surfaceVelocity,
                    t.frictionStiffness = c.frictionStiffness,
                    t.frictionRelaxation = c.frictionRelaxation,
                    t.stiffness = c.stiffness,
                    t.relaxation = c.relaxation,
                    t.contactSkinSize = c.contactSkinSize,
                    t.enabledEquations = e.collisionResponse && o.collisionResponse && i.collisionResponse && a.collisionResponse;
                    var m = t[i.type | a.type],
                    y = 0;
                    if (m) {
                        var v = i.sensor || a.sensor,
                        x = t.frictionEquations.length;
                        y = i.type < a.type ? m.call(t, e, i, w, f, o, a, T, g, v) : m.call(t, o, a, T, g, e, i, w, f, v);
                        var b = t.frictionEquations.length - x;
                        if (y) {
                            if (e.allowSleep && e.type === d.DYNAMIC && e.sleepState === d.SLEEPING && o.sleepState === d.AWAKE && o.type !== d.STATIC && r.squaredLength(o.velocity) + Math.pow(o.angularVelocity, 2) >= 2 * Math.pow(o.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0), o.allowSleep && o.type === d.DYNAMIC && o.sleepState === d.SLEEPING && e.sleepState === d.AWAKE && e.type !== d.STATIC && r.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (o._wakeUpAfterNarrowphase = !0), this.overlapKeeper.setOverlapping(e, i, o, a), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, a)) {
                                var _ = this.beginContactEvent;
                                if (_.shapeA = i, _.shapeB = a, _.bodyA = e, _.bodyB = o, _.contactEquations.length = 0, "number" == typeof y) for (P = t.contactEquations.length - y; P < t.contactEquations.length; P++) _.contactEquations.push(t.contactEquations[P]);
                                this.emit(_)
                            }
                            if ("number" == typeof y && b > 1) for (var P = t.frictionEquations.length - b; P < t.frictionEquations.length; P++) {
                                var C = t.frictionEquations[P];
                                C.setSlipForce(C.getSlipForce() / b)
                            }
                        }
                    }
                }
            },
            s.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t,
                this.emit(e),
                e.spring = null
            },
            s.prototype.removeSpring = function(t) {
                var e = this.springs.indexOf(t); - 1 !== e && v.splice(this.springs, e, 1)
            },
            s.prototype.addBody = function(t) {
                if ( - 1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t),
                    t.world = this;
                    var e = this.addBodyEvent;
                    e.body = t,
                    this.emit(e),
                    e.body = null
                }
            },
            s.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else {
                    t.world = null;
                    var e = this.bodies.indexOf(t); - 1 !== e && (v.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            },
            s.prototype.getBodyById = function(t) {
                for (var e = this.bodies,
                i = 0; i < e.length; i++) {
                    var s = e[i];
                    if (s.id === t) return s
                }
                return ! 1
            },
            s.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            },
            s.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs,
                s = 0; s < i.length; s += 2) if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
            },
            s.prototype.clear = function() {
                this.time = 0,
                this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints,
                e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                var i = this.bodies;
                for (e = i.length - 1; e >= 0; e--) this.removeBody(i[e]);
                var n = this.springs;
                for (e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]);
                var r = this.contactMaterials;
                for (e = r.length - 1; e >= 0; e--) this.removeContactMaterial(r[e]);
                s.apply(this)
            };
            var C = r.create(),
            S = (r.fromValues(0, 0), r.fromValues(0, 0));
            s.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var s = new d({
                    position: t
                }),
                n = new c,
                u = t,
                p = C,
                f = S;
                s.addShape(n);
                for (var g = this.narrowphase,
                m = [], y = 0, v = e.length; y !== v; y++) for (var x = e[y], b = 0, _ = x.shapes.length; b !== _; b++) {
                    var w = x.shapes[b];
                    r.rotate(p, w.position, x.angle),
                    r.add(p, p, x.position);
                    var T = w.angle + x.angle; (w instanceof o && g.circleParticle(x, w, p, T, s, n, u, 0, !0) || w instanceof a && g.particleConvex(s, n, u, 0, x, w, p, T, !0) || w instanceof h && g.particlePlane(s, n, u, 0, x, w, p, T, !0) || w instanceof l && g.particleCapsule(s, n, u, 0, x, w, p, T, !0) || w instanceof c && r.squaredLength(r.sub(f, p, t)) < i * i) && m.push(x)
                }
                return m
            },
            s.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints,
                i = 0; i !== e.length; i++) for (var s = e[i], n = 0; n !== s.equations.length; n++) {
                    var r = s.equations[n];
                    r.stiffness = t,
                    r.needsUpdate = !0
                }
                var o = this.contactMaterials;
                for (i = 0; i !== o.length; i++)(s = o[i]).stiffness = s.frictionStiffness = t; (s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
            },
            s.prototype.setGlobalRelaxation = function(t) {
                for (n = 0; n !== this.constraints.length; n++) for (var e = this.constraints[n], i = 0; i !== e.equations.length; i++) {
                    var s = e.equations[i];
                    s.relaxation = t,
                    s.needsUpdate = !0
                }
                for (var n = 0; n !== this.contactMaterials.length; n++)(e = this.contactMaterials[n]).relaxation = e.frictionRelaxation = t; (e = this.defaultContactMaterial).relaxation = e.frictionRelaxation = t
            };
            var A = new g,
            E = [];
            s.prototype.raycast = function(t, e) {
                return e.getAABB(A),
                this.broadphase.aabbQuery(this, A, E),
                e.intersectBodies(t, E),
                E.length = 0,
                t.hasHit()
            }
        },
        {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    },
    {},
    [36])(36)
}),
function() {
    function t(t, e, s, n) {
        var r = t.createTexture();
        return t.bindTexture(t.TEXTURE_2D, r),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === i.scaleModes.LINEAR ? t.LINEAR: t.NEAREST),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === i.scaleModes.LINEAR ? t.LINEAR: t.NEAREST),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, s, 0, t.RGBA, t.UNSIGNED_BYTE, null),
        r
    }
    function e(e, i, n, r, o) {
        var a, h, l = e.createFramebuffer(),
        c = e.createRenderbuffer();
        return e.activeTexture(e.TEXTURE0 + o),
        e.bindFramebuffer(e.FRAMEBUFFER, l),
        e.bindRenderbuffer(e.RENDERBUFFER, c),
        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this.renderBuffer),
        a = t(e, i, n, r),
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, a, 0),
        (h = e.checkFramebufferStatus(e.FRAMEBUFFER)) !== e.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", s[h]),
        l.width = i,
        l.height = n,
        l.targetTexture = a,
        l.renderBuffer = c,
        l
    }
    var i = i || {};
    i.DisplayObject = function() {
        this.position = new i.Point(0, 0),
        this.scale = new i.Point(1, 1),
        this.pivot = new i.Point(0, 0),
        this.rotation = 0,
        this.alpha = 1,
        this.visible = !0,
        this.hitArea = null,
        this.renderable = !1,
        this.parent = null,
        this.worldAlpha = 1,
        this.worldTransform = new Phaser.Matrix,
        this.worldPosition = new i.Point(0, 0),
        this.worldScale = new i.Point(1, 1),
        this.worldRotation = 0,
        this.filterArea = null,
        this._sr = 0,
        this._cr = 1,
        this._bounds = new i.Rectangle(0, 0, 0, 0),
        this._currentBounds = null,
        this._mask = null,
        this._cacheAsBitmap = !1,
        this._cacheIsDirty = !1
    },
    i.DisplayObject.prototype = {
        constructor: i.DisplayObject,
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null,
            this.parent = null,
            this.worldTransform = null,
            this.filterArea = null,
            this.renderable = !1,
            this._bounds = null,
            this._currentBounds = null,
            this._mask = null,
            this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var e = this.parent;
            t ? e = t: this.parent || (e = this.game.world);
            var i, s, n, r, o, a, h = e.worldTransform,
            l = this.worldTransform;
            this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty),
            i = l.a,
            s = l.b,
            n = l.c;
            var c = i * (r = l.d) - s * n;
            if (i || s) {
                var u = Math.sqrt(i * i + s * s);
                this.worldRotation = s > 0 ? Math.acos(i / u) : -Math.acos(i / u),
                this.worldScale.x = u,
                this.worldScale.y = c / u
            } else if (n || r) {
                var d = Math.sqrt(n * n + r * r);
                this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos( - n / d) : -Math.acos(n / d)),
                this.worldScale.x = c / d,
                this.worldScale.y = d
            } else this.worldScale.x = 0,
            this.worldScale.y = 0;
            return this.worldAlpha = this.alpha * e.worldAlpha,
            this.worldPosition.x = l.tx,
            this.worldPosition.y = l.ty,
            this._currentBounds = null,
            this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h),
            this
        },
        preUpdate: function() {},
        generateTexture: function(t, e, s) {
            var n = this.getLocalBounds(),
            r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, s, e, t);
            return i.DisplayObject._tempMatrix.tx = -n.x,
            i.DisplayObject._tempMatrix.ty = -n.y,
            r.render(this, i.DisplayObject._tempMatrix),
            r
        },
        updateCache: function() {
            return this._generateCachedSprite(),
            this
        },
        toGlobal: function(t) {
            return this.updateTransform(),
            this.worldTransform.apply(t)
        },
        toLocal: function(t, e) {
            return e && (t = e.toGlobal(t)),
            this.updateTransform(),
            this.worldTransform.applyInverse(t)
        },
        _renderCachedSprite: function(t) {
            this._cachedSprite.worldAlpha = this.worldAlpha,
            t.gl ? i.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : i.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var e = 0;
                this.texture && this.texture.baseTexture && i._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                var s = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                this._cachedSprite = new i.Sprite(s),
                this._cachedSprite.worldTransform = this.worldTransform
            }
            var n = this._filters;
            this._filters = null,
            this._cachedSprite.filters = n,
            i.DisplayObject._tempMatrix.tx = -t.x,
            i.DisplayObject._tempMatrix.ty = -t.y,
            this._cachedSprite.texture.render(this, i.DisplayObject._tempMatrix, !0),
            this._cachedSprite.anchor.x = -t.x / t.width,
            this._cachedSprite.anchor.y = -t.y / t.height,
            this._filters = n,
            this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    },
    i.DisplayObject.prototype.displayObjectUpdateTransform = i.DisplayObject.prototype.updateTransform,
    Object.defineProperties(i.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return ! 1;
                        t = t.parent
                    } while ( t );
                    return ! 0
                }
                return ! 1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(t) {
                this._mask && (this._mask.isMask = !1),
                this._mask = t,
                t && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var e = [], s = 0; s < t.length; s++) for (var n = t[s].passes, r = 0; r < n.length; r++) e.push(n[r]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: e
                    }
                }
                this._filters = t,
                this.blendMode && this.blendMode === i.blendModes.MULTIPLY && (this.blendMode = i.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }),
    i.DisplayObjectContainer = function() {
        i.DisplayObject.call(this),
        this.children = [],
        this.ignoreChildInput = !1
    },
    i.DisplayObjectContainer.prototype = Object.create(i.DisplayObject.prototype),
    i.DisplayObjectContainer.prototype.constructor = i.DisplayObjectContainer,
    i.DisplayObjectContainer.prototype.addChild = function(t) {
        return this.addChildAt(t, this.children.length)
    },
    i.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
        if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t),
        t.parent = this,
        this.children.splice(e, 0, t),
        t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    },
    i.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
            s = this.getChildIndex(e);
            if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e,
            this.children[s] = t
        }
    },
    i.DisplayObjectContainer.prototype.getChildIndex = function(t) {
        var e = this.children.indexOf(t);
        if ( - 1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    },
    i.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1),
        this.children.splice(e, 0, t)
    },
    i.DisplayObjectContainer.prototype.getChildAt = function(t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    },
    i.DisplayObjectContainer.prototype.removeChild = function(t) {
        var e = this.children.indexOf(t);
        if ( - 1 !== e) return this.removeChildAt(e)
    },
    i.DisplayObjectContainer.prototype.removeChildAt = function(t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)),
        e
    },
    i.DisplayObjectContainer.prototype.bringChildToTop = function(t) {
        if (t.parent === this) return this.setChildIndex(t, this.children.length - 1)
    },
    i.DisplayObjectContainer.prototype.sendChildToBack = function(t) {
        if (t.parent === this) return this.setChildIndex(t, 0)
    },
    i.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
        void 0 === t && (t = 0),
        void 0 === e && (e = this.children.length);
        var i = e - t;
        if (i > 0 && i <= e) {
            for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) s[n].parent = void 0;
            return s
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    },
    i.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    },
    i.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = i.DisplayObjectContainer.prototype.updateTransform,
    i.DisplayObjectContainer.prototype.getBounds = function(t) {
        var e, s = t && t instanceof i.DisplayObject,
        n = !0;
        if (s ? n = t instanceof i.DisplayObjectContainer && t.contains(this) : t = this, s) {
            var r = t.worldTransform;
            for (t.worldTransform = Phaser.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
        }
        var o, a, h, l = 1 / 0,
        c = 1 / 0,
        u = -1 / 0,
        d = -1 / 0,
        p = !1;
        for (e = 0; e < this.children.length; e++) this.children[e].visible && (p = !0, l = l < (o = this.children[e].getBounds()).x ? l: o.x, c = c < o.y ? c: o.y, u = u > (a = o.width + o.x) ? u: a, d = d > (h = o.height + o.y) ? d: h);
        var f = this._bounds;
        if (!p) {
            var g = (f = new i.Rectangle).x,
            m = f.width + f.x,
            y = f.y,
            v = f.height + f.y,
            x = this.worldTransform,
            b = x.a,
            _ = x.b,
            w = x.c,
            T = x.d,
            P = x.tx,
            C = x.ty,
            S = b * m + w * v + P,
            A = T * v + _ * m + C,
            E = b * g + w * v + P,
            M = T * v + _ * g + C,
            R = b * g + w * y + P,
            L = T * y + _ * g + C,
            B = b * m + w * y + P,
            I = T * y + _ * m + C;
            l = B < (l = R < (l = E < (l = S) ? E: l) ? R: l) ? B: l,
            c = I < (c = L < (c = M < (c = A) ? M: c) ? L: c) ? I: c,
            u = B > (u = R > (u = E > (u = S) ? E: u) ? R: u) ? B: u,
            d = I > (d = L > (d = M > (d = A) ? M: d) ? L: d) ? I: d
        }
        if (f.x = l, f.y = c, f.width = u - l, f.height = d - c, s) for (t.worldTransform = r, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
        if (!n) {
            var O = t.getBounds();
            f.x -= O.x,
            f.y -= O.y
        }
        return f
    },
    i.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    },
    i.DisplayObjectContainer.prototype.contains = function(t) {
        return !! t && (t === this || this.contains(t.parent))
    },
    i.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        if (this.visible && !(this.alpha <= 0)) if (this._cacheAsBitmap) this._renderCachedSprite(t);
        else {
            var e;
            if (this._mask || this._filters) {
                for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(),
                this._mask && t.maskManager.popMask(this._mask, t),
                this._filters && t.filterManager.popFilter(),
                t.spriteBatch.start()
            } else for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
        }
    },
    i.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha) if (this._cacheAsBitmap) this._renderCachedSprite(t);
        else {
            this._mask && t.maskManager.pushMask(this._mask, t);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    },
    Object.defineProperty(i.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e: 1,
            this._width = t
        }
    }),
    Object.defineProperty(i.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e: 1,
            this._height = t
        }
    }),
    i.Sprite = function(t) {
        i.DisplayObjectContainer.call(this),
        this.anchor = new i.Point(i.Sprite.defaultAnchor.x, i.Sprite.defaultAnchor.y),
        this.texture = t || i.Texture.emptyTexture,
        this._width = 0,
        this._height = 0,
        this.tint = 16777215,
        this.cachedTint = -1,
        this.tintedTexture = null,
        this.blendMode = i.blendModes.NORMAL,
        this.shader = null,
        this.exists = !0,
        this.texture.baseTexture.hasLoaded && this.onTextureUpdate(),
        this.renderable = !0
    },
    i.Sprite.defaultAnchor = {
        x: 0,
        y: 0
    },
    i.Sprite.prototype = Object.create(i.DisplayObjectContainer.prototype),
    i.Sprite.prototype.constructor = i.Sprite,
    Object.defineProperty(i.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width,
            this._width = t
        }
    }),
    Object.defineProperty(i.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height,
            this._height = t
        }
    }),
    i.Sprite.prototype.setTexture = function(t, e) {
        e && this.texture.baseTexture.destroy(),
        this.texture.baseTexture.skipRender = !1,
        this.texture = t,
        this.texture.valid = !0,
        this.cachedTint = -1
    },
    i.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width),
        this._height && (this.scale.y = this._height / this.texture.frame.height)
    },
    i.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
        i = this.texture.frame.height,
        s = e * (1 - this.anchor.x),
        n = e * -this.anchor.x,
        r = i * (1 - this.anchor.y),
        o = i * -this.anchor.y,
        a = t || this.worldTransform,
        h = a.a,
        l = a.b,
        c = a.c,
        u = a.d,
        d = a.tx,
        p = a.ty,
        f = -1 / 0,
        g = -1 / 0,
        m = 1 / 0,
        y = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0 && (h *= -1, v = s, s = -n, n = -v), u < 0) {
                u *= -1;
                var v = r;
                r = -o,
                o = -v
            }
            m = h * n + d,
            f = h * s + d,
            y = u * o + p,
            g = u * r + p
        } else {
            var x = h * n + c * o + d,
            b = u * o + l * n + p,
            _ = h * s + c * o + d,
            w = u * o + l * s + p,
            T = h * s + c * r + d,
            P = u * r + l * s + p,
            C = h * n + c * r + d,
            S = u * r + l * n + p;
            m = C < (m = T < (m = _ < (m = x < m ? x: m) ? _: m) ? T: m) ? C: m,
            y = S < (y = P < (y = w < (y = b < y ? b: y) ? w: y) ? P: y) ? S: y,
            f = C > (f = T > (f = _ > (f = x > f ? x: f) ? _: f) ? T: f) ? C: f,
            g = S > (g = P > (g = w > (g = b > g ? b: g) ? w: g) ? P: g) ? S: g
        }
        var A = this._bounds;
        return A.x = m,
        A.width = f - m,
        A.y = y,
        A.height = g - y,
        this._currentBounds = A,
        A
    },
    i.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = Phaser.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    },
    i.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var s = t.spriteBatch;
                for (this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this), n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                s.stop(),
                this._mask && t.maskManager.popMask(this._mask, t),
                this._filters && t.filterManager.popFilter(),
                s.start()
            } else {
                t.spriteBatch.render(this);
                for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
            }
        }
    },
    i.Sprite.prototype._renderCanvas = function(t, e) {
        if (! (!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)) {
            var s = this.worldTransform;
            if (e && (s = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = i.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var n = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha,
                t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === i.scaleModes.LINEAR);
                var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width: this.anchor.x * -this.texture.frame.width,
                o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height: this.anchor.y * -this.texture.frame.height,
                a = s.tx * t.resolution + t.shakeX,
                h = s.ty * t.resolution + t.shakeY,
                l = this.texture.crop.width,
                c = this.texture.crop.height;
                if (this.texture.rotated) {
                    var u = s.a,
                    d = s.b,
                    p = s.c,
                    f = s.d,
                    g = l;
                    a = s.c * c + a,
                    h = s.d * c + h,
                    s.a = 6.123233995736766e-17 * u - p,
                    s.b = 6.123233995736766e-17 * d - f,
                    s.c = u + 6.123233995736766e-17 * p,
                    s.d = d + 6.123233995736766e-17 * f,
                    l = c,
                    c = g
                }
                if (t.roundPixels ? (t.context.setTransform(s.a, s.b, s.c, s.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(s.a, s.b, s.c, s.d, a, h), r /= n, o /= n, c |= 0, (l |= 0) && c) {
                    if (16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = i.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1),
                    t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / n, c / n);
                    else {
                        var m = this.texture.crop.x,
                        y = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, m, y, l, c, r, o, l / n, c / n)
                    }
                    for (v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            } else {
                for (var v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }
    },
    i.initDefaultShaders = function() {},
    i.CompileVertexShader = function(t, e) {
        return i._CompileShader(t, e, t.VERTEX_SHADER)
    },
    i.CompileFragmentShader = function(t, e) {
        return i._CompileShader(t, e, t.FRAGMENT_SHADER)
    },
    i._CompileShader = function(t, e, i) {
        var s = e;
        Array.isArray(e) && (s = e.join("\n"));
        var n = t.createShader(i);
        return t.shaderSource(n, s),
        t.compileShader(n),
        t.getShaderParameter(n, t.COMPILE_STATUS) ? n: (window.console.log(t.getShaderInfoLog(n)), null)
    },
    i.compileProgram = function(t, e, s) {
        var n = i.CompileFragmentShader(t, s),
        r = i.CompileVertexShader(t, e),
        o = t.createProgram();
        return t.attachShader(o, r),
        t.attachShader(o, n),
        t.linkProgram(o),
        t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")),
        o
    },
    i.PixiShader = function(t) {
        this._UID = Phaser._UID++,
        this.gl = t,
        this.program = null,
        this.fragmentSrc = null,
        this.textureCount = 0,
        this.firstRun = !0,
        this.dirty = !0,
        this.attributes = [],
        this.init()
    },
    i.PixiShader.prototype.constructor = i.PixiShader,
    i.PixiShader.prototype.initMultitexShader = function() {
        var t = this.gl;
        this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n",
        s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
        this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
        var n = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
        t.useProgram(n),
        this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"),
        this.projectionVector = t.getUniformLocation(n, "projectionVector"),
        this.offsetVector = t.getUniformLocation(n, "offsetVector"),
        this.dimensions = t.getUniformLocation(n, "dimensions"),
        this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"),
        this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"),
        this.colorAttribute = t.getAttribLocation(n, "aColor"),
        this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
        var r = [],
        o = t.createTexture();
        t.activeTexture(t.TEXTURE0),
        t.bindTexture(t.TEXTURE_2D, o),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
        for (var a = 0; a < this.MAX_TEXTURES; ++a) t.activeTexture(t.TEXTURE0 + a),
        t.bindTexture(t.TEXTURE_2D, o),
        r.push(a);
        for (var h in t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
        this.initUniforms(),
        this.program = n
    },
    i.PixiShader.prototype.initDefaultShader = function() {
        null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
        var t = this.gl,
        e = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var s in t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.uniforms) this.uniforms[s].uniformLocation = t.getUniformLocation(e, s);
        this.initUniforms(),
        this.program = e
    },
    i.PixiShader.prototype.init = function(t) {
        i._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
    },
    i.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var s = (t = this.uniforms[i]).type;
            "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv: "mat3" === s ? t.glFunc = e.uniformMatrix3fv: "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
        }
    },
    i.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                s = i.magFilter ? i.magFilter: e.LINEAR,
                n = i.minFilter ? i.minFilter: e.LINEAR,
                r = i.wrapS ? i.wrapS: e.CLAMP_TO_EDGE,
                o = i.wrapT ? i.wrapT: e.CLAMP_TO_EDGE,
                a = i.luminance ? e.LUMINANCE: e.RGBA;
                if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width: 512,
                    l = i.height ? i.height: 2,
                    c = i.border ? i.border: 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
            }
            e.uniform1i(t.uniformLocation, this.textureCount),
            t._init = !0,
            this.textureCount++
        }
    },
    i.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var s in this.uniforms) 1 === (t = this.uniforms[s]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? i.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    },
    i.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    },
    i.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"],
    i.PixiFastShader = function(t) {
        if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
            t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n",
            s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
            this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
        } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
        this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"],
        this.textureCount = 0,
        this.init()
    },
    i.PixiFastShader.prototype.constructor = i.PixiFastShader,
    i.PixiFastShader.prototype.init = function() {
        var t = this.gl,
        e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
            var s = [],
            n = t.createTexture();
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, n),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r),
            t.bindTexture(t.TEXTURE_2D, n),
            s.push(r);
            t.activeTexture(t.TEXTURE0),
            t.uniform1iv(this.uSampler, s)
        }
        this.projectionVector = t.getUniformLocation(e, "projectionVector"),
        this.offsetVector = t.getUniformLocation(e, "offsetVector"),
        this.dimensions = t.getUniformLocation(e, "dimensions"),
        this.uMatrix = t.getUniformLocation(e, "uMatrix"),
        this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
        this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"),
        this.aScale = t.getAttribLocation(e, "aScale"),
        this.aRotation = t.getAttribLocation(e, "aRotation"),
        this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
        this.colorAttribute = t.getAttribLocation(e, "aColor"),
        this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"),
        -1 === this.colorAttribute && (this.colorAttribute = 2),
        this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex],
        this.program = e
    },
    i.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    },
    i.StripShader = function(t) {
        if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
            t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n",
            s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) ;return;}\n";
            this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
        } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
        this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"],
        this.init()
    },
    i.StripShader.prototype.constructor = i.StripShader,
    i.StripShader.prototype.init = function() {
        var t = this.gl,
        e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
            var s = [],
            n = t.createTexture();
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, n),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r),
            t.bindTexture(t.TEXTURE_2D, n),
            s.push(r);
            t.activeTexture(t.TEXTURE0),
            t.uniform1iv(this.uSampler, s)
        }
        this.projectionVector = t.getUniformLocation(e, "projectionVector"),
        this.offsetVector = t.getUniformLocation(e, "offsetVector"),
        this.colorAttribute = t.getAttribLocation(e, "aColor"),
        this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"),
        this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
        this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"),
        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex],
        this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
        this.alpha = t.getUniformLocation(e, "alpha"),
        this.program = e
    },
    i.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attribute = null
    },
    i.PrimitiveShader = function(t) {
        this._UID = Phaser._UID++,
        this.gl = t,
        this.program = null,
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"],
        this.init()
    },
    i.PrimitiveShader.prototype.constructor = i.PrimitiveShader,
    i.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
        e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e),
        this.projectionVector = t.getUniformLocation(e, "projectionVector"),
        this.offsetVector = t.getUniformLocation(e, "offsetVector"),
        this.tintColor = t.getUniformLocation(e, "tint"),
        this.flipY = t.getUniformLocation(e, "flipY"),
        this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
        this.colorAttribute = t.getAttribLocation(e, "aColor"),
        this.attributes = [this.aVertexPosition, this.colorAttribute],
        this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
        this.alpha = t.getUniformLocation(e, "alpha"),
        this.program = e
    },
    i.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    },
    i.ComplexPrimitiveShader = function(t) {
        this._UID = Phaser._UID++,
        this.gl = t,
        this.program = null,
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"],
        this.init()
    },
    i.ComplexPrimitiveShader.prototype.constructor = i.ComplexPrimitiveShader,
    i.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
        e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e),
        this.projectionVector = t.getUniformLocation(e, "projectionVector"),
        this.offsetVector = t.getUniformLocation(e, "offsetVector"),
        this.tintColor = t.getUniformLocation(e, "tint"),
        this.color = t.getUniformLocation(e, "color"),
        this.flipY = t.getUniformLocation(e, "flipY"),
        this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"),
        this.attributes = [this.aVertexPosition, this.colorAttribute],
        this.translationMatrix = t.getUniformLocation(e, "translationMatrix"),
        this.alpha = t.getUniformLocation(e, "alpha"),
        this.program = e
    },
    i.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attribute = null
    },
    i.glContexts = [],
    i.instances = [],
    i._enableMultiTextureToggle = !1,
    i.WebGLRenderer = function(t, e) {
        this.game = t,
        i.defaultRenderer || (i.defaultRenderer = this),
        this.extensions = {},
        this.type = Phaser.WEBGL,
        this.resolution = t.resolution,
        this.transparent = t.transparent,
        this.autoResize = !1,
        this.preserveDrawingBuffer = t.preserveDrawingBuffer,
        this.clearBeforeRender = t.clearBeforeRender,
        this.width = t.width,
        this.height = t.height,
        this.view = t.canvas,
        this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        },
        this.projection = new i.Point,
        this.offset = new i.Point,
        this.shaderManager = new i.WebGLShaderManager,
        this.spriteBatch = new i.WebGLSpriteBatch(t),
        this.maskManager = new i.WebGLMaskManager,
        this.filterManager = new i.WebGLFilterManager,
        this.stencilManager = new i.WebGLStencilManager,
        this.blendModeManager = new i.WebGLBlendModeManager,
        this.renderSession = {},
        this.currentBatchedTextures = [],
        this.renderSession.game = this.game,
        this.renderSession.gl = this.gl,
        this.renderSession.drawCount = 0,
        this.renderSession.shaderManager = this.shaderManager,
        this.renderSession.maskManager = this.maskManager,
        this.renderSession.filterManager = this.filterManager,
        this.renderSession.blendModeManager = this.blendModeManager,
        this.renderSession.spriteBatch = this.spriteBatch,
        this.renderSession.stencilManager = this.stencilManager,
        this.renderSession.renderer = this,
        this.renderSession.resolution = this.resolution,
        this.renderSession.roundPixels = e.roundPixels || !1,
        this.renderSession.maxTextureAvailableSpace = null,
        this.initContext(),
        this.mapBlendModes()
    },
    i.WebGLRenderer.prototype.constructor = i.WebGLRenderer,
    i.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
        this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE),
        this.glContextId = t.id = i.WebGLRenderer.glContextId++,
        i.glContexts[this.glContextId] = t,
        i.instances[this.glContextId] = this,
        t.disable(t.DEPTH_TEST),
        t.disable(t.CULL_FACE),
        t.enable(t.BLEND),
        this.shaderManager.setContext(t),
        this.spriteBatch.setContext(t),
        this.maskManager.setContext(t),
        this.filterManager.setContext(t),
        this.blendModeManager.setContext(t),
        this.stencilManager.setContext(t),
        this.renderSession.gl = this.gl,
        this.resize(this.width, this.height),
        this.extensions.compression = {};
        var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
        s = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        e && (this.extensions.compression.ETC1 = e),
        s && (this.extensions.compression.PVRTC = s),
        n && (this.extensions.compression.S3TC = n)
    },
    i.WebGLRenderer.prototype.setTexturePriority = function(t) {
        if (i._enableMultiTextureToggle) {
            for (var e = function(t) {
                return--t,
                t |= t >> 1,
                t |= t >> 2,
                t |= t >> 4,
                t |= t >> 8,
                t |= t >> 16,
                ++t
            },
            s = this.gl, n = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), r = s.getParameter(s.MAX_TEXTURE_SIZE), o = this.game.cache._cache.image, a = null, h = 0; h < this.currentBatchedTextures.length; h++)(a = this.currentBatchedTextures[h]) in o ? o[a].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
            var l = r - e(Math.max(this.width, this.height));
            this.currentBatchedTextures.length = 0;
            for (var c = 0; c < t.length; ++c) if ((a = t[c]) in o) {
                var u = o[a].base; (l -= e(Math.max(u.width, u.height))) <= 0 ? (u.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', a, l)) : u.textureIndex = 1 + c % (n - 1),
                this.currentBatchedTextures.push(a)
            } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
            return this.renderSession.maxTextureAvailableSpace = l,
            this.currentBatchedTextures
        }
        console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
    },
    i.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height),
            e.bindFramebuffer(e.FRAMEBUFFER, null),
            this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)),
            this.offset.x = this.game.camera._shake.x,
            this.offset.y = this.game.camera._shake.y,
            this.renderDisplayObject(t, this.projection)
        }
    },
    i.WebGLRenderer.prototype.renderDisplayObject = function(t, e, s, n) {
        this.renderSession.blendModeManager.setBlendMode(i.blendModes.NORMAL),
        this.renderSession.drawCount = 0,
        this.renderSession.flipY = s ? -1 : 1,
        this.renderSession.projection = e,
        this.renderSession.offset = this.offset,
        this.spriteBatch.begin(this.renderSession),
        this.filterManager.begin(this.renderSession, s),
        t._renderWebGL(this.renderSession, n),
        this.spriteBatch.end()
    },
    i.WebGLRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution,
        this.height = e * this.resolution,
        this.view.width = this.width,
        this.view.height = this.height,
        this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"),
        this.gl.viewport(0, 0, this.width, this.height),
        this.projection.x = this.width / 2 / this.resolution,
        this.projection.y = -this.height / 2 / this.resolution
    },
    i.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
        if (!t.hasLoaded) return ! 1;
        var e = this.gl,
        s = t.source;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()),
        e.activeTexture(e.TEXTURE0 + t.textureIndex),
        e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
        e.compressedTexImage2D(e.TEXTURE_2D, 0, s.glExtensionFormat, s.width, s.height, 0, s.textureData),
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR: e.NEAREST),
        t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR: e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR: e.NEAREST),
        t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
        t._dirty[e.id] = !1,
        !0
    },
    i.WebGLRenderer.prototype.updateTexture = function(t) {
        if (!t.hasLoaded) return ! 1;
        if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
        var e = this.gl;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()),
        e.activeTexture(e.TEXTURE0 + t.textureIndex),
        e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha),
        e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source),
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR: e.NEAREST),
        t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR: e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR: e.NEAREST),
        t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
        t._dirty[e.id] = !1,
        !0
    },
    i.WebGLRenderer.prototype.destroy = function() {
        i.glContexts[this.glContextId] = null,
        this.projection = null,
        this.offset = null,
        this.shaderManager.destroy(),
        this.spriteBatch.destroy(),
        this.maskManager.destroy(),
        this.filterManager.destroy(),
        this.shaderManager = null,
        this.spriteBatch = null,
        this.maskManager = null,
        this.filterManager = null,
        this.gl = null,
        this.renderSession = null,
        Phaser.CanvasPool.remove(this),
        i.instances[this.glContextId] = null,
        i.WebGLRenderer.glContextId--
    },
    i.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!i.blendModesWebGL) {
            var e = [],
            s = i.blendModes;
            e[s.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.ADD] = [t.SRC_ALPHA, t.DST_ALPHA],
            e[s.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA],
            e[s.SCREEN] = [t.SRC_ALPHA, t.ONE],
            e[s.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            e[s.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
            i.blendModesWebGL = e
        }
    },
    i.WebGLRenderer.prototype.getMaxTextureUnit = function() {
        var t = this.gl;
        return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
    },
    i.enableMultiTexture = function() {
        i._enableMultiTextureToggle = !0
    },
    i.WebGLRenderer.glContextId = 0,
    i.WebGLRenderer.textureArray = [],
    i.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    },
    i.WebGLBlendModeManager.prototype.constructor = i.WebGLBlendModeManager,
    i.WebGLBlendModeManager.prototype.setContext = function(t) {
        this.gl = t
    },
    i.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return ! 1;
        this.currentBlendMode = t;
        var e = i.blendModesWebGL[this.currentBlendMode];
        return e && this.gl.blendFunc(e[0], e[1]),
        !0
    },
    i.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    },
    i.WebGLMaskManager = function() {},
    i.WebGLMaskManager.prototype.constructor = i.WebGLMaskManager,
    i.WebGLMaskManager.prototype.setContext = function(t) {
        this.gl = t
    },
    i.WebGLMaskManager.prototype.pushMask = function(t, e) {
        var s = e.gl;
        t.dirty && i.WebGLGraphics.updateGraphics(t, s),
        void 0 !== t._webGL[s.id] && void 0 !== t._webGL[s.id].data && 0 !== t._webGL[s.id].data.length && e.stencilManager.pushStencil(t, t._webGL[s.id].data[0], e)
    },
    i.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    },
    i.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    },
    i.WebGLStencilManager = function() {
        this.stencilStack = [],
        this.reverse = !0,
        this.count = 0
    },
    i.WebGLStencilManager.prototype.setContext = function(t) {
        this.gl = t
    },
    i.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var s = this.gl;
        this.bindGraphics(t, e, i),
        0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0),
        this.stencilStack.push(e);
        var n = this.count;
        s.colorMask(!1, !1, !1, !1),
        s.stencilFunc(s.ALWAYS, 0, 255),
        s.stencilOp(s.KEEP, s.KEEP, s.INVERT),
        1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)),
        s.colorMask(!0, !0, !0, !0),
        s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
        this.count++
    },
    i.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
        this._currentGraphics = t;
        var s, n = this.gl,
        r = i.projection,
        o = i.offset;
        1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
    },
    i.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var s = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
        else {
            var n = this.count;
            this.bindGraphics(t, e, i),
            s.colorMask(!1, !1, !1, !1),
            1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)),
            s.colorMask(!0, !0, !0, !0),
            s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
        }
    },
    i.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null,
        this.gl = null
    },
    i.WebGLShaderManager = function() {
        this.maxAttibs = 10,
        this.attribState = [],
        this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    },
    i.WebGLShaderManager.prototype.constructor = i.WebGLShaderManager,
    i.WebGLShaderManager.prototype.setContext = function(t) {
        this.gl = t,
        this.primitiveShader = new i.PrimitiveShader(t),
        this.complexPrimitiveShader = new i.ComplexPrimitiveShader(t),
        this.defaultShader = new i.PixiShader(t),
        this.fastShader = new i.PixiFastShader(t),
        this.stripShader = new i.StripShader(t),
        this.creatureShader = i.CreatureShader ? new i.CreatureShader(t) : null,
        this.setShader(this.defaultShader)
    },
    i.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var s = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
    },
    i.WebGLShaderManager.prototype.setShader = function(t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    },
    i.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null,
        this.tempAttribState = null,
        this.primitiveShader.destroy(),
        this.complexPrimitiveShader.destroy(),
        this.defaultShader.destroy(),
        this.fastShader.destroy(),
        this.stripShader.destroy(),
        this.creatureShader && this.creatureShader.destroy(),
        this.gl = null
    },
    i.WebGLSpriteBatch = function(t) {
        this.game = t,
        this.vertSize = 5,
        this.size = 2e3,
        this.vertexSize = 24;
        var e = this.vertexSize * this.size * 4,
        i = 6 * this.size;
        this.vertices = new ArrayBuffer(e),
        this.positions = new Float32Array(this.vertices),
        this.colors = new Uint32Array(this.vertices),
        this.indices = new Uint16Array(i),
        this.lastIndexCount = 0;
        for (var s = 0,
        n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0,
        this.indices[s + 1] = n + 1,
        this.indices[s + 2] = n + 2,
        this.indices[s + 3] = n + 0,
        this.indices[s + 4] = n + 2,
        this.indices[s + 5] = n + 3;
        this.drawing = !1,
        this.currentBatchSize = 0,
        this.currentBaseTexture = null,
        this.dirty = !0,
        this.textures = [],
        this.blendModes = [],
        this.shaders = [],
        this.sprites = [],
        this.defaultShader = null
    },
    i.WebGLSpriteBatch.prototype.setContext = function(t) {
        if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, i._enableMultiTextureToggle) {
            for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n",
            s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
            this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
        } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
        this.vertexBuffer = t.createBuffer(),
        this.indexBuffer = t.createBuffer(),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
        t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW),
        this.currentBlendMode = 99999;
        var n = new i.PixiShader(t);
        n.fragmentSrc = this.defaultShader.fragmentSrc,
        n.uniforms = {},
        n.init(),
        this.defaultShader.shaders[t.id] = n
    },
    i.WebGLSpriteBatch.prototype.begin = function(t) {
        this.renderSession = t,
        this.shader = this.renderSession.shaderManager.defaultShader,
        this.start()
    },
    i.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    },
    i.WebGLSpriteBatch.prototype.render = function(t, e) {
        var s = t.texture,
        n = s.baseTexture,
        r = this.gl;
        i.WebGLRenderer.textureArray[n.textureIndex] != n && (this.flush(), r.activeTexture(r.TEXTURE0 + n.textureIndex), r.bindTexture(r.TEXTURE_2D, n._glTextures[r.id]), i.WebGLRenderer.textureArray[n.textureIndex] = n);
        var o = t.worldTransform;
        e && (o = e),
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = s.baseTexture);
        var a = s._uvs;
        if (a) {
            var h, l, c, u, d = t.anchor.x,
            p = t.anchor.y;
            if (s.trim) {
                var f = s.trim;
                h = (l = f.x - d * f.width) + s.crop.width,
                c = (u = f.y - p * f.height) + s.crop.height
            } else h = s.frame.width * (1 - d),
            l = s.frame.width * -d,
            c = s.frame.height * (1 - p),
            u = s.frame.height * -p;
            var g = this.currentBatchSize * this.vertexSize,
            m = s.baseTexture.resolution,
            y = s.baseTexture.textureIndex,
            v = o.a / m,
            x = o.b / m,
            b = o.c / m,
            _ = o.d / m,
            w = o.tx,
            T = o.ty,
            P = s.crop.height;
            if (s.rotated) {
                var C = o.a,
                S = o.b,
                A = o.c,
                E = o.d,
                M = l,
                R = h;
                w = o.c * P + w,
                T = o.d * P + T,
                v = 6.123233995736766e-17 * C - A,
                x = 6.123233995736766e-17 * S - E,
                b = C + 6.123233995736766e-17 * A,
                _ = S + 6.123233995736766e-17 * E,
                s._updateUvsInverted(),
                h = c,
                l = u,
                c = R,
                u = M
            }
            var L = this.colors,
            B = this.positions,
            I = t.tint,
            O = (I >> 16) + (65280 & I) + ((255 & I) << 16) + (255 * t.worldAlpha << 24);
            this.renderSession.roundPixels ? (B[g++] = v * l + b * u + w | 0, B[g++] = _ * u + x * l + T | 0, B[g++] = a.x0, B[g++] = a.y0, L[g++] = O, B[g++] = y, B[g++] = v * h + b * u + w | 0, B[g++] = _ * u + x * h + T | 0, B[g++] = a.x1, B[g++] = a.y1, L[g++] = O, B[g++] = y, B[g++] = v * h + b * c + w | 0, B[g++] = _ * c + x * h + T | 0, B[g++] = a.x2, B[g++] = a.y2, L[g++] = O, B[g++] = y, B[g++] = v * l + b * c + w | 0, B[g++] = _ * c + x * l + T | 0, B[g++] = a.x3, B[g++] = a.y3, L[g++] = O, B[g++] = y) : (B[g++] = v * l + b * u + w, B[g++] = _ * u + x * l + T, B[g++] = a.x0, B[g++] = a.y0, L[g++] = O, B[g++] = y, B[g++] = v * h + b * u + w, B[g++] = _ * u + x * h + T, B[g++] = a.x1, B[g++] = a.y1, L[g++] = O, B[g++] = y, B[g++] = v * h + b * c + w, B[g++] = _ * c + x * h + T, B[g++] = a.x2, B[g++] = a.y2, L[g++] = O, B[g++] = y, B[g++] = v * l + b * c + w, B[g++] = _ * c + x * l + T, B[g++] = a.x3, B[g++] = a.y3, L[g++] = O, B[g++] = y),
            this.sprites[this.currentBatchSize++] = t
        }
    },
    i.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var e = t.tilingTexture,
        s = e.baseTexture,
        n = this.gl,
        r = t.texture.baseTexture.textureIndex;
        i.WebGLRenderer.textureArray[r] != s && (this.flush(), n.activeTexture(n.TEXTURE0 + r), n.bindTexture(n.TEXTURE_2D, s._glTextures[n.id]), i.WebGLRenderer.textureArray[r] = s),
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture),
        t._uvs || (t._uvs = new i.TextureUvs);
        var o = t._uvs,
        a = e.baseTexture.width,
        h = e.baseTexture.height;
        t.tilePosition.x %= a * t.tileScaleOffset.x,
        t.tilePosition.y %= h * t.tileScaleOffset.y;
        var l = t.tilePosition.x / (a * t.tileScaleOffset.x),
        c = t.tilePosition.y / (h * t.tileScaleOffset.y),
        u = t.width / a / (t.tileScale.x * t.tileScaleOffset.x),
        d = t.height / h / (t.tileScale.y * t.tileScaleOffset.y);
        o.x0 = 0 - l,
        o.y0 = 0 - c,
        o.x1 = 1 * u - l,
        o.y1 = 0 - c,
        o.x2 = 1 * u - l,
        o.y2 = 1 * d - c,
        o.x3 = 0 - l,
        o.y3 = 1 * d - c;
        var p = t.tint,
        f = (p >> 16) + (65280 & p) + ((255 & p) << 16) + (255 * t.worldAlpha << 24),
        g = this.positions,
        m = this.colors,
        y = t.width,
        v = t.height,
        x = t.anchor.x,
        b = t.anchor.y,
        _ = y * (1 - x),
        w = y * -x,
        T = v * (1 - b),
        P = v * -b,
        C = this.currentBatchSize * this.vertexSize,
        S = e.baseTexture.resolution,
        A = t.worldTransform,
        E = A.a / S,
        M = A.b / S,
        R = A.c / S,
        L = A.d / S,
        B = A.tx,
        I = A.ty;
        g[C++] = E * w + R * P + B,
        g[C++] = L * P + M * w + I,
        g[C++] = o.x0,
        g[C++] = o.y0,
        m[C++] = f,
        g[C++] = r,
        g[C++] = E * _ + R * P + B,
        g[C++] = L * P + M * _ + I,
        g[C++] = o.x1,
        g[C++] = o.y1,
        m[C++] = f,
        g[C++] = r,
        g[C++] = E * _ + R * T + B,
        g[C++] = L * T + M * _ + I,
        g[C++] = o.x2,
        g[C++] = o.y2,
        m[C++] = f,
        g[C++] = r,
        g[C++] = E * w + R * T + B,
        g[C++] = L * T + M * w + I,
        g[C++] = o.x3,
        g[C++] = o.y3,
        m[C++] = f,
        g[C++] = r,
        this.sprites[this.currentBatchSize++] = t
    },
    i.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, e = this.gl;
            if (this.dirty) {
                this.dirty = !1,
                t = this.defaultShader.shaders[e.id],
                e.activeTexture(e.TEXTURE0),
                e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var s = this.vertexSize;
                e.vertexAttribPointer(t.aVertexPosition, 2, e.FLOAT, !1, s, 0),
                e.vertexAttribPointer(t.aTextureCoord, 2, e.FLOAT, !1, s, 8),
                e.vertexAttribPointer(t.colorAttribute, 4, e.UNSIGNED_BYTE, !0, s, 16),
                e.vertexAttribPointer(t.aTextureIndex, 1, e.FLOAT, !1, s, 20)
            }
            if (this.currentBatchSize > .5 * this.size) e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
            else {
                e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
                var n = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                e.bufferSubData(e.ARRAY_BUFFER, 0, n)
            }
            for (var r, o, a, h, l = 0,
            c = 0,
            u = null,
            d = this.renderSession.blendModeManager.currentBlendMode,
            p = null,
            f = !1,
            g = !1,
            m = 0,
            y = this.currentBatchSize; m < y; m++) {
                r = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture: h.texture.baseTexture,
                f = d !== (o = h.blendMode),
                g = p !== (a = h.shader || this.defaultShader);
                var v = r.skipRender;
                if (v && h.children.length > 0 && (v = !1), (f || g) && (this.renderBatch(u, l, c), c = m, l = 0, u = r, f && (d = o, this.renderSession.blendModeManager.setBlendMode(d)), g)) { (t = (p = a).shaders[e.id]) || ((t = new i.PixiShader(e)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[e.id] = t),
                    this.renderSession.shaderManager.setShader(t),
                    t.dirty && t.syncUniforms();
                    var x = this.renderSession.projection;
                    e.uniform2f(t.projectionVector, x.x, x.y);
                    var b = this.renderSession.offset;
                    e.uniform2f(t.offsetVector, b.x, b.y)
                }
                l++
            }
            this.renderBatch(u, l, c),
            this.currentBatchSize = 0
        }
    },
    i.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var s = this.gl;
            if (t._dirty[s.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
            s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2),
            this.renderSession.drawCount++
        }
    },
    i.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(),
        this.dirty = !0
    },
    i.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    },
    i.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null,
        this.indices = null,
        this.gl.deleteBuffer(this.vertexBuffer),
        this.gl.deleteBuffer(this.indexBuffer),
        this.currentBaseTexture = null,
        this.gl = null
    },
    i.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 11,
        this.maxSize = 6e3,
        this.size = this.maxSize;
        var e = 4 * this.size * this.vertSize,
        i = 6 * this.maxSize;
        this.vertices = new Float32Array(e),
        this.indices = new Uint16Array(i),
        this.vertexBuffer = null,
        this.indexBuffer = null,
        this.lastIndexCount = 0;
        for (var s = 0,
        n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0,
        this.indices[s + 1] = n + 1,
        this.indices[s + 2] = n + 2,
        this.indices[s + 3] = n + 0,
        this.indices[s + 4] = n + 2,
        this.indices[s + 5] = n + 3;
        this.drawing = !1,
        this.currentBatchSize = 0,
        this.currentBaseTexture = null,
        this.currentBlendMode = 0,
        this.renderSession = null,
        this.shader = null,
        this.matrix = null,
        this.setContext(t)
    },
    i.WebGLFastSpriteBatch.prototype.constructor = i.WebGLFastSpriteBatch,
    i.WebGLFastSpriteBatch.prototype.setContext = function(t) {
        this.gl = t,
        this.vertexBuffer = t.createBuffer(),
        this.indexBuffer = t.createBuffer(),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
        t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    },
    i.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
        this.renderSession = e,
        this.shader = this.renderSession.shaderManager.fastShader,
        this.matrix = t.worldTransform.toArray(!0),
        this.start()
    },
    i.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    },
    i.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
        i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture,
            i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var s = 0,
            n = e.length; s < n; s++) this.renderSprite(e[s]);
            this.flush()
        }
    },
    i.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        var e = t.texture.baseTexture,
        s = this.gl,
        n = t.texture.baseTexture.textureIndex;
        if ((i.WebGLRenderer.textureArray[n] == e || !e._glTextures[s.id] || t.texture.baseTexture.skipRender || (this.flush(), s.activeTexture(s.TEXTURE0 + n), s.bindTexture(s.TEXTURE_2D, e._glTextures[s.id]), i.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
            var r, o, a, h, l, c, u, d, p = this.vertices;
            if (r = t.texture._uvs, o = t.texture.frame.width, a = t.texture.frame.height, t.texture.trim) {
                var f = t.texture.trim;
                h = (l = f.x - t.anchor.x * f.width) + t.texture.crop.width,
                c = (u = f.y - t.anchor.y * f.height) + t.texture.crop.height
            } else h = o * (1 - t.anchor.x),
            l = o * -t.anchor.x,
            c = a * (1 - t.anchor.y),
            u = a * -t.anchor.y;
            d = 4 * this.currentBatchSize * this.vertSize,
            p[d++] = l,
            p[d++] = u,
            p[d++] = t.position.x,
            p[d++] = t.position.y,
            p[d++] = t.scale.x,
            p[d++] = t.scale.y,
            p[d++] = t.rotation,
            p[d++] = r.x0,
            p[d++] = r.y1,
            p[d++] = t.alpha,
            p[d++] = n,
            p[d++] = h,
            p[d++] = u,
            p[d++] = t.position.x,
            p[d++] = t.position.y,
            p[d++] = t.scale.x,
            p[d++] = t.scale.y,
            p[d++] = t.rotation,
            p[d++] = r.x1,
            p[d++] = r.y1,
            p[d++] = t.alpha,
            p[d++] = n,
            p[d++] = h,
            p[d++] = c,
            p[d++] = t.position.x,
            p[d++] = t.position.y,
            p[d++] = t.scale.x,
            p[d++] = t.scale.y,
            p[d++] = t.rotation,
            p[d++] = r.x2,
            p[d++] = r.y2,
            p[d++] = t.alpha,
            p[d++] = n,
            p[d++] = l,
            p[d++] = c,
            p[d++] = t.position.x,
            p[d++] = t.position.y,
            p[d++] = t.scale.x,
            p[d++] = t.scale.y,
            p[d++] = t.rotation,
            p[d++] = r.x3,
            p[d++] = r.y3,
            p[d++] = t.alpha,
            p[d++] = n,
            ++this.currentBatchSize >= this.size && this.flush()
        }
    },
    i.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id]) {
                if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                }
                t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0),
                this.currentBatchSize = 0,
                this.renderSession.drawCount++
            } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
        }
    },
    i.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    },
    i.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0),
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y),
        t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0),
        t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8),
        t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16),
        t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24),
        t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28),
        t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36),
        t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
    },
    i.WebGLFilterManager = function() {
        this.filterStack = [],
        this.offsetX = 0,
        this.offsetY = 0
    },
    i.WebGLFilterManager.prototype.constructor = i.WebGLFilterManager,
    i.WebGLFilterManager.prototype.setContext = function(t) {
        this.gl = t,
        this.texturePool = [],
        this.initShaderBuffers()
    },
    i.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t,
        this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x,
        this.height = 2 * -i.y,
        this.buffer = e
    },
    i.WebGLFilterManager.prototype.pushFilter = function(t) {
        var e = this.gl,
        s = this.renderSession.projection,
        n = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(),
        t._previous_stencil_mgr = this.renderSession.stencilManager,
        this.renderSession.stencilManager = new i.WebGLStencilManager,
        this.renderSession.stencilManager.setContext(e),
        e.disable(e.STENCIL_TEST),
        this.filterStack.push(t);
        var r = t.filterPasses[0];
        this.offsetX += t._filterArea.x,
        this.offsetY += t._filterArea.y;
        var o = this.texturePool.pop();
        o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
        e.bindTexture(e.TEXTURE_2D, o.texture);
        var a = t._filterArea,
        h = r.padding;
        a.x -= h,
        a.y -= h,
        a.width += 2 * h,
        a.height += 2 * h,
        a.x < 0 && (a.x = 0),
        a.width > this.width && (a.width = this.width),
        a.y < 0 && (a.y = 0),
        a.height > this.height && (a.height = this.height),
        e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer),
        e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution),
        s.x = a.width / 2,
        s.y = -a.height / 2,
        n.x = -a.x,
        n.y = -a.y,
        e.colorMask(!0, !0, !0, !0),
        e.clearColor(0, 0, 0, 0),
        e.clear(e.COLOR_BUFFER_BIT),
        t._glFilterTexture = o
    },
    i.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
        e = this.filterStack.pop(),
        s = e._filterArea,
        n = e._glFilterTexture,
        r = this.renderSession.projection,
        o = this.renderSession.offset;
        if (e.filterPasses.length > 1) {
            t.viewport(0, 0, s.width * this.renderSession.resolution, s.height * this.renderSession.resolution),
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
            this.vertexArray[0] = 0,
            this.vertexArray[1] = s.height,
            this.vertexArray[2] = s.width,
            this.vertexArray[3] = s.height,
            this.vertexArray[4] = 0,
            this.vertexArray[5] = 0,
            this.vertexArray[6] = s.width,
            this.vertexArray[7] = 0,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
            t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
            this.uvArray[2] = s.width / this.width,
            this.uvArray[5] = s.height / this.height,
            this.uvArray[6] = s.width / this.width,
            this.uvArray[7] = s.height / this.height,
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var a = n,
            h = this.texturePool.pop();
            h || (h = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)),
            h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
            t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer),
            t.clear(t.COLOR_BUFFER_BIT),
            t.disable(t.BLEND);
            for (var l = 0; l < e.filterPasses.length - 1; l++) {
                var c = e.filterPasses[l];
                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer),
                t.activeTexture(t.TEXTURE0),
                t.bindTexture(t.TEXTURE_2D, a.texture),
                this.applyFilterPass(c, s, s.width, s.height);
                var u = a;
                a = h,
                h = u
            }
            t.enable(t.BLEND),
            n = a,
            this.texturePool.push(h)
        }
        var d = e.filterPasses[e.filterPasses.length - 1];
        this.offsetX -= s.x,
        this.offsetY -= s.y;
        var p = this.width,
        f = this.height,
        g = 0,
        m = 0,
        y = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var v = this.filterStack[this.filterStack.length - 1];
            p = (s = v._filterArea).width,
            f = s.height,
            g = s.x,
            m = s.y,
            y = v._glFilterTexture.frameBuffer
        }
        r.x = p / 2,
        r.y = -f / 2,
        o.x = g,
        o.y = m;
        var x = (s = e._filterArea).x - g,
        b = s.y - m;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
        this.vertexArray[0] = x,
        this.vertexArray[1] = b + s.height,
        this.vertexArray[2] = x + s.width,
        this.vertexArray[3] = b + s.height,
        this.vertexArray[4] = x,
        this.vertexArray[5] = b,
        this.vertexArray[6] = x + s.width,
        this.vertexArray[7] = b,
        t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray),
        t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
        this.uvArray[2] = s.width / this.width,
        this.uvArray[5] = s.height / this.height,
        this.uvArray[6] = s.width / this.width,
        this.uvArray[7] = s.height / this.height,
        t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray),
        t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution),
        t.bindFramebuffer(t.FRAMEBUFFER, y),
        t.activeTexture(t.TEXTURE0),
        t.bindTexture(t.TEXTURE_2D, n.texture),
        this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(),
        this.renderSession.stencilManager = e._previous_stencil_mgr,
        e._previous_stencil_mgr = null,
        this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST),
        this.applyFilterPass(d, s, p, f),
        this.texturePool.push(n),
        e._glFilterTexture = null
    },
    i.WebGLFilterManager.prototype.applyFilterPass = function(t, e, s, n) {
        var r = this.gl,
        o = t.shaders[r.id];
        o || ((o = new i.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(!0), t.shaders[r.id] = o),
        this.renderSession.shaderManager.setShader(o),
        r.uniform2f(o.projectionVector, s / 2, -n / 2),
        r.uniform2f(o.offsetVector, 0, 0),
        t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]),
        o.syncUniforms(),
        r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer),
        r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0),
        r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer),
        r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0),
        r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer),
        r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0),
        r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0),
        this.renderSession.drawCount++
    },
    i.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(),
        this.uvBuffer = t.createBuffer(),
        this.colorBuffer = t.createBuffer(),
        this.indexBuffer = t.createBuffer(),
        this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
        t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW),
        this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
        t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer),
        t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW),
        this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]),
        t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer),
        t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    },
    i.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null,
        this.offsetX = 0,
        this.offsetY = 0;
        for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null,
        t.deleteBuffer(this.vertexBuffer),
        t.deleteBuffer(this.uvBuffer),
        t.deleteBuffer(this.colorBuffer),
        t.deleteBuffer(this.indexBuffer)
    };
    var s = {
        36054 : "Incomplete attachment",
        36055 : "Missing attachment",
        36057 : "Incomplete dimensions",
        36061 : "Framebuffer unsupported"
    };
    return i.FilterTexture = function(t, s, n, r, o) {
        o = "number" == typeof o ? o: 0,
        this.gl = t,
        this.frameBuffer = e(t, s, n, r || i.scaleModes.DEFAULT, o),
        this.texture = this.frameBuffer.targetTexture,
        this.width = s,
        this.height = n,
        this.renderBuffer = this.frameBuffer.renderBuffer
    },
    i.FilterTexture.prototype.constructor = i.FilterTexture,
    i.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0),
        t.clear(t.COLOR_BUFFER_BIT)
    },
    i.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t,
            this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture),
            i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null),
            i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer),
            i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    },
    i.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer),
        t.deleteTexture(this.texture),
        this.frameBuffer = null,
        this.texture = null
    },
    i.CanvasBuffer = function(t, e) {
        this.width = t,
        this.height = e,
        this.canvas = Phaser.CanvasPool.create(this, this.width, this.height),
        this.context = this.canvas.getContext("2d"),
        this.canvas.width = t,
        this.canvas.height = e
    },
    i.CanvasBuffer.prototype.constructor = i.CanvasBuffer,
    i.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0),
        this.context.clearRect(0, 0, this.width, this.height)
    },
    i.CanvasBuffer.prototype.resize = function(t, e) {
        this.width = this.canvas.width = t,
        this.height = this.canvas.height = e
    },
    i.CanvasBuffer.prototype.destroy = function() {
        Phaser.CanvasPool.remove(this)
    },
    i.CanvasMaskManager = function() {},
    i.CanvasMaskManager.prototype.constructor = i.CanvasMaskManager,
    i.CanvasMaskManager.prototype.pushMask = function(t, e) {
        var s = e.context;
        s.save();
        var n = t.alpha,
        r = t.worldTransform,
        o = e.resolution;
        s.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o),
        i.CanvasGraphics.renderGraphicsMask(t, s),
        s.clip(),
        t.worldAlpha = n
    },
    i.CanvasMaskManager.prototype.popMask = function(t) {
        t.context.restore()
    },
    i.CanvasTinter = function() {},
    i.CanvasTinter.getTintedTexture = function(t, e) {
        var s = t.tintedTexture || Phaser.CanvasPool.create(this);
        return i.CanvasTinter.tintMethod(t.texture, e, s),
        s
    },
    i.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var s = i.getContext("2d"),
        n = t.crop,
        r = n.width,
        o = n.height;
        t.rotated && (r = o, o = n.width),
        i.width === r && i.height === o || (i.width = r, i.height = o),
        s.clearRect(0, 0, r, o),
        s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr( - 6),
        s.fillRect(0, 0, r, o),
        s.globalCompositeOperation = "multiply",
        s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o),
        s.globalCompositeOperation = "destination-atop",
        s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
    },
    i.CanvasTinter.tintWithPerPixel = function(t, e, s) {
        var n = s.getContext("2d"),
        r = t.crop,
        o = r.width,
        a = r.height;
        t.rotated && (o = a, a = r.width),
        s.width === o && s.height === a || (s.width = o, s.height = a),
        n.globalCompositeOperation = "copy",
        n.drawImage(t.baseTexture.source, r.x, r.y, o, a, 0, 0, o, a);
        for (var h = Phaser.Color.hexToRGBArray(e), l = h[0], c = h[1], u = h[2], d = n.getImageData(0, 0, o, a), p = d.data, f = 0; f < p.length; f += 4) if (p[f + 0] *= l, p[f + 1] *= c, p[f + 2] *= u, !i.CanvasTinter.canHandleAlpha) {
            var g = p[f + 3];
            p[f + 0] /= 255 / g,
            p[f + 1] /= 255 / g,
            p[f + 2] /= 255 / g
        }
        n.putImageData(d, 0, 0)
    },
    i.CanvasRenderer = function(t, e) {
        if (this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), !this.context) throw new Error("Failed to create a Canvas 2d context.");
        this.refresh = !0,
        this.count = 0,
        this.maskManager = new i.CanvasMaskManager,
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: e.roundPixels || !1
        },
        this.mapBlendModes(),
        this.resize(this.width, this.height)
    },
    i.CanvasRenderer.prototype.constructor = i.CanvasRenderer,
    i.CanvasRenderer.prototype.render = function(t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0),
        this.context.globalAlpha = 1,
        this.renderSession.currentBlendMode = 0,
        this.renderSession.shakeX = this.game.camera._shake.x,
        this.renderSession.shakeY = this.game.camera._shake.y,
        this.context.globalCompositeOperation = "source-over",
        navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()),
        this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))),
        this.renderDisplayObject(t)
    },
    i.CanvasRenderer.prototype.setTexturePriority = function() {},
    i.CanvasRenderer.prototype.destroy = function(t) {
        void 0 === t && (t = !0),
        t && this.view.parent && this.view.parent.removeChild(this.view),
        this.view = null,
        this.context = null,
        this.maskManager = null,
        this.renderSession = null
    },
    i.CanvasRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution,
        this.height = e * this.resolution,
        this.view.width = this.width,
        this.view.height = this.height,
        this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"),
        this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === i.scaleModes.LINEAR)
    },
    i.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
        this.renderSession.context = e || this.context,
        this.renderSession.resolution = this.resolution,
        t._renderCanvas(this.renderSession, i)
    },
    i.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!i.blendModesCanvas) {
            var t = [],
            e = i.blendModes,
            s = this.game.device.canUseMultiply;
            t[e.NORMAL] = "source-over",
            t[e.ADD] = "lighter",
            t[e.MULTIPLY] = s ? "multiply": "source-over",
            t[e.SCREEN] = s ? "screen": "source-over",
            t[e.OVERLAY] = s ? "overlay": "source-over",
            t[e.DARKEN] = s ? "darken": "source-over",
            t[e.LIGHTEN] = s ? "lighten": "source-over",
            t[e.COLOR_DODGE] = s ? "color-dodge": "source-over",
            t[e.COLOR_BURN] = s ? "color-burn": "source-over",
            t[e.HARD_LIGHT] = s ? "hard-light": "source-over",
            t[e.SOFT_LIGHT] = s ? "soft-light": "source-over",
            t[e.DIFFERENCE] = s ? "difference": "source-over",
            t[e.EXCLUSION] = s ? "exclusion": "source-over",
            t[e.HUE] = s ? "hue": "source-over",
            t[e.SATURATION] = s ? "saturation": "source-over",
            t[e.COLOR] = s ? "color": "source-over",
            t[e.LUMINOSITY] = s ? "luminosity": "source-over",
            i.blendModesCanvas = t
        }
    },
    i.BaseTexture = function(t, e, s) {
        this.resolution = s || 1,
        this.width = 100,
        this.height = 100,
        this.scaleMode = e || i.scaleModes.DEFAULT,
        this.hasLoaded = !1,
        this.source = t,
        this.premultipliedAlpha = !0,
        this._glTextures = [],
        this.mipmap = !1,
        this.textureIndex = 0,
        this._dirty = [!0, !0, !0, !0],
        t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    },
    i.BaseTexture.prototype.constructor = i.BaseTexture,
    i.BaseTexture.prototype.forceLoaded = function(t, e) {
        this.hasLoaded = !0,
        this.width = t,
        this.height = e,
        this.dirty()
    },
    i.BaseTexture.prototype.destroy = function() {
        this.source && Phaser.CanvasPool.removeByCanvas(this.source),
        this.source = null,
        this.unloadFromGPU()
    },
    i.BaseTexture.prototype.dirty = function() {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    },
    i.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; t >= 0; t--) {
            var e = this._glTextures[t],
            s = i.glContexts[t];
            s && e && s.deleteTexture(e)
        }
        this._glTextures.length = 0,
        this.dirty()
    },
    i.BaseTexture.fromCanvas = function(t, e, s) {
        return 0 === t.width && (t.width = 1),
        0 === t.height && (t.height = 1),
        s = s || 1,
        new i.BaseTexture(t, e, s)
    },
    i.TextureSilentFail = !1,
    i.Texture = function(t, e, s, n) {
        this.noFrame = !1,
        e || (this.noFrame = !0, e = new i.Rectangle(0, 0, 1, 1)),
        t instanceof i.Texture && (t = t.baseTexture),
        this.baseTexture = t,
        this.frame = e,
        this.trim = n,
        this.valid = !1,
        this.isTiling = !1,
        this.requiresUpdate = !1,
        this.requiresReTint = !1,
        this._uvs = null,
        this.width = 0,
        this.height = 0,
        this.crop = s || new i.Rectangle(0, 0, 1, 1),
        this.rotated = !1,
        t.hasLoaded && (this.noFrame && (e = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
    },
    i.Texture.prototype.constructor = i.Texture,
    i.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new i.Rectangle(0, 0, t.width, t.height)),
        this.setFrame(this.frame)
    },
    i.Texture.prototype.destroy = function(t) {
        t && this.baseTexture.destroy(),
        this.valid = !1
    },
    i.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded,
        this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height),
        this.valid && this._updateUvs();
        else {
            if (!i.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    },
    i.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new i.TextureUvs);
        var t = this.crop,
        e = this.baseTexture.width,
        s = this.baseTexture.height;
        this._uvs.x0 = t.x / e,
        this._uvs.y0 = t.y / s,
        this._uvs.x1 = (t.x + t.width) / e,
        this._uvs.y1 = t.y / s,
        this._uvs.x2 = (t.x + t.width) / e,
        this._uvs.y2 = (t.y + t.height) / s,
        this._uvs.x3 = t.x / e,
        this._uvs.y3 = (t.y + t.height) / s
    },
    i.Texture.prototype._updateUvsInverted = function() {
        this._uvs || (this._uvs = new i.TextureUvs);
        var t = this.crop,
        e = this.baseTexture.width,
        s = this.baseTexture.height;
        this._uvs.x0 = t.x / e,
        this._uvs.y0 = t.y / s,
        this._uvs.x1 = (t.x + t.height) / e,
        this._uvs.y1 = t.y / s,
        this._uvs.x2 = (t.x + t.height) / e,
        this._uvs.y2 = (t.y + t.width) / s,
        this._uvs.x3 = t.x / e,
        this._uvs.y3 = (t.y + t.width) / s
    },
    i.Texture.fromCanvas = function(t, e) {
        var s = i.BaseTexture.fromCanvas(t, e);
        return new i.Texture(s)
    },
    i.TextureUvs = function() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 0,
        this.y1 = 0,
        this.x2 = 0,
        this.y2 = 0,
        this.x3 = 0,
        this.y3 = 0
    },
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.PIXI = i) : "undefined" != typeof define && define.amd ? define("PIXI", this.PIXI = i) : this.PIXI = i,
    i
}.call(this),
function() {
    var t = t || {
        VERSION: "2.12.0",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        WEBGL_MULTI: 4,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        PENDING_ATLAS: -1,
        HORIZONTAL: 0,
        VERTICAL: 1,
        LANDSCAPE: 0,
        PORTRAIT: 1,
        ANGLE_UP: 270,
        ANGLE_DOWN: 90,
        ANGLE_LEFT: 180,
        ANGLE_RIGHT: 0,
        ANGLE_NORTH_EAST: 315,
        ANGLE_NORTH_WEST: 225,
        ANGLE_SOUTH_EAST: 45,
        ANGLE_SOUTH_WEST: 135,
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        },
        PIXI: PIXI || {},
        _UID: 0
    };
    if ("undefined" != typeof AudioBufferSourceNode && (AudioBufferSourceNode.prototype.start || (AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn), AudioBufferSourceNode.prototype.stop || (AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff)), Math.trunc || (Math.trunc = function(t) {
        return t < 0 ? Math.ceil(t) : Math.floor(t)
    }), Function.prototype.bind || (Function.prototype.bind = function() {
        var t = Array.prototype.slice;
        return function(e) {
            function i() {
                var r = n.concat(t.call(arguments));
                s.apply(this instanceof i ? this: e, r)
            }
            var s = this,
            n = t.call(arguments, 1);
            if ("function" != typeof s) throw new TypeError;
            return i.prototype = function t(e) {
                if (e && (t.prototype = e), !(this instanceof t)) return new t
            } (s.prototype),
            i
        }
    } ()), Array.isArray || (Array.isArray = function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
        "use strict";
        if (null == this) throw new TypeError;
        var e = Object(this),
        i = e.length >>> 0;
        if ("function" != typeof t) throw new TypeError;
        for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
        var e = function(t) {
            var e = new Array;
            window[t] = function(t) {
                if ("number" == typeof t) for (Array.call(this, t), this.length = t, e = 0; e < this.length; e++) this[e] = 0;
                else {
                    Array.call(this, t.length),
                    this.length = t.length;
                    for (var e = 0; e < this.length; e++) this[e] = t[e]
                }
            },
            window[t].prototype = e,
            window[t].constructor = window[t]
        };
        e("Float32Array"),
        e("Uint32Array"),
        e("Uint16Array"),
        e("Int16Array"),
        e("ArrayBuffer")
    }
    for (var i in window.console || (window.console = {},
    window.console.log = window.console.assert = function() {},
    window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(t, e) {
        "use strict";
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
        for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null != r) for (var o in r) s.call(r, o) && (i[o] = r[o])
        }
        return i
    }), t.Utils = {
        defaults: function(t, e) {
            for (var i = Object.keys(e), s = 0, n = i.length; s < n; s++) {
                var r = i[s];
                void 0 === t[r] && (t[r] = e[r])
            }
            return t
        },
        reverseString: function(t) {
            return t.split("").reverse().join("")
        },
        getProperty: function(t, e) {
            var i = e.split(".");
            switch (i.length) {
            case 1:
                return t[e];
            case 2:
                return t[i[0]][i[1]];
            case 3:
                return t[i[0]][i[1]][i[2]];
            case 4:
                return t[i[0]][i[1]][i[2]][i[3]];
            default:
                return this._getProperty(t, e)
            }
        },
        setProperties: function(t, e) {
            for (var i in e) this.setProperty(t, i, e[i]);
            return t
        },
        setProperty: function(t, e, i) {
            var s = e.split(".");
            switch (s.length) {
            case 1:
                t[e] = i;
                break;
            case 2:
                t[s[0]][s[1]] = i;
                break;
            case 3:
                t[s[0]][s[1]][s[2]] = i;
                break;
            case 4:
                t[s[0]][s[1]][s[2]][s[3]] = i;
                break;
            default:
                this._setProperty(t, e, i)
            }
        },
        _getProperty: function(t, e) {
            for (var i = e.split("."), s = i.length, n = 0, r = t; n < s;) {
                var o = i[n];
                if (null == r) return;
                r = r[o],
                n++
            }
            return r
        },
        _setProperty: function(t, e, i) {
            var s = e.split("."),
            n = s.length,
            r = 0,
            o = t,
            a = s[0];
            if (1 === n) t[e] = i;
            else {
                for (; r < n - 1;) o = o[a],
                a = s[++r];
                o[a] = i
            }
            return t
        },
        chanceRoll: function(t) {
            return void 0 === t && (t = 50),
            t > 0 && 100 * Math.random() <= t
        },
        randomChoice: function(t, e) {
            return Math.random() < .5 ? t: e
        },
        parseDimension: function(t, e) {
            var i = 0,
            s = 0;
            return "string" == typeof t ? "%" === t.substr( - 1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i: window.innerHeight * i) : s = parseInt(t, 10) : s = t,
            s
        },
        pad: function(t, e, i, s) {
            if (void 0 === e) e = 0;
            if (void 0 === i) i = " ";
            if (void 0 === s) s = 3;
            var n = 0;
            if (e + 1 >= (t = t.toString()).length) switch (s) {
            case 1:
                t = new Array(e + 1 - t.length).join(i) + t;
                break;
            case 3:
                var r = Math.ceil((n = e - t.length) / 2);
                t = new Array(n - r + 1).join(i) + t + new Array(r + 1).join(i);
                break;
            default:
                t += new Array(e + 1 - t.length).join(i)
            }
            return t
        },
        isPlainObject: function(t) {
            if ("object" != typeof t || t.nodeType || t === t.window) return ! 1;
            try {
                if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return ! 1
            } catch(t) {
                return ! 1
            }
            return ! 0
        },
        extend: function() {
            var e, i, s, n, r, o, a = arguments[0] || {},
            h = 1,
            l = arguments.length,
            c = !1;
            for ("boolean" == typeof a && (c = a, a = arguments[1] || {},
            h = 2), l === h && (a = this, --h); h < l; h++) if (null != (e = arguments[h])) for (i in e) s = a[i],
            a !== (n = e[i]) && (c && n && (t.Utils.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, o = s && Array.isArray(s) ? s: []) : o = s && t.Utils.isPlainObject(s) ? s: {},
            a[i] = t.Utils.extend(c, o, n)) : void 0 !== n && (a[i] = n));
            return a
        },
        mixinPrototype: function(t, e, i) {
            void 0 === i && (i = !1);
            for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                var r = s[n],
                o = e[r]; ! i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o: "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
            }
        },
        mixin: function(e, i) {
            if (!e || "object" != typeof e) return i;
            for (var s in e) {
                var n = e[s];
                if (!n.childNodes && !n.cloneNode) {
                    var r = typeof e[s];
                    e[s] && "object" === r ? typeof i[s] === r ? i[s] = t.Utils.mixin(e[s], i[s]) : i[s] = t.Utils.mixin(e[s], new n.constructor) : i[s] = e[s]
                }
            }
            return i
        }
    },
    t.Circle = function(e, i, s) {
        e = e || 0,
        i = i || 0,
        s = s || 0,
        this.x = e,
        this.y = i,
        this._diameter = s,
        this._radius = 0,
        s > 0 && (this._radius = .5 * s),
        this.type = t.CIRCLE
    },
    t.Circle.prototype = {
        circumference: function() {
            return Math.PI * this._radius * 2
        },
        random: function(e) {
            void 0 === e && (e = new t.Point);
            var i = 2 * Math.PI * Math.random(),
            s = Math.random() + Math.random(),
            n = s > 1 ? 2 - s: s,
            r = n * Math.cos(i),
            o = n * Math.sin(i);
            return e.x = this.x + r * this.radius,
            e.y = this.y + o * this.radius,
            e
        },
        getBounds: function() {
            return new t.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
        },
        setTo: function(t, e, i) {
            return this.x = t,
            this.y = e,
            this._diameter = i,
            this._radius = .5 * i,
            this
        },
        copyFrom: function(t) {
            return this.setTo(t.x, t.y, t.diameter)
        },
        copyTo: function(t) {
            return t.x = this.x,
            t.y = this.y,
            t.diameter = this._diameter,
            t
        },
        distance: function(e, i) {
            var s = t.Math.distance(this.x, this.y, e.x, e.y);
            return i ? Math.round(s) : s
        },
        clone: function(e) {
            return null == e ? e = new t.Circle(this.x, this.y, this.diameter) : e.setTo(this.x, this.y, this.diameter),
            e
        },
        contains: function(e, i) {
            return t.Circle.contains(this, e, i)
        },
        circumferencePoint: function(e, i, s) {
            return t.Circle.circumferencePoint(this, e, i, s)
        },
        sample: function(e, i, s, n, r) {
            e || (e = 60),
            null == i && (i = 0),
            null == s && (s = t.Math.PI2),
            r || (r = []);
            for (var o = 0; o < e;) this.circumferencePoint(t.Math.linear(i, s, o / e), n, r[o] || (r[o] = new t.Point)),
            o += 1;
            return r
        },
        offset: function(t, e) {
            return this.x += t,
            this.y += e,
            this
        },
        offsetPoint: function(t) {
            return this.offset(t.x, t.y)
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    },
    t.Circle.prototype.constructor = t.Circle, Object.defineProperty(t.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter
        },
        set: function(t) {
            t > 0 && (this._diameter = t, this._radius = .5 * t)
        }
    }), Object.defineProperty(t.Circle.prototype, "radius", {
        get: function() {
            return this._radius
        },
        set: function(t) {
            t > 0 && (this._radius = t, this._diameter = 2 * t)
        }
    }), Object.defineProperty(t.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius
        },
        set: function(t) {
            t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
        }
    }), Object.defineProperty(t.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius
        },
        set: function(t) {
            t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
        }
    }), Object.defineProperty(t.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius
        },
        set: function(t) {
            t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
        }
    }), Object.defineProperty(t.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius
        },
        set: function(t) {
            t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
        }
    }), Object.defineProperty(t.Circle.prototype, "area", {
        get: function() {
            return this._radius > 0 ? Math.PI * this._radius * this._radius: 0
        }
    }), Object.defineProperty(t.Circle.prototype, "empty", {
        get: function() {
            return 0 === this._diameter
        },
        set: function(t) { ! 0 === t && this.setTo(0, 0, 0)
        }
    }), t.Circle.contains = function(t, e, i) {
        return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
    },
    t.Circle.equals = function(t, e) {
        return t.x === e.x && t.y === e.y && t.diameter === e.diameter
    },
    t.Circle.intersects = function(e, i) {
        return t.Math.distance(e.x, e.y, i.x, i.y) <= e.radius + i.radius
    },
    t.Circle.circumferencePoint = function(e, i, s, n) {
        return void 0 === s && (s = !1),
        void 0 === n && (n = new t.Point),
        !0 === s && (i = t.Math.degToRad(i)),
        n.x = e.x + e.radius * Math.cos(i),
        n.y = e.y + e.radius * Math.sin(i),
        n
    },
    t.Circle.intersectsRectangle = function(t, e) {
        var i = Math.abs(t.x - e.x - e.halfWidth);
        if (i > e.halfWidth + t.radius) return ! 1;
        var s = Math.abs(t.y - e.y - e.halfHeight);
        if (s > e.halfHeight + t.radius) return ! 1;
        if (i <= e.halfWidth || s <= e.halfHeight) return ! 0;
        var n = i - e.halfWidth,
        r = s - e.halfHeight;
        return n * n + r * r <= t.radius * t.radius
    },
    t.Circle.intersectsLine = function(e, i, s) {
        var n = e.x,
        r = e.y,
        o = (i.end.y - i.start.y) / (i.end.x - i.start.x),
        a = i.end.y - o * i.end.x,
        h = e.radius,
        l = e.radius,
        c = a + o * n,
        u = (n * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
        d = (n * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
        p = o * u + a,
        f = o * d + a,
        g = new t.Point(u, p),
        m = new t.Point(d, f),
        y = i.pointOnSegment(g.x, g.y, .01),
        v = i.pointOnSegment(m.x, m.y, .01);
        return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
    },
    PIXI.Circle = t.Circle, t.Ellipse = function(e, i, s, n) {
        e = e || 0,
        i = i || 0,
        s = s || 0,
        n = n || 0,
        this.x = e,
        this.y = i,
        this.width = s,
        this.height = n,
        this.type = t.ELLIPSE
    },
    t.Ellipse.prototype = {
        setTo: function(t, e, i, s) {
            return this.x = t,
            this.y = e,
            this.width = i,
            this.height = s,
            this
        },
        getBounds: function() {
            return new t.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
        },
        copyFrom: function(t) {
            return this.setTo(t.x, t.y, t.width, t.height)
        },
        copyTo: function(t) {
            return t.x = this.x,
            t.y = this.y,
            t.width = this.width,
            t.height = this.height,
            t
        },
        clone: function(e) {
            return null == e ? e = new t.Ellipse(this.x, this.y, this.width, this.height) : e.setTo(this.x, this.y, this.width, this.height),
            e
        },
        contains: function(e, i) {
            return t.Ellipse.contains(this, e, i)
        },
        random: function(e) {
            void 0 === e && (e = new t.Point);
            var i = Math.random() * Math.PI * 2,
            s = Math.sqrt(Math.random());
            return e.x = this.centerX + .5 * s * Math.cos(i) * this.width,
            e.y = this.centerY + .5 * s * Math.sin(i) * this.height,
            e
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
        }
    },
    t.Ellipse.prototype.constructor = t.Ellipse, Object.defineProperty(t.Ellipse.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(t) {
            this.x = t
        }
    }), Object.defineProperty(t.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(t) {
            t < this.x ? this.width = 0 : this.width = t - this.x
        }
    }), Object.defineProperty(t.Ellipse.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(t) {
            this.y = t
        }
    }), Object.defineProperty(t.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(t) {
            t < this.y ? this.height = 0 : this.height = t - this.y
        }
    }), Object.defineProperty(t.Ellipse.prototype, "centerX", {
        get: function() {
            return this.x + .5 * this.width
        }
    }), Object.defineProperty(t.Ellipse.prototype, "centerY", {
        get: function() {
            return this.y + .5 * this.height
        }
    }), Object.defineProperty(t.Ellipse.prototype, "empty", {
        get: function() {
            return 0 === this.width || 0 === this.height
        },
        set: function(t) { ! 0 === t && this.setTo(0, 0, 0, 0)
        }
    }), t.Ellipse.contains = function(t, e, i) {
        if (t.width <= 0 || t.height <= 0) return ! 1;
        var s = (e - t.x) / t.width - .5,
        n = (i - t.y) / t.height - .5;
        return (s *= s) + (n *= n) < .25
    },
    t.Ellipse.intersectsLine = function(e, i, s) {
        var n = e.x,
        r = e.y,
        o = (i.end.y - i.start.y) / (i.end.x - i.start.x),
        a = i.end.y - o * i.end.x,
        h = e.width / 2,
        l = e.height / 2,
        c = a + o * n,
        u = (n * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
        d = (n * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
        p = o * u + a,
        f = o * d + a,
        g = new t.Point(u, p),
        m = new t.Point(d, f),
        y = i.pointOnSegment(g.x, g.y, .01),
        v = i.pointOnSegment(m.x, m.y, .01);
        return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
    },
    PIXI.Ellipse = t.Ellipse, t.Line = function(e, i, s, n) {
        e = e || 0,
        i = i || 0,
        s = s || 0,
        n = n || 0,
        this.start = new t.Point(e, i),
        this.end = new t.Point(s, n),
        this.type = t.LINE
    },
    t.Line.prototype = {
        setTo: function(t, e, i, s) {
            return this.start.setTo(t, e),
            this.end.setTo(i, s),
            this
        },
        fromPoints: function(t, e) {
            return this.setTo(t.x, t.y, e.x, e.y),
            this
        },
        fromSprite: function(t, e, i) {
            return void 0 === i && (i = !1),
            i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.fromPoints(t, e)
        },
        fromAngle: function(t, e, i, s) {
            return this.start.setTo(t, e),
            this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s),
            this
        },
        rotate: function(t, e) {
            var i = (this.start.x + this.end.x) / 2,
            s = (this.start.y + this.end.y) / 2;
            return this.start.rotate(i, s, t, e),
            this.end.rotate(i, s, t, e),
            this
        },
        rotateAround: function(t, e, i, s) {
            return this.start.rotate(t, e, i, s),
            this.end.rotate(t, e, i, s),
            this
        },
        intersects: function(e, i, s) {
            return t.Line.intersectsPoints(this.start, this.end, e.start, e.end, i, s)
        },
        reflect: function(e) {
            return t.Line.reflect(this, e)
        },
        midPoint: function(e) {
            return void 0 === e && (e = new t.Point),
            e.x = (this.start.x + this.end.x) / 2,
            e.y = (this.start.y + this.end.y) / 2,
            e
        },
        centerOn: function(t, e) {
            var i = t - (this.start.x + this.end.x) / 2,
            s = e - (this.start.y + this.end.y) / 2;
            this.start.add(i, s),
            this.end.add(i, s)
        },
        pointOnLine: function(e, i, s) {
            return t.Math.fuzzyEqual((e - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (i - this.start.y), s || 0)
        },
        pointOnSegment: function(t, e, i) {
            var s = Math.min(this.start.x, this.end.x),
            n = Math.max(this.start.x, this.end.x),
            r = Math.min(this.start.y, this.end.y),
            o = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(t, e, i) && t >= s && t <= n && e >= r && e <= o
        },
        random: function(e) {
            void 0 === e && (e = new t.Point);
            var i = Math.random();
            return e.x = this.start.x + i * (this.end.x - this.start.x),
            e.y = this.start.y + i * (this.end.y - this.start.y),
            e
        },
        coordinatesOnLine: function(t, e) {
            void 0 === t && (t = 1),
            void 0 === e && (e = []);
            var i = Math.round(this.start.x),
            s = Math.round(this.start.y),
            n = Math.round(this.end.x),
            r = Math.round(this.end.y),
            o = Math.abs(n - i),
            a = Math.abs(r - s),
            h = i < n ? 1 : -1,
            l = s < r ? 1 : -1,
            c = o - a;
            e.push([i, s]);
            for (var u = 1; i !== n || s !== r;) {
                var d = c << 1;
                d > -a && (c -= a, i += h),
                d < o && (c += o, s += l),
                u % t == 0 && e.push([i, s]),
                u++
            }
            return e
        },
        clone: function(e) {
            return null == e ? e = new t.Line(this.start.x, this.start.y, this.end.x, this.end.y) : e.setTo(this.start.x, this.start.y, this.end.x, this.end.y),
            e
        }
    },
    Object.defineProperty(t.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
        }
    }), Object.defineProperty(t.Line.prototype, "angle", {
        get: function() {
            return t.Point.angle(this.end, this.start)
        }
    }), Object.defineProperty(t.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x)
        }
    }), Object.defineProperty(t.Line.prototype, "perpSlope", {
        get: function() {
            return - (this.end.x - this.start.x) / (this.end.y - this.start.y)
        }
    }), Object.defineProperty(t.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    }), Object.defineProperty(t.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    }), Object.defineProperty(t.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    }), Object.defineProperty(t.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x)
        }
    }), Object.defineProperty(t.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    }), Object.defineProperty(t.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y)
        }
    }), Object.defineProperty(t.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x)
        }
    }), Object.defineProperty(t.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y)
        }
    }), Object.defineProperty(t.Line.prototype, "normalX", {
        get: function() {
            return Math.cos(this.angle - 1.5707963267948966)
        }
    }), Object.defineProperty(t.Line.prototype, "normalY", {
        get: function() {
            return Math.sin(this.angle - 1.5707963267948966)
        }
    }), Object.defineProperty(t.Line.prototype, "normalAngle", {
        get: function() {
            return t.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
        }
    }), t.Line.intersectsPoints = function(e, i, s, n, r, o) {
        void 0 === r && (r = !0),
        void 0 === o && (o = new t.Point);
        var a = i.y - e.y,
        h = n.y - s.y,
        l = e.x - i.x,
        c = s.x - n.x,
        u = i.x * e.y - e.x * i.y,
        d = n.x * s.y - s.x * n.y,
        p = a * c - h * l;
        if (0 === p) return null;
        if (o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
            var f = (n.y - s.y) * (i.x - e.x) - (n.x - s.x) * (i.y - e.y),
            g = ((n.x - s.x) * (e.y - s.y) - (n.y - s.y) * (e.x - s.x)) / f,
            m = ((i.x - e.x) * (e.y - s.y) - (i.y - e.y) * (e.x - s.x)) / f;
            return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o: null
        }
        return o
    },
    t.Line.intersects = function(e, i, s, n) {
        return t.Line.intersectsPoints(e.start, e.end, i.start, i.end, s, n)
    },
    t.Line.intersectsRectangle = function(t, e) {
        if (0 === t.length || e.empty) return ! 1;
        var i = t.start.x,
        s = t.start.y,
        n = t.end.x,
        r = t.end.y,
        o = e.x,
        a = e.y,
        h = e.right,
        l = e.bottom,
        c = 0;
        if (i >= o && i <= h && s >= a && s <= l || n >= o && n <= h && r >= a && r <= l) return ! 0;
        if (i < o && n >= o) {
            if ((c = s + (r - s) * (o - i) / (n - i)) > a && c <= l) return ! 0
        } else if (i > h && n <= h && (c = s + (r - s) * (h - i) / (n - i)) >= a && c <= l) return ! 0;
        if (s < a && r >= a) {
            if ((c = i + (n - i) * (a - s) / (r - s)) >= o && c <= h) return ! 0
        } else if (s > l && r <= l && (c = i + (n - i) * (l - s) / (r - s)) >= o && c <= h) return ! 0;
        return ! 1
    },
    t.Line.intersectionWithRectangle = function(e, i, s) {
        var n = t.Line.intersectionWithRectangle;
        s || (s = new t.Point),
        n.edges || (n.edges = [new t.Line, new t.Line, new t.Line, new t.Line]),
        n.edgeIntersection || (n.edgeIntersection = new t.Point);
        var r = n.edges,
        o = n.edgeIntersection.set(0),
        a = i.x,
        h = i.y,
        l = i.right,
        c = i.bottom,
        u = 1 / 0;
        r[0].setTo(a, h, l, h),
        r[1].setTo(a, c, l, c),
        r[2].setTo(a, h, a, c),
        r[3].setTo(l, h, l, c);
        for (var d, p = 0; d = r[p]; p++) if (e.intersects(d, !0, o)) {
            var f = e.start.distance(o);
            f < u && (u = f, s.copyFrom(o))
        }
        return null != f ? s: null
    },
    t.Line.reflect = function(t, e) {
        return 2 * e.normalAngle - 3.141592653589793 - t.angle
    },
    t.Matrix = function(e, i, s, n, r, o) {
        null != e || (e = 1),
        null != i || (i = 0),
        null != s || (s = 0),
        null != n || (n = 1),
        null != r || (r = 0),
        null != o || (o = 0),
        this.a = e,
        this.b = i,
        this.c = s,
        this.d = n,
        this.tx = r,
        this.ty = o,
        this.type = t.MATRIX
    },
    t.Matrix.prototype = {
        fromArray: function(t) {
            return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
        },
        setTo: function(t, e, i, s, n, r) {
            return this.a = t,
            this.b = e,
            this.c = i,
            this.d = s,
            this.tx = n,
            this.ty = r,
            this
        },
        clone: function(e) {
            return null == e ? e = new t.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty),
            e
        },
        copyTo: function(t) {
            return t.copyFrom(this),
            t
        },
        copyFrom: function(t) {
            return this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.d = t.d,
            this.tx = t.tx,
            this.ty = t.ty,
            this
        },
        toArray: function(t, e) {
            return void 0 === e && (e = new Float32Array(9)),
            t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1),
            e
        },
        apply: function(e, i) {
            return void 0 === i && (i = new t.Point),
            i.x = this.a * e.x + this.c * e.y + this.tx,
            i.y = this.b * e.x + this.d * e.y + this.ty,
            i
        },
        applyInverse: function(e, i) {
            void 0 === i && (i = new t.Point);
            var s = 1 / (this.a * this.d + this.c * -this.b),
            n = e.x,
            r = e.y;
            return i.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s,
            i.y = this.a * s * r + -this.b * s * n + ( - this.ty * this.a + this.tx * this.b) * s,
            i
        },
        translate: function(t, e) {
            return this.tx += t,
            this.ty += e,
            this
        },
        scale: function(t, e) {
            return this.a *= t,
            this.d *= e,
            this.c *= t,
            this.b *= e,
            this.tx *= t,
            this.ty *= e,
            this
        },
        rotate: function(t) {
            var e = Math.cos(t),
            i = Math.sin(t),
            s = this.a,
            n = this.c,
            r = this.tx;
            return this.a = s * e - this.b * i,
            this.b = s * i + this.b * e,
            this.c = n * e - this.d * i,
            this.d = n * i + this.d * e,
            this.tx = r * e - this.ty * i,
            this.ty = r * i + this.ty * e,
            this
        },
        append: function(t) {
            var e = this.a,
            i = this.b,
            s = this.c,
            n = this.d;
            return this.a = t.a * e + t.b * s,
            this.b = t.a * i + t.b * n,
            this.c = t.c * e + t.d * s,
            this.d = t.c * i + t.d * n,
            this.tx = t.tx * e + t.ty * s + this.tx,
            this.ty = t.tx * i + t.ty * n + this.ty,
            this
        },
        identity: function() {
            return this.setTo(1, 0, 0, 1, 0, 0)
        }
    },
    t.identityMatrix = new t.Matrix, t.Point = function(e, i) {
        e = e || 0,
        i = i || 0,
        this.x = e,
        this.y = i,
        this.type = t.POINT
    },
    t.Point.prototype = {
        copyFrom: function(t) {
            return this.setTo(t.x, t.y)
        },
        invert: function() {
            return this.setTo(this.y, this.x)
        },
        setTo: function(e, i) {
            return t.Point.set(this, e, i)
        },
        set: function(e, i) {
            return t.Point.set(this, e, i)
        },
        setToPolar: function(e, i, s) {
            return null == i && (i = 1),
            s && (e = t.Math.degToRad(e)),
            this.setTo(Math.cos(e) * i, Math.sin(e) * i)
        },
        add: function(t, e) {
            return this.x += t,
            this.y += e,
            this
        },
        subtract: function(t, e) {
            return this.x -= t,
            this.y -= e,
            this
        },
        multiply: function(t, e) {
            return this.x *= t,
            this.y *= e,
            this
        },
        divide: function(t, e) {
            return this.x /= t,
            this.y /= e,
            this
        },
        clampX: function(e, i) {
            return this.x = t.Math.clamp(this.x, e, i),
            this
        },
        clampY: function(e, i) {
            return this.y = t.Math.clamp(this.y, e, i),
            this
        },
        clamp: function(e, i) {
            return this.x = t.Math.clamp(this.x, e, i),
            this.y = t.Math.clamp(this.y, e, i),
            this
        },
        clip: function(t) {
            var e = t.left,
            i = t.top,
            s = t.right,
            n = t.bottom;
            return this.x < e ? this.x = e: this.x > s && (this.x = s),
            this.y < i ? this.y = i: this.y > n && (this.y = n),
            this
        },
        clone: function(e) {
            return null == e ? e = new t.Point(this.x, this.y) : e.setTo(this.x, this.y),
            e
        },
        copyTo: function(t) {
            return t.x = this.x,
            t.y = this.y,
            t
        },
        distance: function(e, i) {
            return t.Point.distance(this, e, i)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        equalsXY: function(t, e) {
            return this.x === t && this.y === e
        },
        fuzzyEquals: function(e, i) {
            return t.Point.fuzzyEquals(this, e, i)
        },
        fuzzyEqualsXY: function(e, i, s) {
            return t.Point.fuzzyEqualsXY(this, e, i, s)
        },
        angle: function(t, e) {
            return this.angleXY(t.x, t.y, e)
        },
        angleXY: function(e, i, s) {
            var n = Math.atan2(i - this.y, e - this.x);
            return s ? t.Math.radToDeg(n) : n
        },
        atan: function(e) {
            var i = Math.atan2(this.y, this.x);
            return e ? t.Math.radToDeg(i) : i
        },
        rotate: function(e, i, s, n, r) {
            return t.Point.rotate(this, e, i, s, n, r)
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y
        },
        setMagnitude: function(t) {
            return this.normalize().multiply(t, t)
        },
        normalize: function() {
            if (!this.isZero()) {
                var t = this.getMagnitude();
                this.x /= t,
                this.y /= t
            }
            return this
        },
        limit: function(t) {
            return this.getMagnitudeSq() > t * t && this.setMagnitude(t),
            this
        },
        expand: function(t) {
            return this.getMagnitudeSq() < t * t && this.setMagnitude(t),
            this
        },
        isZero: function() {
            return 0 === this.x && 0 === this.y
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        perp: function() {
            return this.setTo( - this.y, this.x)
        },
        rperp: function() {
            return this.setTo(this.y, -this.x)
        },
        normalRightHand: function() {
            return this.setTo( - 1 * this.y, this.x)
        },
        floor: function() {
            return this.setTo(Math.floor(this.x), Math.floor(this.y))
        },
        ceil: function() {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
        },
        round: function() {
            return this.setTo(Math.round(this.x), Math.round(this.y))
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    },
    t.Point.prototype.constructor = t.Point, t.Point.add = function(e, i, s) {
        return void 0 === s && (s = new t.Point),
        s.x = e.x + i.x,
        s.y = e.y + i.y,
        s
    },
    t.Point.subtract = function(e, i, s) {
        return void 0 === s && (s = new t.Point),
        s.x = e.x - i.x,
        s.y = e.y - i.y,
        s
    },
    t.Point.multiply = function(e, i, s) {
        return void 0 === s && (s = new t.Point),
        s.x = e.x * i.x,
        s.y = e.y * i.y,
        s
    },
    t.Point.divide = function(e, i, s) {
        return void 0 === s && (s = new t.Point),
        s.x = e.x / i.x,
        s.y = e.y / i.y,
        s
    },
    t.Point.equals = function(t, e) {
        return t.x === e.x && t.y === e.y
    },
    t.Point.equalsXY = function(t, e, i) {
        return t.x === e && t.y === i
    },
    t.Point.fuzzyEquals = function(e, i, s) {
        return t.Math.fuzzyEquals(e.x, i.x, s) && t.Math.fuzzyEquals(e.y, i.y, s)
    },
    t.Point.fuzzyEqualsXY = function(e, i, s, n) {
        return t.Math.fuzzyEquals(e.x, i, n) && t.Math.fuzzyEquals(e.y, s, n)
    },
    t.Point.angle = function(t, e) {
        return Math.atan2(t.y - e.y, t.x - e.x)
    },
    t.Point.negative = function(e, i) {
        return void 0 === i && (i = new t.Point),
        i.setTo( - e.x, -e.y)
    },
    t.Point.multiplyAdd = function(e, i, s, n) {
        return void 0 === n && (n = new t.Point),
        n.setTo(e.x + i.x * s, e.y + i.y * s)
    },
    t.Point.interpolate = function(e, i, s, n) {
        return void 0 === n && (n = new t.Point),
        n.setTo(e.x + (i.x - e.x) * s, e.y + (i.y - e.y) * s)
    },
    t.Point.perp = function(e, i) {
        return void 0 === i && (i = new t.Point),
        i.setTo( - e.y, e.x)
    },
    t.Point.rperp = function(e, i) {
        return void 0 === i && (i = new t.Point),
        i.setTo(e.y, -e.x)
    },
    t.Point.distance = function(e, i, s) {
        var n = t.Math.distance(e.x, e.y, i.x, i.y);
        return s ? Math.round(n) : n
    },
    t.Point.project = function(e, i, s) {
        void 0 === s && (s = new t.Point);
        var n = e.dot(i) / i.getMagnitudeSq();
        return 0 !== n && s.setTo(n * i.x, n * i.y),
        s
    },
    t.Point.projectUnit = function(e, i, s) {
        void 0 === s && (s = new t.Point);
        var n = e.dot(i);
        return 0 !== n && s.setTo(n * i.x, n * i.y),
        s
    },
    t.Point.normalRightHand = function(e, i) {
        return void 0 === i && (i = new t.Point),
        i.setTo( - 1 * e.y, e.x)
    },
    t.Point.normalize = function(e, i) {
        void 0 === i && (i = new t.Point);
        var s = e.getMagnitude();
        return 0 !== s && i.setTo(e.x / s, e.y / s),
        i
    },
    t.Point.rotate = function(e, i, s, n, r, o) {
        if (r && (n = t.Math.degToRad(n)), void 0 === o) {
            e.subtract(i, s);
            var a = Math.sin(n),
            h = Math.cos(n),
            l = h * e.x - a * e.y,
            c = a * e.x + h * e.y;
            e.x = l + i,
            e.y = c + s
        } else {
            var u = n + Math.atan2(e.y - s, e.x - i);
            e.x = i + o * Math.cos(u),
            e.y = s + o * Math.sin(u)
        }
        return e
    },
    t.Point.centroid = function(e, i) {
        if (void 0 === i && (i = new t.Point), "[object Array]" !== Object.prototype.toString.call(e)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var s = e.length;
        if (s < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === s) return i.copyFrom(e[0]),
        i;
        for (var n = 0; n < s; n++) t.Point.add(i, e[n], i);
        return i.divide(s, s),
        i
    },
    t.Point.parse = function(e, i, s) {
        i = i || "x",
        s = s || "y";
        var n = new t.Point;
        return e[i] && (n.x = parseFloat(e[i], 10)),
        e[s] && (n.y = parseFloat(e[s], 10)),
        n
    },
    t.Point.trunc = function(e) {
        return e.x = t.Math.trunc(e.x),
        e.y = t.Math.trunc(e.y),
        e
    },
    t.Point.isPoint = function(t) {
        return null != t && "number" == typeof t.x && "number" == typeof t.y
    },
    t.Point.set = function(t, e, i) {
        return t.x = e || 0,
        t.y = i || (0 !== i ? t.x: 0),
        t
    },
    t.Point.sortClockwise = function(t, e) {
        e || (e = this.centroid(t));
        var i = e.x,
        s = e.y;
        return t.sort(function(t, e) {
            if (t.x - i >= 0 && e.x - i < 0) return - 1;
            if (t.x - i < 0 && e.x - i >= 0) return 1;
            if (t.x - i == 0 && e.x - i == 0) return t.y - s >= 0 || e.y - s >= 0 ? t.y > e.y ? 1 : -1 : e.y > t.y ? 1 : -1;
            var n = (t.x - i) * -(e.y - s) - (e.x - i) * -(t.y - s);
            return n < 0 ? -1 : n > 0 ? 1 : (t.x - i) * (t.x - i) + (t.y - s) * (t.y - s) > (e.x - i) * (e.x - i) + (e.y - s) * (e.y - s) ? -1 : 1
        })
    },
    PIXI.Point = t.Point, t.Polygon = function() {
        this.area = 0,
        this._points = [],
        arguments.length > 0 && this.setTo.apply(this, arguments),
        this.closed = !0,
        this.flattened = !1,
        this.type = t.POLYGON
    },
    t.Polygon.prototype = {
        toNumberArray: function(t) {
            void 0 === t && (t = []);
            for (var e = 0; e < this._points.length; e++)"number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
            return t
        },
        flatten: function() {
            return this._points = this.toNumberArray(),
            this.flattened = !0,
            this
        },
        clone: function(e) {
            var i = this._points.slice();
            return null == e ? e = new t.Polygon(i) : e.setTo(i),
            e
        },
        contains: function(t, e) {
            var i = !1;
            if (this.flattened) for (var s = -2,
            n = this._points.length - 2; (s += 2) < this._points.length; n = s) {
                var r = this._points[s],
                o = this._points[s + 1],
                a = this._points[n],
                h = this._points[n + 1]; (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
            } else for (s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                r = this._points[s].x,
                o = this._points[s].y,
                a = this._points[n].x,
                h = this._points[n].y; (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
            }
            return i
        },
        setTo: function(t) {
            if (this.area = 0, this._points = [], arguments.length > 0) {
                Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                for (var e = Number.MAX_VALUE,
                i = 0,
                s = t.length; i < s; i++) {
                    if ("number" == typeof t[i]) n = new PIXI.Point(t[i], t[i + 1]),
                    i++;
                    else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                    else var n = new PIXI.Point(t[i].x, t[i].y);
                    this._points.push(n),
                    n.y < e && (e = n.y)
                }
                this.calculateArea(e)
            }
            return this
        },
        calculateArea: function(t) {
            for (var e, i, s, n, r = 0,
            o = this._points.length; r < o; r++) e = this._points[r],
            i = r === o - 1 ? this._points[0] : this._points[r + 1],
            s = (e.y - t + (i.y - t)) / 2,
            n = e.x - i.x,
            this.area += s * n;
            return this.area
        }
    },
    t.Polygon.prototype.constructor = t.Polygon, Object.defineProperty(t.Polygon.prototype, "points", {
        get: function() {
            return this._points
        }
    }), PIXI.Polygon = t.Polygon, t.Rectangle = function(e, i, s, n) {
        e = e || 0,
        i = i || 0,
        s = s || 0,
        n = n || 0,
        this.x = e,
        this.y = i,
        this.width = s,
        this.height = n,
        this.type = t.RECTANGLE
    },
    t.Rectangle.prototype = {
        offset: function(t, e) {
            return this.x += t,
            this.y += e,
            this
        },
        offsetPoint: function(t) {
            return this.offset(t.x, t.y)
        },
        setTo: function(t, e, i, s) {
            return this.x = t,
            this.y = e,
            this.width = i,
            this.height = s,
            this
        },
        scale: function(t, e) {
            return void 0 === e && (e = t),
            this.width *= t,
            this.height *= e,
            this
        },
        centerOn: function(t, e) {
            return this.centerX = t,
            this.centerY = e,
            this
        },
        floor: function() {
            this.x = Math.floor(this.x),
            this.y = Math.floor(this.y)
        },
        floorAll: function() {
            this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.width = Math.floor(this.width),
            this.height = Math.floor(this.height)
        },
        ceil: function() {
            this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y)
        },
        ceilAll: function() {
            this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.width = Math.ceil(this.width),
            this.height = Math.ceil(this.height)
        },
        copyFrom: function(t) {
            return this.setTo(t.x, t.y, t.width, t.height)
        },
        copyFromBounds: function(t) {
            return this.setTo(t.left, t.top, t.width, t.height)
        },
        copyTo: function(t) {
            return t.x = this.x,
            t.y = this.y,
            t.width = this.width,
            t.height = this.height,
            t
        },
        inflate: function(e, i) {
            return t.Rectangle.inflate(this, e, i)
        },
        size: function(e) {
            return t.Rectangle.size(this, e)
        },
        resize: function(t, e) {
            return this.width = t,
            this.height = e,
            this
        },
        clone: function(e) {
            return t.Rectangle.clone(this, e)
        },
        contains: function(e, i) {
            return t.Rectangle.contains(this, e, i)
        },
        containsRect: function(e) {
            return t.Rectangle.containsRect(e, this)
        },
        equals: function(e) {
            return t.Rectangle.equals(this, e)
        },
        intersection: function(e, i) {
            return t.Rectangle.intersection(this, e, i)
        },
        intersects: function(e) {
            return t.Rectangle.intersects(this, e)
        },
        intersectsRaw: function(e, i, s, n, r) {
            return t.Rectangle.intersectsRaw(this, e, i, s, n, r)
        },
        union: function(e, i) {
            return t.Rectangle.union(this, e, i)
        },
        random: function(e) {
            return void 0 === e && (e = new t.Point),
            e.x = this.randomX,
            e.y = this.randomY,
            e
        },
        getPoint: function(e, i) {
            switch (void 0 === i && (i = new t.Point), e) {
            default:
            case t.TOP_LEFT:
                return i.set(this.x, this.y);
            case t.TOP_CENTER:
                return i.set(this.centerX, this.y);
            case t.TOP_RIGHT:
                return i.set(this.right, this.y);
            case t.LEFT_CENTER:
                return i.set(this.x, this.centerY);
            case t.CENTER:
                return i.set(this.centerX, this.centerY);
            case t.RIGHT_CENTER:
                return i.set(this.right, this.centerY);
            case t.BOTTOM_LEFT:
                return i.set(this.x, this.bottom);
            case t.BOTTOM_CENTER:
                return i.set(this.centerX, this.bottom);
            case t.BOTTOM_RIGHT:
                return i.set(this.right, this.bottom)
            }
        },
        sides: function(e, i, s, n) {
            arguments.length || (e = new t.Line, i = new t.Line, s = new t.Line, n = new t.Line);
            var r = this.x,
            o = this.y,
            a = this.right,
            h = this.bottom;
            return e.setTo(r, o, a, o),
            i.setTo(a, o, a, h),
            s.setTo(r, h, a, h),
            n.setTo(r, o, r, h),
            arguments.length ? null: [e, i, s, n]
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    },
    Object.defineProperty(t.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2)
        }
    }), Object.defineProperty(t.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2)
        }
    }), Object.defineProperty(t.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(t) {
            t <= this.y ? this.height = 0 : this.height = t - this.y
        }
    }), Object.defineProperty(t.Rectangle.prototype, "bottomLeft", {
        get: function() {
            return new t.Point(this.x, this.bottom)
        },
        set: function(t) {
            this.x = t.x,
            this.bottom = t.y
        }
    }), Object.defineProperty(t.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new t.Point(this.right, this.bottom)
        },
        set: function(t) {
            this.right = t.x,
            this.bottom = t.y
        }
    }), Object.defineProperty(t.Rectangle.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(t) {
            t >= this.right ? this.width = 0 : this.width = this.right - t,
            this.x = t
        }
    }), Object.defineProperty(t.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(t) {
            t <= this.x ? this.width = 0 : this.width = t - this.x
        }
    }), Object.defineProperty(t.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height
        }
    }), Object.defineProperty(t.Rectangle.prototype, "perimeter", {
        get: function() {
            return 2 * this.width + 2 * this.height
        }
    }), Object.defineProperty(t.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth
        },
        set: function(t) {
            this.x = t - this.halfWidth
        }
    }), Object.defineProperty(t.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight
        },
        set: function(t) {
            this.y = t - this.halfHeight
        }
    }), Object.defineProperty(t.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width
        }
    }), Object.defineProperty(t.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height
        }
    }), Object.defineProperty(t.Rectangle.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(t) {
            t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
        }
    }), Object.defineProperty(t.Rectangle.prototype, "topLeft", {
        get: function() {
            return new t.Point(this.x, this.y)
        },
        set: function(t) {
            this.x = t.x,
            this.y = t.y
        }
    }), Object.defineProperty(t.Rectangle.prototype, "topRight", {
        get: function() {
            return new t.Point(this.x + this.width, this.y)
        },
        set: function(t) {
            this.right = t.x,
            this.y = t.y
        }
    }), Object.defineProperty(t.Rectangle.prototype, "empty", {
        get: function() {
            return ! this.width || !this.height
        },
        set: function(t) { ! 0 === t && this.setTo(0, 0, 0, 0)
        }
    }), t.Rectangle.prototype.constructor = t.Rectangle, t.Rectangle.inflate = function(t, e, i) {
        return t.x -= e,
        t.width += 2 * e,
        t.y -= i,
        t.height += 2 * i,
        t
    },
    t.Rectangle.inflatePoint = function(e, i) {
        return t.Rectangle.inflate(e, i.x, i.y)
    },
    t.Rectangle.size = function(e, i) {
        return null == i ? i = new t.Point(e.width, e.height) : i.setTo(e.width, e.height),
        i
    },
    t.Rectangle.clone = function(e, i) {
        return null == i ? i = new t.Rectangle(e.x, e.y, e.width, e.height) : i.setTo(e.x, e.y, e.width, e.height),
        i
    },
    t.Rectangle.createFromBounds = function(e, i) {
        return null != i || (i = new t.Rectangle(e.x, e.y, e.width, e.height)),
        i.copyFromBounds(e)
    },
    t.Rectangle.contains = function(t, e, i) {
        return ! (t.width <= 0 || t.height <= 0) && e >= t.x && e < t.right && i >= t.y && i < t.bottom
    },
    t.Rectangle.containsRaw = function(t, e, i, s, n, r) {
        return n >= t && n < t + i && r >= e && r < e + s
    },
    t.Rectangle.containsPoint = function(e, i) {
        return t.Rectangle.contains(e, i.x, i.y)
    },
    t.Rectangle.containsRect = function(t, e) {
        return ! (t.volume > e.volume) && t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom
    },
    t.Rectangle.equals = function(t, e) {
        return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
    },
    t.Rectangle.sameDimensions = function(t, e) {
        return t.width === e.width && t.height === e.height
    },
    t.Rectangle.intersection = function(e, i, s) {
        return void 0 === s && (s = new t.Rectangle),
        t.Rectangle.intersects(e, i) && (s.x = Math.max(e.x, i.x), s.y = Math.max(e.y, i.y), s.width = Math.min(e.right, i.right) - s.x, s.height = Math.min(e.bottom, i.bottom) - s.y),
        s
    },
    t.Rectangle.intersects = function(t, e) {
        return ! (t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
    },
    t.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
        return void 0 === r && (r = 0),
        !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
    },
    t.Rectangle.union = function(e, i, s) {
        return void 0 === s && (s = new t.Rectangle),
        s.setTo(Math.min(e.x, i.x), Math.min(e.y, i.y), Math.max(e.right, i.right) - Math.min(e.left, i.left), Math.max(e.bottom, i.bottom) - Math.min(e.top, i.top))
    },
    t.Rectangle.aabb = function(e, i) {
        void 0 === i && (i = new t.Rectangle);
        var s = Number.NEGATIVE_INFINITY,
        n = Number.POSITIVE_INFINITY,
        r = Number.NEGATIVE_INFINITY,
        o = Number.POSITIVE_INFINITY;
        return e.forEach(function(t) {
            t.x > s && (s = t.x),
            t.x < n && (n = t.x),
            t.y > r && (r = t.y),
            t.y < o && (o = t.y)
        }),
        i.setTo(n, o, s - n, r - o),
        i
    },
    PIXI.Rectangle = t.Rectangle, t.EmptyRectangle = new t.Rectangle(0, 0, 0, 0), t.RoundedRectangle = function(e, i, s, n, r) {
        void 0 === e && (e = 0),
        void 0 === i && (i = 0),
        void 0 === s && (s = 0),
        void 0 === n && (n = 0),
        void 0 === r && (r = 20),
        this.x = e,
        this.y = i,
        this.width = s,
        this.height = n,
        this.radius = r || 20,
        this.type = t.ROUNDEDRECTANGLE
    },
    t.RoundedRectangle.prototype = {
        clone: function() {
            return new t.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
        },
        contains: function(t, e) {
            if (this.width <= 0 || this.height <= 0) return ! 1;
            var i = this.x;
            if (t >= i && t <= i + this.width) {
                var s = this.y;
                if (e >= s && e <= s + this.height) return ! 0
            }
            return ! 1
        }
    },
    t.RoundedRectangle.prototype.constructor = t.RoundedRectangle, PIXI.RoundedRectangle = t.RoundedRectangle, t.Camera = function(e, i, s, n, r, o) {
        this.game = e,
        this.world = e.world,
        this.id = 0,
        this.view = new t.Rectangle(s, n, r, o),
        this.bounds = new t.Rectangle(s, n, r, o),
        this.deadzone = null,
        this.visible = !0,
        this.roundPx = !0,
        this.atLimit = {
            x: !1,
            y: !1
        },
        this.target = null,
        this.displayObject = null,
        this.scale = null,
        this.totalInView = 0,
        this.lerp = new t.Point(1, 1),
        this.onShakeComplete = new t.Signal,
        this.onFlashComplete = new t.Signal,
        this.onFadeComplete = new t.Signal,
        this.fx = null,
        this._targetPosition = new t.Point,
        this._edge = 0,
        this._position = new t.Point,
        this._shake = {
            intensity: 0,
            duration: 0,
            horizontal: !1,
            vertical: !1,
            shakeBounds: !0,
            x: 0,
            y: 0
        },
        this._fxDuration = 0,
        this._fxType = 0,
        this._fixedView = new t.Rectangle
    },
    t.Camera.FOLLOW_LOCKON = 0, t.Camera.FOLLOW_PLATFORMER = 1, t.Camera.FOLLOW_TOPDOWN = 2, t.Camera.FOLLOW_TOPDOWN_TIGHT = 3, t.Camera.SHAKE_BOTH = 4, t.Camera.SHAKE_HORIZONTAL = 5, t.Camera.SHAKE_VERTICAL = 6, t.Camera.ENABLE_FX = !0, t.Camera.prototype = {
        boot: function() {
            this.displayObject = this.game.world,
            this.scale = this.game.world.scale,
            this.game.camera = this,
            t.Graphics && t.Camera.ENABLE_FX && (this.fx = new t.Graphics(this.game), this.game.stage.addChild(this.fx))
        },
        preUpdate: function() {
            this.totalInView = 0
        },
        follow: function(e, i, s, n) {
            var r;
            switch (void 0 === i && (i = t.Camera.FOLLOW_LOCKON), void 0 === s && (s = 1), void 0 === n && (n = 1), this.target = e, this.lerp.set(s, n), i) {
            case t.Camera.FOLLOW_PLATFORMER:
                var o = this.width / 8,
                a = this.height / 3;
                this.deadzone = new t.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                break;
            case t.Camera.FOLLOW_TOPDOWN:
                r = Math.max(this.width, this.height) / 4,
                this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                break;
            case t.Camera.FOLLOW_TOPDOWN_TIGHT:
                r = Math.max(this.width, this.height) / 8,
                this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                break;
            case t.Camera.FOLLOW_LOCKON:
            default:
                this.deadzone = null
            }
        },
        unfollow: function() {
            this.target = null
        },
        focusOn: function(t) {
            this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
        },
        focusOnXY: function(t, e) {
            this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
        },
        shake: function(e, i, s, n, r) {
            return void 0 === e && (e = .05),
            void 0 === i && (i = 500),
            void 0 === s && (s = !0),
            void 0 === n && (n = t.Camera.SHAKE_BOTH),
            void 0 === r && (r = !0),
            !(!s && this._shake.duration > 0 || (this._shake.intensity = e, this._shake.duration = i, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = n === t.Camera.SHAKE_BOTH || n === t.Camera.SHAKE_HORIZONTAL, this._shake.vertical = n === t.Camera.SHAKE_BOTH || n === t.Camera.SHAKE_VERTICAL, 0))
        },
        flash: function(t, e, i, s) {
            return void 0 === t && (t = 16777215),
            void 0 === e && (e = 500),
            void 0 === i && (i = !1),
            void 0 === s && (s = 1),
            !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, 0))
        },
        fade: function(t, e, i, s) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = 500),
            void 0 === i && (i = !1),
            void 0 === s && (s = 1),
            !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, 0))
        },
        update: function() {
            this._fxDuration > 0 && this.updateFX(),
            this._shake.duration > 0 && this.updateShake(),
            this.bounds && this.checkBounds(),
            this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)),
            this.displayObject.position.x = -this.view.x,
            this.displayObject.position.y = -this.view.y
        },
        updateFX: function() {
            0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
        },
        updateShake: function() {
            this._shake.duration -= this.game.time.elapsedMS,
            this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
        },
        updateTarget: function() {
            this._targetPosition.x = this.view.x + this.target.worldPosition.x,
            this._targetPosition.y = this.view.y + this.target.worldPosition.y,
            this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)),
            this.bounds && this.checkBounds(),
            this.roundPx && this.view.floor(),
            this.displayObject.position.x = -this.view.x,
            this.displayObject.position.y = -this.view.y
        },
        setBoundsToWorld: function() {
            this.bounds && this.bounds.copyFrom(this.game.world.bounds)
        },
        checkBounds: function() {
            this.atLimit.x = !1,
            this.atLimit.y = !1;
            var t = this.view.x + this._shake.x,
            e = this.view.right + this._shake.x,
            i = this.view.y + this._shake.y,
            s = this.view.bottom + this._shake.y;
            t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)),
            i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
        },
        setPosition: function(t, e) {
            this.view.x = t,
            this.view.y = e,
            this.bounds && this.checkBounds()
        },
        setSize: function(t, e) {
            this.view.width = t,
            this.view.height = e
        },
        reset: function() {
            this.target = null,
            this.view.x = 0,
            this.view.y = 0,
            this._shake.duration = 0,
            this._shake.x = 0,
            this._shake.y = 0,
            this.resetFX()
        },
        resetFX: function() {
            this.fx && (this.fx.clear(), this.fx.alpha = 0),
            this._fxDuration = 0
        }
    },
    t.Camera.prototype.constructor = t.Camera, Object.defineProperty(t.Camera.prototype, "x", {
        get: function() {
            return this.view.x
        },
        set: function(t) {
            this.view.x = t,
            this.bounds && this.checkBounds()
        }
    }), Object.defineProperty(t.Camera.prototype, "y", {
        get: function() {
            return this.view.y
        },
        set: function(t) {
            this.view.y = t,
            this.bounds && this.checkBounds()
        }
    }), Object.defineProperty(t.Camera.prototype, "position", {
        get: function() {
            return this._position.set(this.view.x, this.view.y),
            this._position
        },
        set: function(t) {
            void 0 !== t.x && (this.view.x = t.x),
            void 0 !== t.y && (this.view.y = t.y),
            this.bounds && this.checkBounds()
        }
    }), Object.defineProperty(t.Camera.prototype, "width", {
        get: function() {
            return this.view.width
        },
        set: function(t) {
            this.view.width = t
        }
    }), Object.defineProperty(t.Camera.prototype, "height", {
        get: function() {
            return this.view.height
        },
        set: function(t) {
            this.view.height = t
        }
    }), Object.defineProperty(t.Camera.prototype, "shakeIntensity", {
        get: function() {
            return this._shake.intensity
        },
        set: function(t) {
            this._shake.intensity = t
        }
    }), Object.defineProperty(t.Camera.prototype, "fixedView", {
        get: function() {
            return this._fixedView.setTo(0, 0, this.view.width, this.view.height),
            this._fixedView
        }
    }), Object.defineProperty(t.Camera.prototype, "centerX", {
        get: function() {
            return this.x + .5 * this.width
        }
    }), Object.defineProperty(t.Camera.prototype, "centerY", {
        get: function() {
            return this.y + .5 * this.height
        }
    }), t.State = function() {
        this.game = null,
        this.key = "",
        this.add = null,
        this.make = null,
        this.camera = null,
        this.cache = null,
        this.input = null,
        this.load = null,
        this.math = null,
        this.sound = null,
        this.scale = null,
        this.stage = null,
        this.state = null,
        this.time = null,
        this.tweens = null,
        this.world = null,
        this.particles = null,
        this.physics = null,
        this.rnd = null
    },
    t.State.prototype = {
        init: function() {},
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        postUpdate: function() {},
        preRender: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        resumed: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    },
    t.State.prototype.constructor = t.State, t.StateManager = function(e, i) {
        this.game = e,
        this.states = {},
        this._pendingState = null,
        null != i && (this._pendingState = i),
        this._clearWorld = !1,
        this._clearCache = !1,
        this._created = !1,
        this._args = [],
        this.current = "",
        this.onStateChange = new t.Signal,
        this.onInitCallback = null,
        this.onPreloadCallback = null,
        this.onCreateCallback = null,
        this.onUpdateCallback = null,
        this.onRenderCallback = null,
        this.onResizeCallback = null,
        this.onPreRenderCallback = null,
        this.onLoadUpdateCallback = null,
        this.onLoadRenderCallback = null,
        this.onPausedCallback = null,
        this.onResumedCallback = null,
        this.onPauseUpdateCallback = null,
        this.onShutDownCallback = null
    },
    t.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this),
            this.game.onResume.add(this.resume, this),
            null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
        },
        add: function(e, i, s) {
            var n;
            return void 0 === s && (s = !1),
            i instanceof t.State ? n = i: "object" == typeof i ? (n = i).game = this.game: "function" == typeof i && (n = new i(this.game)),
            this.states[e] = n,
            s && (this.game.isBooted ? this.start(e) : this._pendingState = e),
            n
        },
        remove: function(t) {
            this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null),
            delete this.states[t]
        },
        start: function(t, e, i) {
            void 0 === e && (e = !0),
            void 0 === i && (i = !1),
            this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
        },
        restart: function(t, e) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !1),
            this._pendingState = this.current,
            this._clearWorld = t,
            this._clearCache = e,
            arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                var t = this.current;
                if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                this._pendingState = null,
                this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
            }
        },
        clearCurrentState: function() {
            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
        },
        checkState: function(t) {
            var e = this.states[t];
            return e ? !!(e.preload || e.create || e.update || e.render) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
        },
        link: function(t) {
            var e = this.states[t];
            e.game = this.game,
            e.add = this.game.add,
            e.make = this.game.make,
            e.camera = this.game.camera,
            e.cache = this.game.cache,
            e.input = this.game.input,
            e.load = this.game.load,
            e.math = this.game.math,
            e.sound = this.game.sound,
            e.scale = this.game.scale,
            e.state = this,
            e.stage = this.game.stage,
            e.time = this.game.time,
            e.tweens = this.game.tweens,
            e.world = this.game.world,
            e.particles = this.game.particles,
            e.rnd = this.game.rnd,
            e.physics = this.game.physics,
            e.key = t
        },
        unlink: function(t) {
            var e = this.states[t];
            e && (e.game = null, e.add = null, e.make = null, e.camera = null, e.cache = null, e.input = null, e.load = null, e.math = null, e.sound = null, e.scale = null, e.state = null, e.stage = null, e.time = null, e.tweens = null, e.world = null, e.particles = null, e.rnd = null, e.physics = null)
        },
        setCurrentState: function(t) {
            var e = this.states[t];
            this.callbackContext = e,
            this.link(t),
            this.onInitCallback = e.init || this.dummy,
            this.onPreloadCallback = e.preload || null,
            this.onLoadRenderCallback = e.loadRender || null,
            this.onLoadUpdateCallback = e.loadUpdate || null,
            this.onCreateCallback = e.create || null,
            this.onUpdateCallback = e.update || null,
            this.onPostUpdateCallback = e.postUpdate || null,
            this.onPreRenderCallback = e.preRender || null,
            this.onRenderCallback = e.render || null,
            this.onResizeCallback = e.resize || null,
            this.onPausedCallback = e.paused || null,
            this.onResumedCallback = e.resumed || null,
            this.onPauseUpdateCallback = e.pauseUpdate || null,
            this.onShutDownCallback = e.shutdown || this.dummy,
            "" !== this.current && this.game.physics.reset(),
            this.current = t,
            this._created = !1,
            this.onInitCallback.apply(this.callbackContext, this._args),
            t === this._pendingState && (this._args = []),
            this.game._kickstart = !0
        },
        getCurrentState: function() {
            return this.states[this.current]
        },
        loadComplete: function() { ! 1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
        },
        loadUpdate: function() { ! 1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        pause: function() {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
        },
        resume: function() {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
        },
        update: function() {
            this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        postUpdate: function() {
            this._created && this.onPostUpdateCallback && this.onPostUpdateCallback.call(this.callbackContext, this.game)
        },
        pauseUpdate: function() {
            this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        preRender: function(t) {
            this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
        },
        resize: function(t, e) {
            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
        },
        render: function() {
            this._created ? this.onRenderCallback && (this.game.renderType === t.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
        },
        destroy: function() {
            this._clearWorld = !0,
            this._clearCache = !0,
            this.clearCurrentState(),
            this.callbackContext = null,
            this.onInitCallback = null,
            this.onShutDownCallback = null,
            this.onPreloadCallback = null,
            this.onLoadRenderCallback = null,
            this.onLoadUpdateCallback = null,
            this.onCreateCallback = null,
            this.onUpdateCallback = null,
            this.onPostUpdateCallback = null,
            this.onRenderCallback = null,
            this.onPausedCallback = null,
            this.onResumedCallback = null,
            this.onPauseUpdateCallback = null,
            this.game = null,
            this.states = {},
            this._pendingState = null,
            this.current = ""
        }
    },
    t.StateManager.prototype.constructor = t.StateManager, Object.defineProperty(t.StateManager.prototype, "created", {
        get: function() {
            return this._created
        }
    }), t.Signal = function() {},
    t.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !1,
        validateListener: function(t, e) {
            if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
        },
        _registerListener: function(e, i, s, n, r) {
            var o, a = this._indexOfListener(e, s);
            if ( - 1 !== a) {
                if ((o = this._bindings[a]).isOnce() !== i) throw new Error("You cannot add" + (i ? "": "Once") + "() then add" + (i ? "Once": "") + "() the same listener without removing the relationship first.")
            } else o = new t.SignalBinding(this, e, i, s, n, r),
            this._addBinding(o);
            return this.memorize && this._prevParams && o.execute(this._prevParams),
            o
        },
        _addBinding: function(t) {
            this._bindings || (this._bindings = []);
            var e = this._bindings.length;
            do {
                e--
            } while ( this . _bindings [ e ] && t._priority <= this._bindings[e]._priority);
            this._bindings.splice(e + 1, 0, t)
        },
        _indexOfListener: function(t, e) {
            if (!this._bindings) return - 1;
            void 0 === e && (e = null);
            for (var i, s = this._bindings.length; s--;) if ((i = this._bindings[s])._listener === t && i.context === e) return s;
            return - 1
        },
        has: function(t, e) {
            return - 1 !== this._indexOfListener(t, e)
        },
        add: function(t, e, i) {
            this.validateListener(t, "add");
            var s = [];
            if (arguments.length > 3) for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
            return this._registerListener(t, !1, e, i, s)
        },
        addOnce: function(t, e, i) {
            this.validateListener(t, "addOnce");
            var s = [];
            if (arguments.length > 3) for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
            return this._registerListener(t, !0, e, i, s)
        },
        remove: function(t, e) {
            this.validateListener(t, "remove");
            var i = this._indexOfListener(t, e);
            return - 1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)),
            t
        },
        removeAll: function(t) {
            if (void 0 === t && (t = null), this._bindings) {
                for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                t || (this._bindings.length = 0)
            }
        },
        getNumListeners: function() {
            return this._bindings ? this._bindings.length: 0
        },
        halt: function() {
            this._shouldPropagate = !1
        },
        dispatch: function() {
            if (this.active && (this._bindings || this.memorize)) {
                var t = Array.prototype.slice.call(arguments);
                this.memorize && (this._prevParams = t);
                var e = this._bindings ? this._bindings.length: 0;
                if (e) {
                    var i = this._bindings.slice();
                    this._shouldPropagate = !0;
                    do {
                        e--
                    } while ( i [ e ] && this._shouldPropagate && !1 !== i[e].execute(t))
                }
            }
        },
        forget: function() {
            this._prevParams && (this._prevParams = null)
        },
        dispose: function() {
            this.removeAll(),
            this._bindings = null,
            this._prevParams && (this._prevParams = null)
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    },
    Object.defineProperty(t.Signal.prototype, "boundDispatch", {
        get: function() {
            var t = this;
            return this._boundDispatch || (this._boundDispatch = function() {
                return t.dispatch.apply(t, arguments)
            })
        }
    }), t.Signal.prototype.constructor = t.Signal, t.SignalBinding = function(t, e, i, s, n, r) {
        this._listener = e,
        i && (this._isOnce = !0),
        null != s && (this.context = s),
        this._signal = t,
        n && (this._priority = n),
        r && r.length && (this._args = r)
    },
    t.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function(t) {
            var e, i;
            return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()),
            e
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null
        },
        isBound: function() {
            return !! this._signal && !!this._listener
        },
        isOnce: function() {
            return this._isOnce
        },
        getListener: function() {
            return this._listener
        },
        getSignal: function() {
            return this._signal
        },
        _destroy: function() {
            delete this._signal,
            delete this._listener,
            delete this.context
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    },
    t.SignalBinding.prototype.constructor = t.SignalBinding, t.Filter = function(e, i, s) {
        this.game = e,
        this.type = t.WEBGL_FILTER,
        this.passes = [this],
        this.shaders = [],
        this.dirty = !0,
        this.padding = 0,
        this.prevPoint = new t.Point;
        var n = new Date;
        if (this.uniforms = {
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            time: {
                type: "1f",
                value: 0
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            date: {
                type: "4fv",
                value: [n.getFullYear(), n.getMonth(), n.getDate(), 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds()]
            },
            sampleRate: {
                type: "1f",
                value: 44100
            },
            iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            }
        },
        i) for (var r in i) this.uniforms[r] = i[r];
        "string" == typeof s && (s = s.split("\n")),
        this.fragmentSrc = s || []
    },
    t.Filter.prototype = {
        init: function() {},
        setResolution: function(t, e) {
            this.uniforms.resolution.value.x = t,
            this.uniforms.resolution.value.y = e
        },
        update: function(t) {
            if (t) {
                var e = t.x / this.game.width,
                i = 1 - t.y / this.game.height;
                e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds()
        },
        addToWorld: function(e, i, s, n, r, o) {
            void 0 === r && (r = 0),
            void 0 === o && (o = 0),
            null != s ? this.width = s: s = this.width,
            null != n ? this.height = n: n = this.height;
            var a = this.game.add.image(e, i, t.Cache.DEFAULT);
            return a.width = s,
            a.height = n,
            a.anchor.set(r, o),
            a.filters = [this],
            a
        },
        syncUniforms: function() {
            for (var t = 0; t < this.shaders.length; t++) this.shaders[t].dirty = !0
        },
        destroy: function() {
            this.passes.length = 0,
            this.shaders.length = 0,
            this.fragmentSrc.length = 0,
            this.game = null,
            this.uniforms = null,
            this.prevPoint = null
        }
    },
    t.Filter.prototype.constructor = t.Filter, Object.defineProperty(t.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x
        },
        set: function(t) {
            this.uniforms.resolution.value.x = t
        }
    }), Object.defineProperty(t.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y
        },
        set: function(t) {
            this.uniforms.resolution.value.y = t
        }
    }), t.Plugin = function(t, e) {
        void 0 === e && (e = null),
        this.game = t,
        this.parent = e,
        this.active = !1,
        this.visible = !1,
        this.hasPreUpdate = !1,
        this.hasUpdate = !1,
        this.hasPostUpdate = !1,
        this.hasRender = !1,
        this.hasPostRender = !1
    },
    t.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null,
            this.parent = null,
            this.active = !1,
            this.visible = !1
        }
    },
    t.Plugin.prototype.constructor = t.Plugin, t.PluginManager = function(t) {
        this.game = t,
        this.plugins = [],
        this._len = 0,
        this._i = 0
    },
    t.PluginManager.prototype = {
        add: function(t) {
            var e = Array.prototype.slice.call(arguments, 1),
            i = !1;
            return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this),
            "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0),
            "function" == typeof t.update && (t.hasUpdate = !0, i = !0),
            "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0),
            "function" == typeof t.render && (t.hasRender = !0, i = !0),
            "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0),
            i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
        },
        remove: function(t, e) {
            for (void 0 === e && (e = !0), this._i = this._len; this._i--;) if (this.plugins[this._i] === t) return e && t.destroy(),
            this.plugins.splice(this._i, 1),
            void this._len--
        },
        removeAll: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
            this.plugins.length = 0,
            this._len = 0
        },
        preUpdate: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
        },
        update: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
        },
        postUpdate: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
        },
        render: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
        },
        postRender: function() {
            for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
        },
        destroy: function() {
            this.removeAll(),
            this.game = null
        }
    },
    t.PluginManager.prototype.constructor = t.PluginManager, t.Stage = function(e) {
        this.game = e,
        PIXI.DisplayObjectContainer.call(this),
        this.name = "_stage_root",
        this.disableVisibilityChange = !1,
        this.exists = !0,
        this.worldTransform = new t.Matrix,
        this.stage = this,
        this.currentRenderOrderID = 0,
        this._hiddenVar = "hidden",
        this._onChange = null,
        this._bgColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            color: 0,
            rgba: "#000000"
        },
        this.game.transparent || (this._bgColor.a = 1),
        e.config && this.parseConfig(e.config)
    },
    t.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Stage.prototype.constructor = t.Stage, t.Stage.prototype.parseConfig = function(t) {
        t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange),
        t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
    },
    t.Stage.prototype.boot = function() {
        t.DOM.getOffset(this.game.canvas, this.offset),
        t.Canvas.setUserSelect(this.game.canvas, "none"),
        t.Canvas.setTouchAction(this.game.canvas, "none"),
        this.checkVisibility()
    },
    t.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for (var t = 0; t < this.children.length;) {
            var e = this.children[t];
            e.preUpdate(),
            this === e.parent && t++
        }
    },
    t.Stage.prototype.update = function() {
        for (var t = this.children.length; t--;) this.children[t].update()
    },
    t.Stage.prototype.postUpdate = function() {
        this.game.camera.update(),
        this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
        this.updateTransform()
    },
    t.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    },
    t.Stage.prototype.checkVisibility = function() {
        void 0 !== document.hidden ? this._hiddenVar = "visibilitychange": void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange": void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange": void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange": this._hiddenVar = null;
        var t = this;
        this._onChange = function(e) {
            return t.visibilityChange(e)
        },
        this._onChangePause = function() {
            return t._onChange({
                type: "pause"
            })
        },
        this._onChangeResume = function() {
            return t._onChange({
                type: "resume"
            })
        },
        this._onClick = function(e) {
            void 0 === document.hasFocus || document.hasFocus() || t.visibilityChange(e)
        },
        this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1),
        window.onblur = this._onChange,
        window.onfocus = this._onChange,
        window.onpagehide = this._onChange,
        window.onpageshow = this._onChange,
        window.addEventListener("click", this._onClick),
        this.game.device.cocoonJSApp && CocoonJS.App && (CocoonJS.App.onSuspended && CocoonJS.App.onSuspended.addEventListener(this._onChangePause), CocoonJS.App.onActivated && CocoonJS.App.onActivated.addEventListener(this._onChangeResume), CocoonJS.App.on && (CocoonJS.App.on("activated", this._onChangeResume), CocoonJS.App.on("suspended", this._onChangePause)))
    },
    t.Stage.prototype.visibilityChange = function(t) {
        switch (t.type) {
        case "blur":
        case "pagehide":
            return void this.game.focusLoss(t);
        case "click":
        case "focus":
        case "pageshow":
            return void this.game.focusGain(t)
        }
        this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
    },
    t.Stage.prototype.setBackgroundColor = function(e) {
        this.game.transparent || (t.Color.valueToColor(e, this._bgColor), t.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
    },
    t.Stage.prototype.destroy = function() {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1),
        window.onpagehide = null,
        window.onpageshow = null,
        window.onblur = null,
        window.onfocus = null,
        window.removeEventListener("click", this._onClick)
    },
    t.Stage.prototype.add = function(t, e, i) {
        return t.parent === this ? t: (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? this.addChild(t) : this.addChildAt(t, i), t)
    },
    Object.defineProperty(t.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._bgColor.color
        },
        set: function(t) {
            this.setBackgroundColor(t)
        }
    }), Object.defineProperty(t.Stage.prototype, "smoothed", {
        get: function() {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
        },
        set: function(t) {
            PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR: PIXI.scaleModes.NEAREST
        }
    }), t.Group = function(e, i, s, n, r, o) {
        void 0 === n && (n = !1),
        void 0 === r && (r = !1),
        void 0 === o && (o = t.Physics.ARCADE),
        this.game = e,
        void 0 === i && (i = e.world),
        this.name = s || "group",
        this.z = 0,
        PIXI.DisplayObjectContainer.call(this),
        n ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : i && (i.addChild(this), this.z = i.children.length),
        this.type = t.GROUP,
        this.physicsType = t.GROUP,
        this.alive = !0,
        this.exists = !0,
        this.ignoreDestroy = !1,
        this.pendingDestroy = !1,
        this.classType = t.Sprite,
        this.cursor = null,
        this.inputEnableChildren = !1,
        this.updateOnlyExistingChildren = !1,
        this.onChildInputDown = new t.Signal,
        this.onChildInputUp = new t.Signal,
        this.onChildInputOver = new t.Signal,
        this.onChildInputOut = new t.Signal,
        this.enableBody = r,
        this.enableBodyDebug = !1,
        this.physicsBodyType = o,
        this.physicsSortDirection = null,
        this.onDestroy = new t.Signal,
        this.cursorIndex = 0,
        this.fixedToCamera = !1,
        this.cameraOffset = new t.Point,
        this.hash = [],
        this._sortProperty = "z"
    },
    t.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Group.prototype.constructor = t.Group, t.Group.RETURN_NONE = 0, t.Group.RETURN_TOTAL = 1, t.Group.RETURN_CHILD = 2, t.Group.RETURN_ALL = 3, t.Group.SORT_ASCENDING = -1, t.Group.SORT_DESCENDING = 1, t.Group.prototype.add = function(t, e, i) {
        return void 0 === e && (e = !1),
        t.parent === this ? t: (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
    },
    t.Group.prototype.addAt = function(t, e, i) {
        return this.add(t, i, e)
    },
    t.Group.prototype.addToHash = function(t) {
        return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
    },
    t.Group.prototype.removeFromHash = function(t) {
        if (t) {
            var e = this.hash.indexOf(t);
            if ( - 1 !== e) return this.hash.splice(e, 1),
            !0
        }
        return ! 1
    },
    t.Group.prototype.addMultiple = function(e, i) {
        if (e instanceof t.Group) e.moveAll(this, i);
        else if (Array.isArray(e)) for (var s = 0; s < e.length; s++) this.add(e[s], i);
        return e
    },
    t.Group.prototype.getAt = function(t) {
        return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
    },
    t.Group.prototype.create = function(t, e, i, s, n, r) {
        void 0 === n && (n = !0);
        var o = new this.classType(this.game, t, e, i, s);
        return o.exists = n,
        o.visible = n,
        o.alive = n,
        this.add(o, !1, r)
    },
    t.Group.prototype.createMultiple = function(t, e, i, s, n, r) {
        void 0 === i && (i = 0),
        void 0 === s && (s = !1),
        Array.isArray(e) || (e = [e]),
        Array.isArray(i) || (i = [i]);
        var o = this,
        a = [];
        return e.forEach(function(e) {
            i.forEach(function(i) {
                for (var h = 0; h < t; h++) {
                    var l = o.create(0, 0, e, i, s);
                    n && n.call(r || l, l, h),
                    a.push(l)
                }
            })
        }),
        a
    },
    t.Group.prototype.updateZ = function() {
        for (var t = this.children.length; t--;) this.children[t].z = t
    },
    t.Group.prototype.align = function(e, i, s, n, r, o) {
        if (void 0 === r && (r = t.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === e && -1 === i) return ! 1;
        for (var a = new t.Rectangle(0, 0, s, n), h = e * s, l = i * n, c = o; c < this.children.length; c++) {
            var u = this.children[c];
            if (u.alignIn) if (u.alignIn(a, r), -1 === e) a.y += n,
            a.y === l && (a.x += s, a.y = 0);
            else if ( - 1 === i) a.x += s,
            a.x === h && (a.x = 0, a.y += n);
            else if (a.x += s, a.x === h && (a.x = 0, a.y += n, a.y === l)) return ! 0
        }
        return ! 0
    },
    t.Group.prototype.resetCursor = function(t) {
        if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t,
        this.cursor = this.children[this.cursorIndex],
        this.cursor
    },
    t.Group.prototype.next = function() {
        if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++,
        this.cursor = this.children[this.cursorIndex],
        this.cursor
    },
    t.Group.prototype.previous = function() {
        if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--,
        this.cursor = this.children[this.cursorIndex],
        this.cursor
    },
    t.Group.prototype.swap = function(t, e) {
        this.swapChildren(t, e),
        this.updateZ()
    },
    t.Group.prototype.bringToTop = function(t) {
        return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)),
        t
    },
    t.Group.prototype.bringChildToTop = t.Group.prototype.bringToTop, t.Group.prototype.sendToBack = function(t) {
        return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)),
        t
    },
    t.Group.prototype.sendChildToBack = t.Group.prototype.sendToBack, t.Group.prototype.moveUp = function(t) {
        if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
            var e = this.getIndex(t),
            i = this.getAt(e + 1);
            i && this.swap(t, i)
        }
        return t
    },
    t.Group.prototype.moveDown = function(t) {
        if (t.parent === this && this.getIndex(t) > 0) {
            var e = this.getIndex(t),
            i = this.getAt(e - 1);
            i && this.swap(t, i)
        }
        return t
    },
    t.Group.prototype.xy = function(t, e, i) {
        if (t < 0 || t > this.children.length) return - 1;
        this.getChildAt(t).x = e,
        this.getChildAt(t).y = i
    },
    t.Group.prototype.reverse = function() {
        this.children.reverse(),
        this.updateZ()
    },
    t.Group.prototype.getIndex = function(t) {
        return this.children.indexOf(t)
    },
    t.Group.prototype.getByName = function(t) {
        for (var e = 0; e < this.children.length; e++) if (this.children[e].name === t) return this.children[e];
        return null
    },
    t.Group.prototype.replace = function(e, i) {
        var s = this.getIndex(e);
        if ( - 1 !== s) return i.parent && (i.parent instanceof t.Group ? i.parent.remove(i) : i.parent.removeChild(i)),
        this.remove(e),
        this.addAt(i, s),
        e
    },
    t.Group.prototype.hasProperty = function(t, e) {
        var i = e.length;
        return 1 === i && e[0] in t || 2 === i && e[0] in t && e[1] in t[e[0]] || 3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]
    },
    t.Group.prototype.setProperty = function(t, e, i, s, n) {
        if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return ! 1;
        var r = e.length;
        return 1 === r ? 0 === s ? t[e[0]] = i: 1 === s ? t[e[0]] += i: 2 === s ? t[e[0]] -= i: 3 === s ? t[e[0]] *= i: 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i: 1 === s ? t[e[0]][e[1]] += i: 2 === s ? t[e[0]][e[1]] -= i: 3 === s ? t[e[0]][e[1]] *= i: 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i: 1 === s ? t[e[0]][e[1]][e[2]] += i: 2 === s ? t[e[0]][e[1]][e[2]] -= i: 3 === s ? t[e[0]][e[1]][e[2]] *= i: 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i: 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i: 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i: 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i: 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)),
        !0
    },
    t.Group.prototype.checkProperty = function(e, i, s, n) {
        if (void 0 === n && (n = !1), this !== e.parent) return ! 1;
        var r = t.Utils.getProperty(e, i);
        return ! (void 0 === r && n || r !== s)
    },
    t.Group.prototype.set = function(t, e, i, s, n, r, o) {
        if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, o)
    },
    t.Group.prototype.setAll = function(t, e, i, s, n, r) {
        void 0 === i && (i = !1),
        void 0 === s && (s = !1),
        void 0 === r && (r = !1),
        t = t.split("."),
        n = n || 0;
        for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, r)
    },
    t.Group.prototype.setAllChildren = function(e, i, s, n, r, o) {
        void 0 === s && (s = !1),
        void 0 === n && (n = !1),
        void 0 === o && (o = !1),
        r = r || 0;
        for (var a = 0; a < this.children.length; a++)(!s || s && this.children[a].alive) && (!n || n && this.children[a].visible) && (this.children[a] instanceof t.Group ? this.children[a].setAllChildren(e, i, s, n, r, o) : this.setProperty(this.children[a], e.split("."), i, r, o))
    },
    t.Group.prototype.checkAll = function(t, e, i, s, n) {
        void 0 === i && (i = !1),
        void 0 === s && (s = !1),
        void 0 === n && (n = !1);
        for (var r = 0; r < this.children.length; r++) {
            var o = this.children[r];
            if ((!i || i && o.alive) && (!s || s && o.visible) && !this.checkProperty(o, t, e, n)) return ! 1
        }
        return ! 0
    },
    t.Group.prototype.checkAny = function(t, e, i, s) {
        void 0 === i && (i = !1),
        void 0 === s && (s = !1);
        for (var n = 0; n < this.children.length; n++) {
            var r = this.children[n];
            if ((!i || i && r.alive) && (!s || s && r.visible) && this.checkProperty(r, t, e)) return ! 0
        }
        return ! 1
    },
    t.Group.prototype.addAll = function(t, e, i, s) {
        this.setAll(t, e, i, s, 1)
    },
    t.Group.prototype.subAll = function(t, e, i, s) {
        this.setAll(t, e, i, s, 2)
    },
    t.Group.prototype.multiplyAll = function(t, e, i, s) {
        this.setAll(t, e, i, s, 3)
    },
    t.Group.prototype.divideAll = function(t, e, i, s) {
        this.setAll(t, e, i, s, 4)
    },
    t.Group.prototype.kill = function() {
        this.alive = !1,
        this.exists = !1,
        this.visible = !1
    },
    t.Group.prototype.killAll = function() {
        this.callAllExists("kill", !0)
    },
    t.Group.prototype.revive = function() {
        this.alive = !0,
        this.exists = !0,
        this.visible = !0
    },
    t.Group.prototype.reviveAll = function() {
        this.callAllExists("revive", !1)
    },
    t.Group.prototype.resetAll = function(t, e, i, s, n) {
        this.forEach(this.resetChild, this, n, t, e, i, s)
    },
    t.Group.prototype.callAllExists = function(t, e) {
        var i;
        if (arguments.length > 2) for (i = [], s = 2; s < arguments.length; s++) i.push(arguments[s]);
        for (var s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
    },
    t.Group.prototype.callbackFromArray = function(t, e, i) {
        if (1 === i) {
            if (t[e[0]]) return t[e[0]]
        } else if (2 === i) {
            if (t[e[0]][e[1]]) return t[e[0]][e[1]]
        } else if (3 === i) {
            if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
        } else if (4 === i) {
            if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
        } else if (t[e]) return t[e];
        return ! 1
    },
    t.Group.prototype.callAll = function(t, e) {
        if (void 0 !== t) {
            var i, s = (t = t.split(".")).length;
            if (null == e || "" === e) e = null;
            else if ("string" == typeof e) var n = (e = e.split(".")).length;
            if (arguments.length > 2) for (i = [], a = 2; a < arguments.length; a++) i.push(arguments[a]);
            for (var r = null,
            o = null,
            a = 0; a < this.children.length; a++) r = this.callbackFromArray(this.children[a], t, s),
            e && r ? (o = this.callbackFromArray(this.children[a], e, n), r && r.apply(o, i)) : r && r.apply(this.children[a], i)
        }
    },
    t.Group.prototype.preUpdate = function() {
        if (this.pendingDestroy) return this.destroy(),
        !1;
        if (!this.exists || !this.parent.exists) return this.renderOrderID = -1,
        !1;
        for (var t = 0; t < this.children.length;) {
            var e = this.children[t];
            e.preUpdate(),
            this === e.parent && t++
        }
        return ! 0
    },
    t.Group.prototype.update = function() {
        for (var t = this.children.length; t--;) {
            var e = this.children.length;
            t >= e && (t = e - 1);
            var i = this.children[t];
            this.updateOnlyExistingChildren && !i.exists || i.update()
        }
    },
    t.Group.prototype.postUpdate = function() {
        this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
    },
    t.Group.prototype.filter = function(e, i) {
        for (var s = -1,
        n = this.children.length,
        r = []; ++s < n;) {
            var o = this.children[s]; (!i || i && o.exists) && e(o, s, this.children) && r.push(o)
        }
        return new t.ArraySet(r)
    },
    t.Group.prototype.forEach = function(t, e, i) {
        if (void 0 === i && (i = !1), arguments.length <= 3) for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && t.call(e, this.children[n]);
        else {
            for (var s = [null], n = 3; n < arguments.length; n++) s.push(arguments[n]);
            for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && (s[0] = this.children[n], t.apply(e, s))
        }
    },
    t.Group.prototype.forEachExists = function(e, i) {
        var s;
        if (arguments.length > 2) {
            s = [null];
            for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
        }
        this.iterate("exists", !0, t.Group.RETURN_TOTAL, e, i, s)
    },
    t.Group.prototype.forEachAlive = function(e, i) {
        var s;
        if (arguments.length > 2) {
            s = [null];
            for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
        }
        this.iterate("alive", !0, t.Group.RETURN_TOTAL, e, i, s)
    },
    t.Group.prototype.forEachDead = function(e, i) {
        var s;
        if (arguments.length > 2) {
            s = [null];
            for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
        }
        this.iterate("alive", !1, t.Group.RETURN_TOTAL, e, i, s)
    },
    t.Group.prototype.sort = function(e, i) {
        this.children.length < 2 || (void 0 === e && (e = "z"), void 0 === i && (i = t.Group.SORT_ASCENDING), this._sortProperty = e, i === t.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
    },
    t.Group.prototype.customSort = function(t, e) {
        this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
    },
    t.Group.prototype.ascendingSortHandler = function(t, e) {
        return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
    },
    t.Group.prototype.descendingSortHandler = function(t, e) {
        return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
    },
    t.Group.prototype.iterate = function(e, i, s, n, r, o) {
        if (0 === this.children.length) {
            if (s === t.Group.RETURN_TOTAL) return 0;
            if (s === t.Group.RETURN_ALL) return []
        }
        var a = 0;
        if (s === t.Group.RETURN_ALL) var h = [];
        for (var l = 0; l < this.children.length; l++) if (this.children[l][e] === i) {
            if (a++, n && (o ? (o[0] = this.children[l], n.apply(r, o)) : n.call(r, this.children[l])), s === t.Group.RETURN_CHILD) return this.children[l];
            s === t.Group.RETURN_ALL && h.push(this.children[l])
        }
        return s === t.Group.RETURN_TOTAL ? a: s === t.Group.RETURN_ALL ? h: null
    },
    t.Group.prototype.getFirst = function(e, i) {
        return this.iterate(e, i, t.Group.RETURN_CHILD)
    },
    t.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
        void 0 === e && (e = !1),
        "boolean" != typeof t && (t = !0);
        var o = this.getFirst("exists", t);
        return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
    },
    t.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
        void 0 === t && (t = !1);
        var r = this.getFirst("alive", !0);
        return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
    },
    t.Group.prototype.getFirstDead = function(t, e, i, s, n) {
        void 0 === t && (t = !1);
        var r = this.getFirst("alive", !1);
        return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
    },
    t.Group.prototype.resetChild = function(t, e, i, s, n) {
        return null === t ? null: (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
    },
    t.Group.prototype.getTop = function() {
        if (this.children.length > 0) return this.children[this.children.length - 1]
    },
    t.Group.prototype.getBottom = function() {
        if (this.children.length > 0) return this.children[0]
    },
    t.Group.prototype.getClosestTo = function(e, i, s) {
        for (var n = Number.MAX_VALUE,
        r = 0,
        o = null,
        a = 0; a < this.children.length; a++) {
            var h = this.children[a];
            h.exists && (r = Math.abs(t.Point.distance(e, h))) < n && (!i || i.call(s, h, r)) && (n = r, o = h)
        }
        return o
    },
    t.Group.prototype.getFurthestFrom = function(e, i, s) {
        for (var n = 0,
        r = 0,
        o = null,
        a = 0; a < this.children.length; a++) {
            var h = this.children[a];
            h.exists && (r = Math.abs(t.Point.distance(e, h))) > n && (!i || i.call(s, h, r)) && (n = r, o = h)
        }
        return o
    },
    t.Group.prototype.count = function(e, i) {
        return this.iterate(e, i, t.Group.RETURN_TOTAL)
    },
    t.Group.prototype.countLiving = function() {
        return this.count("alive", !0)
    },
    t.Group.prototype.countDead = function() {
        return this.count("alive", !1)
    },
    t.Group.prototype.getRandom = function(e, i) {
        return void 0 === e && (e = 0),
        void 0 === i && (i = this.children.length),
        0 === i ? null: t.ArrayUtils.getRandomItem(this.children, e, i)
    },
    t.Group.prototype.getRandomExists = function(t, e) {
        var i = this.getAll("exists", !0, t, e);
        return this.game.rnd.pick(i)
    },
    t.Group.prototype.getAll = function(t, e, i, s) {
        void 0 === i && (i = 0),
        void 0 === s && (s = this.children.length);
        for (var n = [], r = i; r < s; r++) {
            var o = this.children[r];
            t ? o[t] === e && n.push(o) : n.push(o)
        }
        return n
    },
    t.Group.prototype.remove = function(t, e, i) {
        if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return ! 1;
        i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
        var s = this.removeChild(t);
        return this.removeFromHash(t),
        this.updateZ(),
        this.cursor === t && this.next(),
        e && s && s.destroy(!0),
        !0
    },
    t.Group.prototype.moveAll = function(e, i) {
        if (void 0 === i && (i = !1), this.children.length > 0 && e instanceof t.Group) {
            do {
                e.add(this.children[0], i)
            } while ( this . children . length > 0 );
            this.hash = [],
            this.cursor = null
        }
        return e
    },
    t.Group.prototype.removeAll = function(t, e, i) {
        if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
            do { ! e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                var s = this.removeChild(this.children[0]);
                this.removeFromHash(s), t && s && s.destroy(!0, i)
            } while ( this . children . length > 0 );
            this.hash = [],
            this.cursor = null
        }
    },
    t.Group.prototype.removeBetween = function(t, e, i, s) {
        if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
            if (t > e || t < 0 || e > this.children.length) return ! 1;
            for (var n = e; n >= t;) { ! s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                var r = this.removeChild(this.children[n]);
                this.removeFromHash(r),
                i && r && r.destroy(!0),
                this.cursor === this.children[n] && (this.cursor = null),
                n--
            }
            this.updateZ()
        }
    },
    t.Group.prototype.scatter = function(t, e) {
        null == t && (t = this.game.world.bounds),
        this.forEach(function(e) {
            e.position.set(t.randomX, t.randomY)
        },
        null, e)
    },
    t.Group.prototype.shuffle = function() {
        t.ArrayUtils.shuffle(this.children),
        this.updateZ()
    },
    t.Group.prototype.destroy = function(t, e) {
        null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
    },
    Object.defineProperty(t.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", !0, t.Group.RETURN_TOTAL)
        }
    }), Object.defineProperty(t.Group.prototype, "length", {
        get: function() {
            return this.children.length
        }
    }), Object.defineProperty(t.Group.prototype, "angle", {
        get: function() {
            return t.Math.radToDeg(this.rotation)
        },
        set: function(e) {
            this.rotation = t.Math.degToRad(e)
        }
    }), Object.defineProperty(t.Group.prototype, "centerX", {
        get: function() {
            return this.getBounds(this.parent).centerX
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.x - e.x;
            this.x = t + i - e.halfWidth
        }
    }), Object.defineProperty(t.Group.prototype, "centerY", {
        get: function() {
            return this.getBounds(this.parent).centerY
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.y - e.y;
            this.y = t + i - e.halfHeight
        }
    }), Object.defineProperty(t.Group.prototype, "left", {
        get: function() {
            return this.getBounds(this.parent).left
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.x - e.x;
            this.x = t + i
        }
    }), Object.defineProperty(t.Group.prototype, "right", {
        get: function() {
            return this.getBounds(this.parent).right
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.x - e.x;
            this.x = t + i - e.width
        }
    }), Object.defineProperty(t.Group.prototype, "top", {
        get: function() {
            return this.getBounds(this.parent).top
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.y - e.y;
            this.y = t + i
        }
    }), Object.defineProperty(t.Group.prototype, "bottom", {
        get: function() {
            return this.getBounds(this.parent).bottom
        },
        set: function(t) {
            var e = this.getBounds(this.parent),
            i = this.y - e.y;
            this.y = t + i - e.height
        }
    }), t.World = function(e) {
        t.Group.call(this, e, null, "__world", !1),
        this.bounds = new t.Rectangle(0, 0, e.width, e.height),
        this.camera = null,
        this._definedSize = !1,
        this._width = e.width,
        this._height = e.height,
        this.game.state.onStateChange.add(this.stateChange, this)
    },
    t.World.prototype = Object.create(t.Group.prototype), t.World.prototype.constructor = t.World, t.World.prototype.boot = function() {
        this.camera = new t.Camera(this.game, 0, 0, 0, this.game.width, this.game.height),
        this.game.stage.addChild(this),
        this.camera.boot()
    },
    t.World.prototype.stateChange = function() {
        this.x = 0,
        this.y = 0,
        this.camera.reset()
    },
    t.World.prototype.setBounds = function(t, e, i, s) {
        this._definedSize = !0,
        this._width = i,
        this._height = s,
        this.bounds.setTo(t, e, i, s),
        this.x = t,
        this.y = e,
        this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)),
        this.game.physics.setBoundsToWorld()
    },
    t.World.prototype.resize = function(t, e) {
        this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)),
        this.bounds.width = t,
        this.bounds.height = e,
        this.game.camera.setBoundsToWorld(),
        this.game.physics.setBoundsToWorld()
    },
    t.World.prototype.shutdown = function() {
        this.destroy(!0, !0)
    },
    t.World.prototype.wrap = function(t, e, i, s, n) {
        void 0 === e && (e = 0),
        void 0 === i && (i = !1),
        void 0 === s && (s = !0),
        void 0 === n && (n = !0),
        i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right: t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom: t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e: s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e: n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
    },
    t.World.prototype.wrapAll = function(t, e, i, s, n, r) {
        t.forEach(this.wrap, this, e, i, s, n, r)
    },
    Object.defineProperty(t.World.prototype, "width", {
        get: function() {
            return this.bounds.width
        },
        set: function(t) {
            t < this.game.width && (t = this.game.width),
            this.bounds.width = t,
            this._width = t,
            this._definedSize = !0
        }
    }), Object.defineProperty(t.World.prototype, "height", {
        get: function() {
            return this.bounds.height
        },
        set: function(t) {
            t < this.game.height && (t = this.game.height),
            this.bounds.height = t,
            this._height = t,
            this._definedSize = !0
        }
    }), Object.defineProperty(t.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth + this.bounds.x
        }
    }), Object.defineProperty(t.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight + this.bounds.y
        }
    }), Object.defineProperty(t.World.prototype, "randomX", {
        get: function() {
            return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
        }
    }), Object.defineProperty(t.World.prototype, "randomY", {
        get: function() {
            return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
        }
    }), t.Game = function(e, i, s, n, r, o, a, h) {
        return this.id = t.GAMES.push(this) - 1,
        this.config = null,
        this.physicsConfig = h,
        this.parent = "",
        this.width = 800,
        this.height = 600,
        this.resolution = 1,
        this._width = 800,
        this._height = 600,
        this.transparent = !1,
        this.antialias = !0,
        this.multiTexture = !1,
        this.preserveDrawingBuffer = !1,
        this.clearBeforeRender = !0,
        this.renderer = null,
        this.renderType = t.AUTO,
        this.state = null,
        this.isBooted = !1,
        this.isRunning = !1,
        this.raf = null,
        this.add = null,
        this.make = null,
        this.cache = null,
        this.input = null,
        this.load = null,
        this.math = null,
        this.net = null,
        this.scale = null,
        this.sound = null,
        this.stage = null,
        this.time = null,
        this.tweens = null,
        this.world = null,
        this.physics = null,
        this.plugins = null,
        this.rnd = null,
        this.device = t.Device,
        this.camera = null,
        this.canvas = null,
        this.context = null,
        this.debug = null,
        this.particles = null,
        this.create = null,
        this.lockRender = !1,
        this.pendingDestroy = !1,
        this.stepping = !1,
        this.pendingStep = !1,
        this.stepCount = 0,
        this.onPause = null,
        this.onResume = null,
        this.onBlur = null,
        this.onFocus = null,
        this._paused = !1,
        this._codePaused = !1,
        this.currentUpdateID = 0,
        this.updatesThisFrame = 1,
        this.rendersThisFrame = 1,
        this._deltaTime = 0,
        this._lastCount = 0,
        this._spiraling = 0,
        this._kickstart = !0,
        this.fpsProblemNotifier = new t.Signal,
        this.forceSingleUpdate = !0,
        this.forceSingleRender = !0,
        this.dropFrames = !1,
        this._nextFpsNotification = 0,
        1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
            enableDebug: !0
        },
        void 0 !== e && (this._width = e), void 0 !== i && (this._height = i), void 0 !== s && (this.renderType = s), void 0 !== n && (this.parent = n), void 0 !== o && (this.transparent = o), void 0 !== a && (this.antialias = a), this.rnd = new t.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new t.StateManager(this, r)),
        this.device.whenReady(this.boot, this),
        this
    },
    t.Game.prototype = {
        parseConfig: function(e) {
            this.config = e,
            void 0 === e.enableDebug && (this.config.enableDebug = !0),
            e.width && (this._width = e.width),
            e.height && (this._height = e.height),
            e.renderer && (this.renderType = e.renderer),
            e.parent && (this.parent = e.parent),
            void 0 !== e.transparent && (this.transparent = e.transparent),
            void 0 !== e.antialias && (this.antialias = e.antialias),
            void 0 !== e.clearBeforeRender && (this.clearBeforeRender = e.clearBeforeRender),
            void 0 !== e.multiTexture && (this.multiTexture = e.multiTexture),
            e.resolution && (this.resolution = e.resolution),
            void 0 !== e.preserveDrawingBuffer && (this.preserveDrawingBuffer = e.preserveDrawingBuffer),
            e.physicsConfig && (this.physicsConfig = e.physicsConfig);
            var i = [(Date.now() * Math.random()).toString()];
            e.seed && (i = e.seed),
            this.rnd = new t.RandomDataGenerator(i);
            var s = null;
            e.state && (s = e.state),
            this.state = new t.StateManager(this, s)
        },
        boot: function() {
            if (!this.isBooted) {
                if (this.onPause = new t.Signal, this.onResume = new t.Signal, this.onBlur = new t.Signal, this.onFocus = new t.Signal, this.isBooted = !0, PIXI.game = this, this.math = t.Math, this.scale = new t.ScaleManager(this, this._width, this._height), this.stage = new t.Stage(this), this.setUpRenderer(), this.world = new t.World(this), this.add = new t.GameObjectFactory(this), this.make = new t.GameObjectCreator(this), this.cache = new t.Cache(this), this.load = new t.Loader(this), this.time = new t.Time(this), this.tweens = new t.TweenManager(this), this.input = new t.Input(this), this.sound = new t.SoundManager(this), this.physics = new t.Physics(this, this.physicsConfig), this.particles = new t.Particles(this), this.create = new t.Create(this), this.plugins = new t.PluginManager(this), this.net = new t.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(this.config), this.sound.boot(), this.state.boot(), this.config.enableDebug) this.debug = new t.Utils.Debug(this),
                this.debug.boot();
                else {
                    var e = function() {};
                    this.debug = {
                        preUpdate: e,
                        update: e,
                        reset: e,
                        destroy: e,
                        isDisabled: !0
                    }
                }
                this.showDebugHeader(),
                this.isRunning = !0,
                this.config && this.config.forceSetTimeOut ? this.raf = new t.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new t.RequestAnimationFrame(this, !1),
                this._kickstart = !0,
                this.focusWindow(),
                this.config.disableStart || (this.cache.isReady ? this.raf.start() : this.cache.onReady.addOnce(function() {
                    this.raf.start()
                },
                this))
            }
        },
        showDebugHeader: function() {
            if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                var e = t.VERSION,
                i = "Canvas",
                s = "HTML Audio",
                n = 1;
                if (this.renderType === t.WEBGL ? (i = "WebGL", n++) : this.renderType === t.HEADLESS && (i = "Headless"), this.device.webAudio && (s = "WebAudio", n++), this.device.ie) window.console && console.log("Phaser v" + e + " | Pixi.js | " + i + " | " + s + " | http://phaser.io");
                else {
                    for (var r = ["%c %c %c Phaser CE v" + e + " | Pixi.js | " + i + " | " + s + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], o = 0; o < 3; o++) o < n ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                    console.log.apply(console, r)
                }
            }
        },
        setUpRenderer: function() {
            if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas 2d context, aborting.");
            if (this.config.canvas ? this.canvas = this.config.canvas: this.canvas = t.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle: this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.config.crisp && t.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === t.WEBGL || this.renderType === t.WEBGL_MULTI || this.renderType === t.AUTO && this.device.webGL) { (this.multiTexture || this.renderType === t.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0);
                try {
                    this.renderer = new PIXI.WebGLRenderer(this, this.config),
                    this.renderType = t.WEBGL,
                    this.context = null,
                    this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1),
                    this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1)
                } catch(e) {
                    if (PIXI.defaultRenderer = null, this.renderer = null, this.multiTexture = !1, PIXI._enableMultiTextureToggle = !1, this.renderType === t.WEBGL) throw e
                }
            }
            this.renderer || (this.renderer = new PIXI.CanvasRenderer(this, this.config), this.context = this.renderer.context, this.renderType === t.AUTO && (this.renderType = t.CANVAS)),
            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === t.CANVAS),
            this.renderType !== t.HEADLESS && (this.stage.smoothed = this.antialias, t.Canvas.addToDOM(this.canvas, this.parent, !1), t.Canvas.setTouchAction(this.canvas))
        },
        contextLost: function(t) {
            t.preventDefault(),
            this.renderer.contextLost = !0
        },
        contextRestored: function() {
            this.renderer.initContext(),
            this.cache.clearGLTextures(),
            this.renderer.contextLost = !1
        },
        update: function(t) {
            if (this.pendingDestroy) this.destroy();
            else {
                if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult),
                this.updateRender(this.time.slowMotion * this.time.desiredFps),
                void(this._kickstart = !1);
                if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()),
                this._deltaTime = 0,
                this._spiraling = 0,
                this.dropFrames ? this.rendersThisFrame = 0 : (this.updateRender(this.time.slowMotion * this.time.desiredFps), this.rendersThisFrame = 1);
                else {
                    var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                    var i = 0;
                    for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)), this.forceSingleRender ? this.rendersThisFrame = 1 : this.rendersThisFrame = Math.min(1, this.updatesThisFrame); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                    i > this._lastCount ? this._spiraling++:i < this._lastCount && (this._spiraling = 0),
                    this._lastCount = i,
                    this.rendersThisFrame > 0 && this.updateRender(this._deltaTime / e)
                }
            }
        },
        updateLogic: function(t) {
            this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(t), this.debug.preUpdate(), this.input.pauseUpdate()) : (this.stepping && (this.pendingStep = !0), this.time.countUpdate(), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.state.postUpdate(), this.plugins.postUpdate()),
            this.stage.updateTransform()
        },
        updateRender: function(e) {
            this.lockRender || this.renderType === t.HEADLESS || (this.time.countRender(), this.state.preRender(e), this.renderer.render(this.stage), this.plugins.render(e), this.state.render(e), this.plugins.postRender(e))
        },
        enableStep: function() {
            this.stepping = !0,
            this.pendingStep = !1,
            this.stepCount = 0
        },
        disableStep: function() {
            this.stepping = !1,
            this.pendingStep = !1
        },
        step: function() {
            this.pendingStep = !1,
            this.stepCount++
        },
        destroy: function() {
            this.raf.stop(),
            this.debug.destroy(),
            this.state.destroy(),
            this.sound.destroy(),
            this.scale.destroy(),
            this.stage.destroy(),
            this.input.destroy(),
            this.physics.destroy(),
            this.plugins.destroy(),
            this.tweens.destroy(),
            this.debug = null,
            this.state = null,
            this.sound = null,
            this.scale = null,
            this.stage = null,
            this.input = null,
            this.physics = null,
            this.plugins = null,
            this.tweens = null,
            this.cache = null,
            this.load = null,
            this.time = null,
            this.world = null,
            this.isBooted = !1,
            this.renderer.destroy(!1),
            t.Canvas.removeFromDOM(this.canvas),
            PIXI.game === this && (PIXI.game = null),
            PIXI.defaultRenderer = null,
            t.GAMES[this.id] = null
        },
        gamePaused: function(t) {
            this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
        },
        gameResumed: function(t) {
            this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
        },
        focusLoss: function(t) {
            this.onBlur.dispatch(t),
            this.stage.disableVisibilityChange || this.gamePaused(t)
        },
        focusGain: function(t) {
            this.focusWindow(),
            this.onFocus.dispatch(t),
            this.stage.disableVisibilityChange || this.gameResumed(t)
        },
        focusWindow: function() {
            window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus()
        }
    },
    t.Game.prototype.constructor = t.Game, Object.defineProperty(t.Game.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(t) { ! 0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.muteOnPause && this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
        }
    }), t.Input = function(e) {
        this.game = e,
        this.hitCanvas = null,
        this.hitContext = null,
        this.moveCallbacks = [],
        this.customCandidateHandler = null,
        this.customCandidateHandlerContext = null,
        this.pollRate = 0,
        this.enabled = !0,
        this.multiInputOverride = t.Input.MOUSE_TOUCH_COMBINE,
        this.position = null,
        this.speed = null,
        this.circle = null,
        this.scale = null,
        this.maxPointers = -1,
        this.tapRate = 200,
        this.doubleTapRate = 300,
        this.holdRate = 2e3,
        this.justPressedRate = 200,
        this.justReleasedRate = 200,
        this.recordPointerHistory = !1,
        this.recordRate = 100,
        this.recordLimit = 100,
        this.touchLockCallbacks = [],
        this.pointer1 = null,
        this.pointer2 = null,
        this.pointer3 = null,
        this.pointer4 = null,
        this.pointer5 = null,
        this.pointer6 = null,
        this.pointer7 = null,
        this.pointer8 = null,
        this.pointer9 = null,
        this.pointer10 = null,
        this.pointers = [],
        this.activePointer = null,
        this.mousePointer = null,
        this.mouse = null,
        this.keyboard = null,
        this.touch = null,
        this.mspointer = null,
        this.gamepad = null,
        this.resetLocked = !1,
        this.onDown = null,
        this.onUp = null,
        this.onTap = null,
        this.onHold = null,
        this.minPriorityID = 0,
        this.interactiveItems = new t.ArraySet,
        this._localPoint = new t.Point,
        this._pollCounter = 0,
        this._oldPosition = null,
        this._x = 0,
        this._y = 0
    },
    t.Input.MOUSE_OVERRIDES_TOUCH = 0, t.Input.TOUCH_OVERRIDES_MOUSE = 1, t.Input.MOUSE_TOUCH_COMBINE = 2, t.Input.MAX_POINTERS = 10, t.Input.prototype = {
        boot: function(e) {
            "maxPointers" in e && (this.maxPointers = e.maxPointers),
            this.mousePointer = new t.Pointer(this.game, 0, t.PointerMode.CURSOR),
            this.addPointer(),
            this.addPointer(),
            this.mouse = new t.Mouse(this.game),
            this.touch = new t.Touch(this.game),
            this.mspointer = new t.MSPointer(this.game),
            this.mouseWheel = new t.MouseWheel(this.game),
            this.pointerLock = new t.PointerLock(this.game),
            t.Keyboard && (this.keyboard = new t.Keyboard(this.game)),
            t.Gamepad && (this.gamepad = new t.Gamepad(this.game)),
            this.onDown = new t.Signal,
            this.onUp = new t.Signal,
            this.onTap = new t.Signal,
            this.onHold = new t.Signal,
            this.scale = new t.Point(1, 1),
            this.speed = new t.Point,
            this.position = new t.Point,
            this._oldPosition = new t.Point,
            this.circle = new t.Circle(0, 0, 45),
            this.activePointer = this.mousePointer,
            this.hitCanvas = t.CanvasPool.create(this, 1, 1),
            this.hitContext = this.hitCanvas.getContext("2d"),
            this.game.device.mspointer && !1 !== e.mspointer ? this.mspointer.start() : this.game.device.touch && !1 !== e.touch && this.touch.start(),
            this.mspointer.active || !1 === e.mouse || this.mouse.start(),
            this.mousePointer.active = !0,
            !1 !== e.mouseWheel && this.mouseWheel.start(),
            !1 !== e.pointerLock && this.pointerLock.start(),
            this.keyboard && !1 !== e.keyboard && this.keyboard.start();
            var i = this;
            this._onClickTrampoline = function(t) {
                i.onClickTrampoline(t)
            },
            this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
        },
        destroy: function() {
            this.mouse.stop(),
            this.mouseWheel.stop(),
            this.touch.stop(),
            this.mspointer.stop(),
            this.pointerLock.stop(),
            this.keyboard && this.keyboard.stop(),
            this.gamepad && this.gamepad.stop(),
            this.moveCallbacks = [],
            t.CanvasPool.remove(this),
            this.game.canvas.removeEventListener("click", this._onClickTrampoline)
        },
        setInteractiveCandidateHandler: function(t, e) {
            this.customCandidateHandler = t,
            this.customCandidateHandlerContext = e
        },
        addMoveCallback: function(t, e) {
            this.moveCallbacks.push({
                callback: t,
                context: e
            })
        },
        addTouchLockCallback: function(t, e, i) {
            void 0 === i && (i = !1),
            this.touchLockCallbacks.push({
                callback: t,
                context: e,
                onEnd: i
            })
        },
        removeTouchLockCallback: function(t, e) {
            for (var i = this.touchLockCallbacks.length; i--;) if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1),
            !0;
            return ! 1
        },
        executeTouchLockCallbacks: function(t, e) {
            for (var i = this.touchLockCallbacks.length; i--;) {
                var s = this.touchLockCallbacks[i];
                s.onEnd === t && s.callback.call(s.context, this, e) && this.touchLockCallbacks.splice(i, 1)
            }
        },
        deleteMoveCallback: function(t, e) {
            for (var i = this.moveCallbacks.length; i--;) if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
        },
        addPointer: function() {
            if (this.pointers.length >= t.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + t.Input.MAX_POINTERS + " pointers reached."),
            null;
            var e = this.pointers.length + 1,
            i = new t.Pointer(this.game, e, t.PointerMode.CONTACT);
            return this.pointers.push(i),
            this["pointer" + e] = i,
            i
        },
        update: function() {
            if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
            else {
                this.speed.x = this.position.x - this._oldPosition.x,
                this.speed.y = this.position.y - this._oldPosition.y,
                this._oldPosition.copyFrom(this.position),
                this.mousePointer.update(),
                this.gamepad && this.gamepad.active && this.gamepad.update();
                for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                this._pollCounter = 0
            }
        },
        pauseUpdate: function() {
            this.gamepad && this.gamepad.active && this.gamepad.update()
        },
        reset: function(e) {
            if (this.game.isBooted && !this.resetLocked) {
                void 0 === e && (e = !1),
                this.mousePointer.reset(),
                this.keyboard && this.keyboard.reset(e);
                for (var i = 0; i < this.pointers.length; i++) this.pointers[i].reset();
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""),
                e && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new t.Signal, this.onUp = new t.Signal, this.onTap = new t.Signal, this.onHold = new t.Signal, this.moveCallbacks = []),
                this._pollCounter = 0
            }
        },
        resetSpeed: function(t, e) {
            this._oldPosition.setTo(t, e),
            this.speed.setTo(0, 0)
        },
        startPointer: function(t) {
            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
            if (!this.pointer1.active) return this.pointer1.start(t);
            if (!this.pointer2.active) return this.pointer2.start(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (!i.active) return i.start(t)
            }
            return null
        },
        updatePointer: function(t) {
            if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
            if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active && i.identifier === t.identifier) return i.move(t)
            }
            return null
        },
        stopPointer: function(t) {
            if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
            if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
            for (var e = 2; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active && i.identifier === t.identifier) return i.stop(t)
            }
            return null
        },
        countActivePointers: function(t) {
            void 0 === t && (t = this.pointers.length);
            for (var e = t,
            i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--;
            return t - e
        },
        getPointer: function(t) {
            void 0 === t && (t = !1);
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.active === t) return i
            }
            return null
        },
        getPointerFromIdentifier: function(t) {
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.identifier === t) return i
            }
            return null
        },
        getPointerFromId: function(t) {
            for (var e = 0; e < this.pointers.length; e++) {
                var i = this.pointers[e];
                if (i.pointerId === t) return i
            }
            return null
        },
        getLocalPosition: function(e, i, s) {
            void 0 === s && (s = new t.Point);
            var n = e.worldTransform,
            r = 1 / (n.a * n.d + n.c * -n.b);
            return s.setTo(n.d * r * i.x + -n.c * r * i.y + (n.ty * n.c - n.tx * n.d) * r, n.a * r * i.y + -n.b * r * i.x + ( - n.ty * n.a + n.tx * n.b) * r)
        },
        hitTest: function(e, i, s) {
            if (!e.worldVisible) return ! 1;
            if (this.getLocalPosition(e, i, this._localPoint), s.copyFrom(this._localPoint), e.hitArea && e.hitArea.contains) return e.hitArea.contains(this._localPoint.x, this._localPoint.y);
            if (t.Creature && e instanceof t.Creature) {
                var n = Math.abs(e.width),
                r = Math.abs(e.height),
                o = e.x - n * e.anchorX;
                if (this.game.camera.x + i.x >= o && this.game.camera.x + i.x < o + n && (a = e.y - r * e.anchorY, this.game.camera.y + i.y >= a && this.game.camera.y + i.y < a + r)) return ! 0
            } else if (e instanceof t.TileSprite) {
                n = e.width,
                r = e.height,
                o = -n * e.anchor.x;
                if (this._localPoint.x >= o && this._localPoint.x < o + n && (a = -r * e.anchor.y, this._localPoint.y >= a && this._localPoint.y < a + r)) return ! 0
            } else if (e instanceof PIXI.Sprite) {
                n = e.texture.frame.width / e.texture.baseTexture.resolution,
                r = e.texture.frame.height / e.texture.baseTexture.resolution,
                o = -n * e.anchor.x;
                if (this._localPoint.x >= o && this._localPoint.x < o + n) {
                    var a = -r * e.anchor.y;
                    if (this._localPoint.y >= a && this._localPoint.y < a + r) return ! 0
                }
            } else if (e instanceof t.Graphics) for (l = 0; l < e.graphicsData.length; l++) {
                var h = e.graphicsData[l];
                if (h.fill && h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y)) return ! 0
            }
            for (var l = 0; l < e.children.length; l++) if (this.hitTest(e.children[l], i, s)) return ! 0;
            return ! 1
        },
        onClickTrampoline: function() {
            this.activePointer.processClickTrampolines()
        }
    },
    t.Input.prototype.constructor = t.Input, Object.defineProperty(t.Input.prototype, "x", {
        get: function() {
            return this._x
        },
        set: function(t) {
            this._x = Math.floor(t)
        }
    }), Object.defineProperty(t.Input.prototype, "y", {
        get: function() {
            return this._y
        },
        set: function(t) {
            this._y = Math.floor(t)
        }
    }), Object.defineProperty(t.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate
        }
    }), Object.defineProperty(t.Input.prototype, "totalInactivePointers", {
        get: function() {
            return this.pointers.length - this.countActivePointers()
        }
    }), Object.defineProperty(t.Input.prototype, "totalActivePointers", {
        get: function() {
            return this.countActivePointers()
        }
    }), Object.defineProperty(t.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x
        }
    }), Object.defineProperty(t.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y
        }
    }), t.Mouse = function(t) {
        this.game = t,
        this.input = t.input,
        this.callbackContext = this.game,
        this.mouseDownCallback = null,
        this.mouseUpCallback = null,
        this.mouseOutCallback = null,
        this.mouseOverCallback = null,
        this.capture = !1,
        this.active = !1,
        this.enabled = !0,
        this.stopOnGameOut = !1,
        this.event = null,
        this._onMouseDown = null,
        this._onMouseMove = null,
        this._onMouseUp = null,
        this._onMouseOut = null,
        this._onMouseOver = null
    },
    t.Mouse.NO_BUTTON = -1, t.Mouse.LEFT_BUTTON = 0, t.Mouse.MIDDLE_BUTTON = 1, t.Mouse.RIGHT_BUTTON = 2, t.Mouse.BACK_BUTTON = 3, t.Mouse.FORWARD_BUTTON = 4, t.Mouse.WHEEL_UP = 1, t.Mouse.WHEEL_DOWN = -1, t.Mouse.prototype = {
        start: function() {
            var t = this.game.device;
            if (t.isAndroidStockBrowser() && this.input.touch.active) return ! 1;
            if (null !== this._onMouseDown) return ! 1;
            var e = this;
            this._onMouseDown = function(t) {
                return e.onMouseDown(t)
            },
            this._onMouseMove = function(t) {
                return e.onMouseMove(t)
            },
            this._onMouseUp = function(t) {
                return e.onMouseUp(t)
            },
            this._onMouseUpGlobal = function(t) {
                return e.onMouseUpGlobal(t)
            },
            this._onMouseOutGlobal = function(t) {
                return e.onMouseOutGlobal(t)
            },
            this._onMouseOut = function(t) {
                return e.onMouseOut(t)
            },
            this._onMouseOver = function(t) {
                return e.onMouseOver(t)
            };
            var i = this.game.canvas;
            return i.addEventListener("mousedown", this._onMouseDown, !0),
            i.addEventListener("mousemove", this._onMouseMove, !0),
            i.addEventListener("mouseup", this._onMouseUp, !0),
            t.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0)),
            this.active = !0,
            !0
        },
        onMouseDown: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
        },
        onMouseMove: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
        },
        onMouseUp: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
        },
        onMouseUpGlobal: function(t) {
            this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
        },
        onMouseOutGlobal: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.input.mousePointer.withinGame = !1,
            this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.resetButtons())
        },
        onMouseOut: function(t) {
            if (this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled) {
                this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t));
                for (var e = this.input.interactiveItems.list,
                i = e.length; i--;) {
                    var s = e[i];
                    s.enabled && s._pointerOutHandler(this.input.mousePointer)
                }
            }
        },
        onMouseOver: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.input.mousePointer.withinGame = !0,
            this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
        },
        releasePointerLock: function() {
            return console.warn("Deprecated. Please use `input.pointerLock.exit()` instead."),
            this.input.pointerLock.exit()
        },
        requestPointerLock: function() {
            return console.warn("Deprecated. Please use `input.pointerLock.request()` instead."),
            this.input.pointerLock.request()
        },
        stop: function() {
            var t = this.game.canvas;
            t.removeEventListener("mousedown", this._onMouseDown, !0),
            t.removeEventListener("mousemove", this._onMouseMove, !0),
            t.removeEventListener("mouseup", this._onMouseUp, !0),
            t.removeEventListener("mouseover", this._onMouseOver, !0),
            t.removeEventListener("mouseout", this._onMouseOut, !0),
            window.removeEventListener("mouseup", this._onMouseUpGlobal, !0),
            window.removeEventListener("mouseout", this._onMouseOutGlobal, !0),
            this.active = !1
        }
    },
    t.Mouse.prototype.constructor = t.Mouse, Object.defineProperty(t.Mouse.prototype, "locked", {
        get: function() {
            return this.input.pointerLock.locked
        }
    }), Object.defineProperty(t.Mouse.prototype, "pointerLock", {
        get: function() {
            return this.input.pointerLock.onChange
        }
    }), Object.defineProperty(t.Mouse.prototype, "mouseWheelCallback", {
        get: function() {
            return this.input.mouseWheel.callback
        },
        set: function(t) {
            this.input.mouseWheel.callback = t
        }
    }), Object.defineProperty(t.Mouse.prototype, "wheelDelta", {
        get: function() {
            return this.input.mouseWheel.delta
        }
    }), t.MouseWheel = function(t) {
        this.game = t,
        this.input = t.input,
        this.element = t.canvas,
        this.preventDefault = !0,
        this.active = !1,
        this.callback = null,
        this.callbackContext = t,
        this.delta = 0,
        this.wheelEventName = t.device.wheelEvent,
        this.boundOnWheelHandler = this.onWheelHandler.bind(this),
        this.eventProxy = null
    },
    t.MouseWheel.UP = 1, t.MouseWheel.DOWN = -1, t.MouseWheel.prototype.start = function() {
        return ! (!this.wheelEventName || this.active || (this.element.addEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), "mousewheel" === this.wheelEventName ? this.eventProxy = new t.WheelEventProxy( - .025, 1) : "DOMMouseScroll" === this.wheelEventName && (this.eventProxy = new t.WheelEventProxy(1, 1)), this.active = !0, 0))
    },
    t.MouseWheel.prototype.stop = function() {
        this.active && (this.element.removeEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), this.active = !1)
    },
    t.MouseWheel.prototype.onWheelHandler = function(e) {
        this.eventProxy && (e = this.eventProxy.bindEvent(e)),
        this.preventDefault && e.preventDefault(),
        this.delta = t.Math.clamp( - e.deltaY, -1, 1),
        this.callback && this.callback.call(this.callbackContext, e)
    },
    t.MSPointer = function(t) {
        this.game = t,
        this.input = t.input,
        this.callbackContext = this.game,
        this.pointerDownCallback = null,
        this.pointerMoveCallback = null,
        this.pointerUpCallback = null,
        this.capture = !1,
        this.event = null,
        this.active = !1,
        this.enabled = !0,
        this._onMSPointerDown = null,
        this._onMSPointerMove = null,
        this._onMSPointerUp = null,
        this._onMSPointerUpGlobal = null,
        this._onMSPointerOut = null,
        this._onMSPointerOver = null
    },
    t.MSPointer.prototype = {
        start: function() {
            if (!this.game.device.mspointer) return ! 1;
            if (null !== this._onMSPointerDown) return ! 1;
            var t = this;
            this._onMSPointerDown = function(e) {
                return t.onPointerDown(e)
            },
            this._onMSPointerMove = function(e) {
                return t.onPointerMove(e)
            },
            this._onMSPointerUp = function(e) {
                return t.onPointerUp(e)
            },
            this._onMSPointerUpGlobal = function(e) {
                return t.onPointerUpGlobal(e)
            },
            this._onMSPointerOut = function(e) {
                return t.onPointerOut(e)
            },
            this._onMSPointerOver = function(e) {
                return t.onPointerOver(e)
            };
            var e = this.game.canvas;
            return e.addEventListener("MSPointerDown", this._onMSPointerDown, !1),
            e.addEventListener("MSPointerMove", this._onMSPointerMove, !1),
            e.addEventListener("MSPointerUp", this._onMSPointerUp, !1),
            e.addEventListener("pointerdown", this._onMSPointerDown, !1),
            e.addEventListener("pointermove", this._onMSPointerMove, !1),
            e.addEventListener("pointerup", this._onMSPointerUp, !1),
            e.style["-ms-content-zooming"] = "none",
            e.style["-ms-touch-action"] = "none",
            this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0)),
            this.active = !0,
            !0
        },
        onPointerDown: function(t) {
            this.game.input.executeTouchLockCallbacks(!1, t),
            this.event = t,
            this.capture && t.preventDefault(),
            this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
        },
        onPointerMove: function(t) {
            this.event = t,
            this.capture && t.preventDefault(),
            this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
        },
        onPointerUp: function(t) {
            this.game.input.executeTouchLockCallbacks(!0, t),
            this.event = t,
            this.capture && t.preventDefault(),
            this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t),
            this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
        },
        onPointerUpGlobal: function(t) {
            if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && e.withinGame && this.onPointerUp(t)
            } else this.onPointerUp(t)
        },
        onPointerOut: function(t) {
            if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
            else {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && (e.withinGame = !1)
            }
            this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t),
            this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
        },
        onPointerOver: function(t) {
            if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
            else {
                var e = this.input.getPointerFromIdentifier(t.identifier);
                e && (e.withinGame = !0)
            }
            this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
        },
        stop: function() {
            var t = this.game.canvas;
            t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1),
            t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1),
            t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1),
            t.removeEventListener("pointerdown", this._onMSPointerDown, !1),
            t.removeEventListener("pointermove", this._onMSPointerMove, !1),
            t.removeEventListener("pointerup", this._onMSPointerUp, !1),
            window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
            t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0),
            t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0),
            window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0),
            t.removeEventListener("pointerover", this._onMSPointerOver, !0),
            t.removeEventListener("pointerout", this._onMSPointerOut, !0),
            this.active = !1
        }
    },
    t.MSPointer.prototype.constructor = t.MSPointer, t.DeviceButton = function(e, i) {
        this.parent = e,
        this.game = e.game,
        this.event = null,
        this.isDown = !1,
        this.isUp = !0,
        this.timeDown = 0,
        this.timeUp = 0,
        this.repeats = 0,
        this.altKey = !1,
        this.shiftKey = !1,
        this.ctrlKey = !1,
        this.value = 0,
        this.buttonCode = i,
        this.onDown = new t.Signal,
        this.onUp = new t.Signal,
        this.onFloat = new t.Signal
    },
    t.DeviceButton.prototype = {
        start: function(t, e) {
            this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
        },
        stop: function(t, e) {
            this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
        },
        startStop: function(t, e, i) {
            t ? this.start(e, i) : this.stop(e, i)
        },
        padFloat: function(t) {
            this.isDown = !1,
            this.isUp = !1,
            this.value = t,
            this.onFloat.dispatch(this, t)
        },
        justPressed: function(t) {
            return t = t || 250,
            this.isDown && this.timeDown + t > this.game.time.time
        },
        justReleased: function(t) {
            return t = t || 250,
            this.isUp && this.timeUp + t > this.game.time.time
        },
        reset: function() {
            this.isDown = !1,
            this.isUp = !0,
            this.timeDown = this.game.time.time,
            this.repeats = 0,
            this.altKey = !1,
            this.shiftKey = !1,
            this.ctrlKey = !1
        },
        destroy: function() {
            this.onDown.dispose(),
            this.onUp.dispose(),
            this.onFloat.dispose(),
            this.parent = null,
            this.game = null
        }
    },
    t.DeviceButton.prototype.constructor = t.DeviceButton, Object.defineProperty(t.DeviceButton.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }), t.Pointer = function(e, i, s) {
        this.game = e,
        this.id = i,
        this.type = t.POINTER,
        this.exists = !0,
        this.identifier = 0,
        this.pointerId = null,
        this.pointerMode = s || t.PointerMode.CURSOR | t.PointerMode.CONTACT,
        this.target = null,
        this.button = null,
        this.leftButton = new t.DeviceButton(this, t.Pointer.LEFT_BUTTON),
        this.middleButton = new t.DeviceButton(this, t.Pointer.MIDDLE_BUTTON),
        this.rightButton = new t.DeviceButton(this, t.Pointer.RIGHT_BUTTON),
        this.backButton = new t.DeviceButton(this, t.Pointer.BACK_BUTTON),
        this.forwardButton = new t.DeviceButton(this, t.Pointer.FORWARD_BUTTON),
        this.eraserButton = new t.DeviceButton(this, t.Pointer.ERASER_BUTTON),
        this._holdSent = !1,
        this._history = [],
        this._nextDrop = 0,
        this._stateReset = !1,
        this.withinGame = !1,
        this.clientX = -1,
        this.clientY = -1,
        this.pageX = -1,
        this.pageY = -1,
        this.screenX = -1,
        this.screenY = -1,
        this.rawMovementX = 0,
        this.rawMovementY = 0,
        this.movementX = 0,
        this.movementY = 0,
        this.x = -1,
        this.y = -1,
        this.isMouse = 0 === i,
        this.isDown = !1,
        this.isUp = !0,
        this.timeDown = 0,
        this.timeUp = 0,
        this.previousTapTime = 0,
        this.totalTouches = 0,
        this.msSinceLastClick = Number.MAX_VALUE,
        this.targetObject = null,
        this.interactiveCandidates = [],
        this.active = !1,
        this.dirty = !1,
        this.position = new t.Point,
        this.positionDown = new t.Point,
        this.positionUp = new t.Point,
        this.circle = new t.Circle(0, 0, 44),
        this._clickTrampolines = null,
        this._trampolineTargetObject = null
    },
    t.Pointer.NO_BUTTON = 0, t.Pointer.LEFT_BUTTON = 1, t.Pointer.RIGHT_BUTTON = 2, t.Pointer.MIDDLE_BUTTON = 4, t.Pointer.BACK_BUTTON = 8, t.Pointer.FORWARD_BUTTON = 16, t.Pointer.ERASER_BUTTON = 32, t.Pointer.prototype = {
        resetButtons: function() {
            this.isDown = !1,
            this.isUp = !0,
            this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
        },
        processButtonsDown: function(e, i) {
            switch (e) {
            case t.Mouse.LEFT_BUTTON:
                this.leftButton.start(i);
                break;
            case t.Mouse.RIGHT_BUTTON:
                this.rightButton.start(i);
                break;
            case t.Mouse.MIDDLE_BUTTON:
                this.middleButton.start(i);
                break;
            case t.Mouse.BACK_BUTTON:
                this.backButton.start(i);
                break;
            case t.Mouse.FORWARD_BUTTON:
                this.forwardButton.start(i)
            }
        },
        processButtonsUp: function(e, i) {
            switch (e) {
            case t.Mouse.LEFT_BUTTON:
                this.leftButton.stop(i);
                break;
            case t.Mouse.RIGHT_BUTTON:
                this.rightButton.stop(i);
                break;
            case t.Mouse.MIDDLE_BUTTON:
                this.middleButton.stop(i);
                break;
            case t.Mouse.BACK_BUTTON:
                this.backButton.stop(i);
                break;
            case t.Mouse.FORWARD_BUTTON:
                this.forwardButton.stop(i)
            }
        },
        processButtonsUpDown: function(e, i) {
            var s = i.type.toLowerCase().substr( - 4),
            n = "down" === s,
            r = "move" === s;
            void 0 !== e ? (n && 1 === e && i.ctrlKey && (e = 2), this.leftButton.startStop(t.Pointer.LEFT_BUTTON & e, i), this.rightButton.startStop(t.Pointer.RIGHT_BUTTON & e, i), this.middleButton.startStop(t.Pointer.MIDDLE_BUTTON & e, i), this.backButton.startStop(t.Pointer.BACK_BUTTON & e, i), this.forwardButton.startStop(t.Pointer.FORWARD_BUTTON & e, i), this.eraserButton.startStop(t.Pointer.ERASER_BUTTON & e, i)) : void 0 !== i.button ? n && i.ctrlKey && 0 === i.button ? this.rightButton.start(i) : n ? this.processButtonsDown(i.button, i) : r || this.processButtonsUp(i.button, i) : n ? i.ctrlKey ? this.rightButton.start(i) : this.leftButton.start(i) : (this.leftButton.stop(i), this.rightButton.stop(i))
        },
        updateButtons: function(t) {
            this.button = t.button,
            this.processButtonsUpDown(t.buttons, t),
            this.isUp = !0,
            this.isDown = !1,
            (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
        },
        start: function(e) {
            var i = this.game.input;
            return e.pointerId && (this.pointerId = e.pointerId),
            this.identifier = e.identifier,
            this.target = e.target,
            this.isMouse ? this.updateButtons(e) : (this.isDown = !0, this.isUp = !1),
            this.active = !0,
            this.withinGame = !0,
            this.dirty = !1,
            this._history = [],
            this._clickTrampolines = null,
            this._trampolineTargetObject = null,
            this.msSinceLastClick = this.game.time.time - this.timeDown,
            this.timeDown = this.game.time.time,
            this._holdSent = !1,
            this.move(e, !0),
            this.positionDown.setTo(this.x, this.y),
            (i.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.x = this.x, i.y = this.y, i.position.setTo(this.x, this.y), i.onDown.dispatch(this, e), i.resetSpeed(this.x, this.y)),
            this._stateReset = !1,
            this.totalTouches++,
            null !== this.targetObject && this.targetObject._touchedHandler(this),
            this
        },
        update: function() {
            var e = this.game.input;
            this.active && (this.dirty && (e.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= e.holdRate && ((e.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && e.onHold.dispatch(this), this._holdSent = !0), e.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + e.recordRate, this._history.push({
                x: this.position.x,
                y: this.position.y
            }), this._history.length > e.recordLimit && this._history.shift()))
        },
        move: function(e, i) {
            var s = this.game.input;
            if (!s.pollLocked) {
                void 0 === i && (i = !1),
                void 0 !== e.button && (this.button = e.button),
                this.isMouse && this.updateButtons(e),
                this.clientX = e.clientX,
                this.clientY = e.clientY,
                this.pageX = e.pageX,
                this.pageY = e.pageY,
                this.screenX = e.screenX,
                this.screenY = e.screenY,
                this.isMouse && s.mouse.locked && !i && (this.rawMovementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0, this.rawMovementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY),
                this.x = (this.pageX - this.game.scale.offset.x) * s.scale.x,
                this.y = (this.pageY - this.game.scale.offset.y) * s.scale.y,
                this.position.setTo(this.x, this.y),
                this.circle.x = this.x,
                this.circle.y = this.y,
                (s.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || s.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || s.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === s.totalActivePointers) && (s.activePointer = this, s.x = this.x, s.y = this.y, s.position.setTo(s.x, s.y), s.circle.x = s.x, s.circle.y = s.y),
                this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                for (var n = s.moveCallbacks.length; n--;) s.moveCallbacks[n].callback.call(s.moveCallbacks[n].context, this, this.x, this.y, i, e);
                return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? s.interactiveItems.total > 0 && this.processInteractiveObjects(i) : !1 === this.targetObject.update(this) && (this.targetObject = null),
                this
            }
        },
        processInteractiveObjects: function(t) {
            var e = 0,
            i = -1,
            s = null,
            n = this.game.input.interactiveItems.first;
            for (this.interactiveCandidates = []; n;) n.checked = !1,
            !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))),
            n = this.game.input.interactiveItems.next;
            for (n = this.game.input.interactiveItems.first; n;) ! n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)),
            n = this.game.input.interactiveItems.next;
            return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)),
            this.swapTarget(s, !1),
            null !== this.targetObject
        },
        swapTarget: function(t, e) {
            void 0 === e && (e = !1),
            null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
        },
        leave: function(t) {
            this.withinGame = !1,
            this.move(t, !1)
        },
        stop: function(e) {
            var i = this.game.input;
            if (!this._stateReset || !this.withinGame) {
                if (this.timeUp = this.game.time.time, (i.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.onUp.dispatch(this, e), this.duration >= 0 && this.duration <= i.tapRate)) {
                    var s = this.timeUp - this.previousTapTime < i.doubleTapRate;
                    i.onTap.dispatch(this, s, e),
                    this.previousTapTime = this.timeUp
                }
                return this.isMouse ? this.updateButtons(e) : (this.isDown = !1, this.isUp = !0),
                this.id > 0 && (this.active = !1),
                this.withinGame = this.game.scale.bounds.contains(e.pageX, e.pageY),
                this.pointerId = null,
                this.identifier = null,
                this.positionUp.setTo(this.x, this.y),
                !1 === this.isMouse && i.currentPointers--,
                i.interactiveItems.callAll("_releasedHandler", this),
                this._clickTrampolines && (this._trampolineTargetObject = this.targetObject),
                this.targetObject = null,
                this
            }
            e.preventDefault()
        },
        justPressed: function(t) {
            return t = t || this.game.input.justPressedRate,
            !0 === this.isDown && this.timeDown + t > this.game.time.time
        },
        justReleased: function(t) {
            return t = t || this.game.input.justReleasedRate,
            this.isUp && this.timeUp + t > this.game.time.time
        },
        addClickTrampoline: function(t, e, i, s) {
            if (this.isDown) {
                for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++) if (n[r].name === t) {
                    n.splice(r, 1);
                    break
                }
                n.push({
                    name: t,
                    targetObject: this.targetObject,
                    callback: e,
                    callbackContext: i,
                    callbackArgs: s
                })
            }
        },
        processClickTrampolines: function() {
            var t = this._clickTrampolines;
            if (t) {
                for (var e = 0; e < t.length; e++) {
                    var i = t[e];
                    i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                }
                this._clickTrampolines = null,
                this._trampolineTargetObject = null
            }
        },
        reset: function() { ! 1 === this.isMouse && (this.active = !1),
            this.pointerId = null,
            this.identifier = null,
            this.dirty = !1,
            this.totalTouches = 0,
            this._holdSent = !1,
            this._history.length = 0,
            this._stateReset = !0,
            this.resetButtons(),
            this.targetObject && this.targetObject._releasedHandler(this),
            this.targetObject = null
        },
        resetMovement: function() {
            this.movementX = 0,
            this.movementY = 0
        }
    },
    t.Pointer.prototype.constructor = t.Pointer, Object.defineProperty(t.Pointer.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }), Object.defineProperty(t.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x
        }
    }), Object.defineProperty(t.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y
        }
    }), t.PointerMode = {
        CURSOR: 1,
        CONTACT: 2
    },
    t.PointerModes = {},
    t.PointerModes[t.PointerMode.CURSOR] = "CURSOR", t.PointerModes[t.PointerMode.CONTACT] = "CONTACT", t.Touch = function(t) {
        this.game = t,
        this.active = !1,
        this.enabled = !0,
        this.callbackContext = this.game,
        this.touchStartCallback = null,
        this.touchMoveCallback = null,
        this.touchEndCallback = null,
        this.touchEnterCallback = null,
        this.touchLeaveCallback = null,
        this.touchCancelCallback = null,
        this.preventDefault = !0,
        this.event = null,
        this._onTouchStart = null,
        this._onTouchMove = null,
        this._onTouchEnd = null,
        this._onTouchEnter = null,
        this._onTouchLeave = null,
        this._onTouchCancel = null,
        this._onTouchMove = null
    },
    t.Touch.prototype = {
        start: function() {
            if (!this.game.device.touch) return ! 1;
            if (null !== this._onTouchStart) return ! 1;
            var t = this;
            return this._onTouchStart = function(e) {
                return t.onTouchStart(e)
            },
            this._onTouchMove = function(e) {
                return t.onTouchMove(e)
            },
            this._onTouchEnd = function(e) {
                return t.onTouchEnd(e)
            },
            this._onTouchEnter = function(e) {
                return t.onTouchEnter(e)
            },
            this._onTouchLeave = function(e) {
                return t.onTouchLeave(e)
            },
            this._onTouchCancel = function(e) {
                return t.onTouchCancel(e)
            },
            this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1),
            this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1),
            this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1),
            this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1),
            this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)),
            this.active = !0,
            !0
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(t) {
                t.preventDefault()
            },
            document.addEventListener("touchmove", this._documentTouchMove, !1)
        },
        onTouchStart: function(t) {
            if (this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.game.input.enabled && this.enabled) {
                this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t),
                this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
            }
        },
        onTouchCancel: function(t) {
            if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
            }
        },
        onTouchEnter: function(t) {
            this.event = t,
            this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t),
            this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
        },
        onTouchLeave: function(t) {
            this.event = t,
            this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t),
            this.preventDefault && t.preventDefault()
        },
        onTouchMove: function(t) {
            this.event = t,
            this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t),
            this.preventDefault && t.preventDefault();
            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
        },
        onTouchEnd: function(t) {
            this.game.input.executeTouchLockCallbacks(!0, t),
            this.event = t,
            this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t),
            this.preventDefault && t.preventDefault();
            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
        },
        stop: function() {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel), this.active = !1)
        }
    },
    t.Touch.prototype.constructor = t.Touch, t.InputHandler = function(e) {
        this.sprite = e,
        this.game = e.game,
        this.enabled = !1,
        this.checked = !1,
        this.priorityID = 0,
        this.useHandCursor = !1,
        this._setHandCursor = !1,
        this.isDragged = !1,
        this.allowHorizontalDrag = !0,
        this.allowVerticalDrag = !0,
        this.bringToTop = !1,
        this.snapOffset = null,
        this.snapOnDrag = !1,
        this.snapOnRelease = !1,
        this.snapX = 0,
        this.snapY = 0,
        this.snapOffsetX = 0,
        this.snapOffsetY = 0,
        this.pixelPerfectOver = !1,
        this.pixelPerfectClick = !1,
        this.pixelPerfectAlpha = 255,
        this.draggable = !1,
        this.boundsRect = null,
        this.boundsSprite = null,
        this.scaleLayer = !1,
        this.dragOffset = new t.Point,
        this.dragFromCenter = !1,
        this.dragStopBlocksInputUp = !1,
        this.dragStartPoint = new t.Point,
        this.dragDistanceThreshold = 0,
        this.dragTimeThreshold = 0,
        this.downPoint = new t.Point,
        this.snapPoint = new t.Point,
        this._dragPoint = new t.Point,
        this._dragPhase = !1,
        this._pendingDrag = !1,
        this._dragTimePass = !1,
        this._dragDistancePass = !1,
        this._wasEnabled = !1,
        this._tempPoint = new t.Point,
        this._pointerData = [],
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            camX: 0,
            camY: 0,
            isDown: !1,
            isUp: !1,
            isOver: !1,
            isOut: !1,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: !1
        })
    },
    t.InputHandler.prototype = {
        start: function(e, i) {
            if (e = e || 0, void 0 === i && (i = !1), !1 === this.enabled) {
                this.game.input.interactiveItems.add(this),
                this.useHandCursor = i,
                this.priorityID = e;
                for (var s = 0; s < 10; s++) this._pointerData[s] = {
                    id: s,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                };
                this.snapOffset = new t.Point,
                this.enabled = !0,
                this._wasEnabled = !0
            }
            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this),
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this),
            this.sprite
        },
        addedToGroup: function() {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start()
        },
        removedFromGroup: function() {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
        },
        reset: function() {
            this.enabled = !1;
            for (var t = 0; t < 10; t++) this._pointerData[t] = {
                id: t,
                x: 0,
                y: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            }
        },
        stop: function() { ! 1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
        },
        destroy: function() {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
        },
        validForInput: function(t, e, i) {
            return void 0 === i && (i = !0),
            !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput || !i && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver
        },
        pointerX: function(t) {
            return t = t || 0,
            this._pointerData[t].x
        },
        pointerY: function(t) {
            return t = t || 0,
            this._pointerData[t].y
        },
        pointerDown: function(t) {
            return t = t || 0,
            this._pointerData[t].isDown
        },
        pointerUp: function(t) {
            return t = t || 0,
            this._pointerData[t].isUp
        },
        pointerTimeDown: function(t) {
            return t = t || 0,
            this._pointerData[t].timeDown
        },
        pointerTimeUp: function(t) {
            return t = t || 0,
            this._pointerData[t].timeUp
        },
        pointerOver: function(t) {
            if (!this.enabled) return ! 1;
            if (void 0 === t) {
                for (var e = 0; e < 10; e++) if (this._pointerData[e].isOver) return ! 0;
                return ! 1
            }
            return this._pointerData[t].isOver
        },
        pointerOut: function(t) {
            if (!this.enabled) return ! 1;
            if (void 0 !== t) return this._pointerData[t].isOut;
            for (var e = 0; e < 10; e++) if (this._pointerData[e].isOut) return ! 0
        },
        pointerTimeOver: function(t) {
            return t = t || 0,
            this._pointerData[t].timeOver
        },
        pointerTimeOut: function(t) {
            return t = t || 0,
            this._pointerData[t].timeOut
        },
        pointerDragged: function(t) {
            return t = t || 0,
            this._pointerData[t].isDragged
        },
        checkPointerDown: function(t, e) {
            return !! (t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
        },
        checkPointerOver: function(t, e) {
            return !! (this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
        },
        checkPixel: function(t, e, i) {
            if (this.sprite.texture.baseTexture.source) {
                if (null === t && null === e) {
                    this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                    t = this._tempPoint.x,
                    e = this._tempPoint.y
                }
                if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t,
                this._dy = e,
                !1;
                if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return ! 0
            }
            return ! 1
        },
        update: function(e) {
            if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = t.Math.distance(e.x, e.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(e), !0) : this.draggable && this._draggedPointerID === e.id ? this.updateDrag(e, !1) : this._pointerData[e.id].isOver ? this.checkPointerOver(e) ? (this._pointerData[e.id].x = e.x - this.sprite.x, this._pointerData[e.id].y = e.y - this.sprite.y, !0) : (this._pointerOutHandler(e), !1) : void 0 : (this._pointerOutHandler(e), !1)
        },
        _pointerOverHandler: function(t, e) {
            if (null !== this.sprite) {
                var i = this._pointerData[t.id];
                if (!1 === i.isOver || t.dirty) {
                    var s = !1 === i.isOver;
                    i.isOver = !0,
                    i.isOut = !1,
                    i.timeOver = this.game.time.time,
                    i.x = t.x - this.sprite.x,
                    i.y = t.y - this.sprite.y,
                    this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0),
                    !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t),
                    this.sprite.parent && this.sprite.parent.onChildInputOver && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                }
            }
        },
        _pointerOutHandler: function(t, e) {
            if (null !== this.sprite) {
                var i = this._pointerData[t.id];
                i.isOver = !1,
                i.isOut = !0,
                i.timeOut = this.game.time.time,
                this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1),
                !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputOut && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
            }
        },
        _touchedHandler: function(t) {
            if (null !== this.sprite) {
                var e = this._pointerData[t.id];
                if (!e.isDown && e.isOver) {
                    if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                    if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputDown && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                    this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)),
                    this.bringToTop && this.sprite.bringToTop()
                }
            }
        },
        dragTimeElapsed: function(t) {
            this._dragTimePass = !0,
            this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
        },
        _releasedHandler: function(t) {
            if (null !== this.sprite) {
                var e = this._pointerData[t.id];
                if (e.isDown && t.isUp) {
                    e.isDown = !1,
                    e.isUp = !0,
                    e.timeUp = this.game.time.time,
                    e.downDuration = e.timeUp - e.timeDown;
                    var i = this.checkPointerOver(t);
                    this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputUp && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))),
                    e.isOver = i,
                    !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1),
                    t.dirty = !0,
                    this._pendingDrag = !1,
                    this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                }
            }
        },
        updateDrag: function(t, e) {
            var i = this.game.camera,
            s = this.dragOffset,
            n = this._dragPoint,
            r = this._pointerData[t.id],
            o = this.snapPoint,
            a = this.sprite;
            if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t),
            !1;
            var h = this.globalToLocal(t);
            if (a.fixedToCamera) var l = i.scale.x * h.x + n.x + s.x,
            c = i.scale.y * h.y + n.y + s.y;
            else l = h.x + n.x + s.x,
            c = h.y + n.y + s.y;
            if (a.fixedToCamera) {
                var u = a.cameraOffset,
                d = u.x,
                p = u.y;
                this.allowHorizontalDrag && (u.x = l - i.x),
                this.allowVerticalDrag && (u.y = c - i.y),
                this.boundsRect && this.checkBoundsRect(),
                this.boundsSprite && this.checkBoundsSprite(),
                this.snapOnDrag && (u.x = Math.round((u.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, u.y = Math.round((u.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(u.x, u.y));
                var f = u.x - d,
                g = u.y - p
            } else {
                var m = i.x - r.camX,
                y = i.y - r.camY;
                d = a.x,
                p = a.y;
                this.allowHorizontalDrag && (a.x = l + m),
                this.allowVerticalDrag && (a.y = c + y),
                this.boundsRect && this.checkBoundsRect(),
                this.boundsSprite && this.checkBoundsSprite(),
                this.snapOnDrag && (a.x = Math.round((a.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, a.y = Math.round((a.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(a.x, a.y));
                f = a.x - d,
                g = a.y - p
            }
            return this.sprite.events.onDragUpdate.dispatch(a, t, l, c, o, e, f, g),
            !0
        },
        justOver: function(t, e) {
            return t = t || 0,
            e = e || 500,
            this._pointerData[t].isOver && this.overDuration(t) < e
        },
        justOut: function(t, e) {
            return t = t || 0,
            e = e || 500,
            this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
        },
        justPressed: function(t, e) {
            return t = t || 0,
            e = e || 500,
            this._pointerData[t].isDown && this.downDuration(t) < e
        },
        justReleased: function(t, e) {
            return t = t || 0,
            e = e || 500,
            this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
        },
        overDuration: function(t) {
            return t = t || 0,
            this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver: -1
        },
        downDuration: function(t) {
            return t = t || 0,
            this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown: -1
        },
        enableDrag: function(e, i, s, n, r, o) {
            void 0 === e && (e = !1),
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            void 0 === n && (n = 255),
            void 0 === r && (r = null),
            void 0 === o && (o = null),
            this._dragPoint = new t.Point,
            this.draggable = !0,
            this.bringToTop = i,
            this.dragOffset = new t.Point,
            this.dragFromCenter = e,
            this.pixelPerfectClick = s,
            this.pixelPerfectAlpha = n,
            r && (this.boundsRect = r),
            o && (this.boundsSprite = o)
        },
        disableDrag: function() {
            if (this._pointerData) for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
            this.draggable = !1,
            this.isDragged = !1,
            this._draggedPointerID = -1,
            this._pendingDrag = !1
        },
        startDrag: function(e) {
            var i = this.sprite.x,
            s = this.sprite.y,
            n = this.globalToLocal(e);
            if (this.isDragged = !0, this._draggedPointerID = e.id, this._pointerData[e.id].camX = this.game.camera.x, this._pointerData[e.id].camY = this.game.camera.y, this._pointerData[e.id].isDragged = !0, this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    var r = this.sprite.getBounds(),
                    o = this.globalToLocal(new t.Point(r.centerX, r.centerY));
                    this.sprite.cameraOffset.x = n.x + (this.sprite.cameraOffset.x - o.x),
                    this.sprite.cameraOffset.y = n.y + (this.sprite.cameraOffset.y - o.y)
                }
                this._dragPoint.setTo(this.sprite.cameraOffset.x - e.x, this.sprite.cameraOffset.y - e.y)
            } else {
                if (this.dragFromCenter) {
                    r = this.sprite.getBounds(),
                    o = this.globalToLocal(new t.Point(r.centerX, r.centerY));
                    this.sprite.x = n.x + (this.sprite.x - o.x),
                    this.sprite.y = n.y + (this.sprite.y - o.y)
                }
                this._dragPoint.setTo(this.sprite.x - n.x, this.sprite.y - n.y)
            }
            this.updateDrag(e, !0),
            this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()),
            this.dragStartPoint.set(i, s),
            this.sprite.events.onDragStart$dispatch(this.sprite, e, i, s),
            this._pendingDrag = !1
        },
        globalToLocalX: function(t) {
            return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x),
            t
        },
        globalToLocalY: function(t) {
            return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y),
            t
        },
        globalToLocal: function(t) {
            return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                x: t.x,
                y: t.y
            }) : t
        },
        stopDrag: function(t) {
            this.isDragged = !1,
            this._draggedPointerID = -1,
            this._pointerData[t.id].isDragged = !1,
            this._dragPhase = !1,
            this._pendingDrag = !1,
            this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)),
            this.sprite.events.onDragStop$dispatch(this.sprite, t),
            !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
        },
        setDragLock: function(t, e) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            this.allowHorizontalDrag = t,
            this.allowVerticalDrag = e
        },
        enableSnap: function(t, e, i, s, n, r) {
            void 0 === i && (i = !0),
            void 0 === s && (s = !1),
            void 0 === n && (n = 0),
            void 0 === r && (r = 0),
            this.snapX = t,
            this.snapY = e,
            this.snapOffsetX = n,
            this.snapOffsetY = r,
            this.snapOnDrag = i,
            this.snapOnRelease = s
        },
        disableSnap: function() {
            this.snapOnDrag = !1,
            this.snapOnRelease = !1
        },
        checkBoundsRect: function() {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left: this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top: this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX: this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY: this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
        },
        checkBoundsSprite: function() {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x: this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y: this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX: this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY: this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
        }
    },
    t.InputHandler.prototype.constructor = t.InputHandler, t.PointerLock = function(e) {
        this.game = e,
        this.input = e.input,
        this.element = e.canvas,
        this.active = !1,
        this.locked = !1,
        this.onChange = new t.Signal,
        this.onError = new t.Signal,
        this.boundOnChangeHandler = this.onChangeHandler.bind(this),
        this.boundOnErrorHandler = this.onErrorHandler.bind(this);
        var i = e.device;
        this.pointerLockElement = i.pointerLockElement,
        this.pointerlockchange = i.pointerlockchange,
        this.pointerlockerror = i.pointerlockerror
    },
    t.PointerLock.prototype.start = function() {
        return ! (!this.game.device.pointerLock || this.active || (this.element.requestPointerLock || (this.element.requestPointerLock = this.element.mozRequestPointerLock || this.element.webkitRequestPointerLock), document.exitPointerLock || (document.exitPointerLock = document.mozExitPointerLock || document.webkitExitPointerLock), document.addEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.addEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !0, 0))
    },
    t.PointerLock.prototype.stop = function() {
        this.active && (document.removeEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.removeEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !1)
    },
    t.PointerLock.prototype.request = function() {
        this.active && !this.locked && this.element.requestPointerLock()
    },
    t.PointerLock.prototype.exit = function() {
        document.exitPointerLock()
    },
    t.PointerLock.prototype.onChangeHandler = function(t) {
        this.locked = document[this.pointerLockElement] === this.element,
        this.onChange.dispatch(this.locked, t)
    },
    t.PointerLock.prototype.onErrorHandler = function(t) {
        this.onError.dispatch(t)
    },
    t.Gamepad = function(e) {
        this.game = e,
        this._gamepadIndexMap = {},
        this._rawPads = [],
        this._active = !1,
        this.enabled = !0,
        this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads,
        this._prevRawGamepadTypes = [],
        this._prevTimestamps = [],
        this.callbackContext = this,
        this.onConnectCallback = null,
        this.onDisconnectCallback = null,
        this.onDownCallback = null,
        this.onUpCallback = null,
        this.onAxisCallback = null,
        this.onFloatCallback = null,
        this._ongamepadconnected = null,
        this._gamepaddisconnected = null,
        this._gamepads = [new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this)]
    },
    t.Gamepad.prototype = {
        addCallbacks: function(t, e) {
            void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect: this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect: this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown: this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp: this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis: this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat: this.onFloatCallback, this.callbackContext = t)
        },
        start: function() {
            if (!this._active) {
                this._active = !0;
                var t = this;
                this._onGamepadConnected = function(e) {
                    return t.onGamepadConnected(e)
                },
                this._onGamepadDisconnected = function(e) {
                    return t.onGamepadDisconnected(e)
                },
                window.addEventListener("gamepadconnected", this._onGamepadConnected, !1),
                window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
            }
        },
        onGamepadConnected: function(t) {
            var e = t.gamepad;
            this._rawPads.push(e),
            this._gamepads[e.index].connect(e)
        },
        onGamepadDisconnected: function(t) {
            var e = t.gamepad;
            for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
            this._gamepads[e.index].disconnect()
        },
        update: function() {
            this._pollGamepads(),
            this.pad1.pollStatus(),
            this.pad2.pollStatus(),
            this.pad3.pollStatus(),
            this.pad4.pollStatus()
        },
        _pollGamepads: function() {
            if (this._active) {
                if (navigator.getGamepads) t = navigator.getGamepads();
                else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                if (t) {
                    this._rawPads = [];
                    for (var e = !1,
                    i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                    for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                    if (e) {
                        for (var n, r = {
                            rawIndices: {},
                            padIndices: {}
                        },
                        o = 0; o < this._gamepads.length; o++) if ((n = this._gamepads[o]).connected) for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === n.index && (r.rawIndices[n.index] = !0, r.padIndices[o] = !0);
                        for (var h = 0; h < this._gamepads.length; h++) if (n = this._gamepads[h], !r.padIndices[h]) {
                            this._rawPads.length < 1 && n.disconnect();
                            for (var l = 0; l < this._rawPads.length && !r.padIndices[h]; l++) {
                                var c = this._rawPads[l];
                                if (c) {
                                    if (r.rawIndices[c.index]) {
                                        n.disconnect();
                                        continue
                                    }
                                    n.connect(c),
                                    r.rawIndices[c.index] = !0,
                                    r.padIndices[h] = !0
                                } else n.disconnect()
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(t) {
            for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
        },
        stop: function() {
            this._active = !1,
            window.removeEventListener("gamepadconnected", this._onGamepadConnected),
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
        },
        reset: function() {
            this.update();
            for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
        },
        justPressed: function(t, e) {
            for (var i = 0; i < this._gamepads.length; i++) if (!0 === this._gamepads[i].justPressed(t, e)) return ! 0;
            return ! 1
        },
        justReleased: function(t, e) {
            for (var i = 0; i < this._gamepads.length; i++) if (!0 === this._gamepads[i].justReleased(t, e)) return ! 0;
            return ! 1
        },
        isDown: function(t) {
            for (var e = 0; e < this._gamepads.length; e++) if (!0 === this._gamepads[e].isDown(t)) return ! 0;
            return ! 1
        },
        destroy: function() {
            this.stop();
            for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
        }
    },
    t.Gamepad.prototype.constructor = t.Gamepad, Object.defineProperty(t.Gamepad.prototype, "active", {
        get: function() {
            return this._active
        }
    }), Object.defineProperty(t.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable
        }
    }), Object.defineProperty(t.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length
        }
    }), Object.defineProperty(t.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0]
        }
    }), Object.defineProperty(t.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1]
        }
    }), Object.defineProperty(t.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2]
        }
    }), Object.defineProperty(t.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3]
        }
    }), t.Gamepad.BUTTON_0 = 0, t.Gamepad.BUTTON_1 = 1, t.Gamepad.BUTTON_2 = 2, t.Gamepad.BUTTON_3 = 3, t.Gamepad.BUTTON_4 = 4, t.Gamepad.BUTTON_5 = 5, t.Gamepad.BUTTON_6 = 6, t.Gamepad.BUTTON_7 = 7, t.Gamepad.BUTTON_8 = 8, t.Gamepad.BUTTON_9 = 9, t.Gamepad.BUTTON_10 = 10, t.Gamepad.BUTTON_11 = 11, t.Gamepad.BUTTON_12 = 12, t.Gamepad.BUTTON_13 = 13, t.Gamepad.BUTTON_14 = 14, t.Gamepad.BUTTON_15 = 15, t.Gamepad.AXIS_0 = 0, t.Gamepad.AXIS_1 = 1, t.Gamepad.AXIS_2 = 2, t.Gamepad.AXIS_3 = 3, t.Gamepad.AXIS_4 = 4, t.Gamepad.AXIS_5 = 5, t.Gamepad.AXIS_6 = 6, t.Gamepad.AXIS_7 = 7, t.Gamepad.AXIS_8 = 8, t.Gamepad.AXIS_9 = 9, t.Gamepad.XBOX360_A = 0, t.Gamepad.XBOX360_B = 1, t.Gamepad.XBOX360_X = 2, t.Gamepad.XBOX360_Y = 3, t.Gamepad.XBOX360_LEFT_BUMPER = 4, t.Gamepad.XBOX360_RIGHT_BUMPER = 5, t.Gamepad.XBOX360_LEFT_TRIGGER = 6, t.Gamepad.XBOX360_RIGHT_TRIGGER = 7, t.Gamepad.XBOX360_BACK = 8, t.Gamepad.XBOX360_START = 9, t.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, t.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, t.Gamepad.XBOX360_DPAD_LEFT = 14, t.Gamepad.XBOX360_DPAD_RIGHT = 15, t.Gamepad.XBOX360_DPAD_UP = 12, t.Gamepad.XBOX360_DPAD_DOWN = 13, t.Gamepad.XBOX360_STICK_LEFT_X = 0, t.Gamepad.XBOX360_STICK_LEFT_Y = 1, t.Gamepad.XBOX360_STICK_RIGHT_X = 2, t.Gamepad.XBOX360_STICK_RIGHT_Y = 3, t.Gamepad.PS3XC_X = 0, t.Gamepad.PS3XC_CIRCLE = 1, t.Gamepad.PS3XC_SQUARE = 2, t.Gamepad.PS3XC_TRIANGLE = 3, t.Gamepad.PS3XC_L1 = 4, t.Gamepad.PS3XC_R1 = 5, t.Gamepad.PS3XC_L2 = 6, t.Gamepad.PS3XC_R2 = 7, t.Gamepad.PS3XC_SELECT = 8, t.Gamepad.PS3XC_START = 9, t.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, t.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, t.Gamepad.PS3XC_DPAD_UP = 12, t.Gamepad.PS3XC_DPAD_DOWN = 13, t.Gamepad.PS3XC_DPAD_LEFT = 14, t.Gamepad.PS3XC_DPAD_RIGHT = 15, t.Gamepad.PS3XC_STICK_LEFT_X = 0, t.Gamepad.PS3XC_STICK_LEFT_Y = 1, t.Gamepad.PS3XC_STICK_RIGHT_X = 2, t.Gamepad.PS3XC_STICK_RIGHT_Y = 3, t.SinglePad = function(t, e) {
        this.game = t,
        this.index = null,
        this.connected = !1,
        this.callbackContext = this,
        this.onConnectCallback = null,
        this.onDisconnectCallback = null,
        this.onDownCallback = null,
        this.onUpCallback = null,
        this.onAxisCallback = null,
        this.onFloatCallback = null,
        this.deadZone = .26,
        this._padParent = e,
        this._rawPad = null,
        this._prevTimestamp = null,
        this._buttons = [],
        this._buttonsLen = 0,
        this._axes = [],
        this._axesLen = 0
    },
    t.SinglePad.prototype = {
        addCallbacks: function(t, e) {
            void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect: this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect: this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown: this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp: this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis: this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat: this.onFloatCallback, this.callbackContext = t)
        },
        getButton: function(t) {
            return this._buttons[t] ? this._buttons[t] : null
        },
        pollStatus: function() {
            if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad || !this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                for (var t = 0; t < this._buttonsLen; t++) {
                    var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value: this._rawPad.buttons[t];
                    e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                }
                for (var i = 0; i < this._axesLen; i++) {
                    var s = this._rawPad.axes[i];
                    s > 0 && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                }
                this._prevTimestamp = this._rawPad.timestamp
            }
        },
        connect: function(e) {
            var i = !this.connected;
            this.connected = !0,
            this.index = e.index,
            this._rawPad = e,
            this._buttons = [],
            this._buttonsLen = e.buttons.length,
            this._axes = [],
            this._axesLen = e.axes.length;
            for (var s = 0; s < this._axesLen; s++) this._axes[s] = e.axes[s];
            for (var n in e.buttons) n = parseInt(n, 10),
            this._buttons[n] = new t.DeviceButton(this, n);
            i && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index),
            i && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
        },
        disconnect: function() {
            var t = this.connected,
            e = this.index;
            this.connected = !1,
            this.index = null,
            this._rawPad = void 0;
            for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
            this._buttons = [],
            this._buttonsLen = 0,
            this._axes = [],
            this._axesLen = 0,
            t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e),
            t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
        },
        destroy: function() {
            this._rawPad = void 0;
            for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
            this._buttons = [],
            this._buttonsLen = 0,
            this._axes = [],
            this._axesLen = 0,
            this.onConnectCallback = null,
            this.onDisconnectCallback = null,
            this.onDownCallback = null,
            this.onUpCallback = null,
            this.onAxisCallback = null,
            this.onFloatCallback = null
        },
        processAxisChange: function(t, e) {
            this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
        },
        processButtonDown: function(t, e) {
            this._buttons[t] && this._buttons[t].start(null, e),
            this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index),
            this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
        },
        processButtonUp: function(t, e) {
            this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index),
            this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e),
            this._buttons[t] && this._buttons[t].stop(null, e)
        },
        processButtonFloat: function(t, e) {
            this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index),
            this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e),
            this._buttons[t] && this._buttons[t].padFloat(e)
        },
        axis: function(t) {
            return !! this._axes[t] && this._axes[t]
        },
        isDown: function(t) {
            return !! this._buttons[t] && this._buttons[t].isDown
        },
        isUp: function(t) {
            return !! this._buttons[t] && this._buttons[t].isUp
        },
        justReleased: function(t, e) {
            if (this._buttons[t]) return this._buttons[t].justReleased(e)
        },
        justPressed: function(t, e) {
            if (this._buttons[t]) return this._buttons[t].justPressed(e)
        },
        buttonValue: function(t) {
            return this._buttons[t] ? this._buttons[t].value: null
        },
        reset: function() {
            for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
        }
    },
    t.SinglePad.prototype.constructor = t.SinglePad, t.Key = function(e, i) {
        this.game = e,
        this._enabled = !0,
        this.event = null,
        this.isDown = !1,
        this.isUp = !0,
        this.altKey = !1,
        this.ctrlKey = !1,
        this.shiftKey = !1,
        this.timeDown = 0,
        this.duration = 0,
        this.timeUp = -2500,
        this.durationUp = -2500,
        this.repeats = 0,
        this.keyCode = i,
        this.onDown = new t.Signal,
        this.onHoldCallback = null,
        this.onHoldContext = null,
        this.onUp = new t.Signal,
        this._justDown = !1,
        this._justUp = !1
    },
    t.Key.prototype = {
        update: function() {
            this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
        },
        processKeyDown: function(t) {
            this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
        },
        processKeyUp: function(t) {
            this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)))
        },
        reset: function(t) {
            void 0 === t && (t = !0),
            this.isDown = !1,
            this.isUp = !0,
            this.timeUp = this.game.time.time,
            this.duration = 0,
            this.durationUp = -2500,
            this._enabled = !0,
            this._justDown = !1,
            this._justUp = !1,
            t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
        },
        downDuration: function(t) {
            return void 0 === t && (t = 50),
            this.isDown && this.duration < t
        },
        upDuration: function(t) {
            return void 0 === t && (t = 50),
            !this.isDown && this.game.time.time - this.timeUp < t
        },
        justPressed: function() {
            return this.isDown && 0 === this.duration
        },
        justReleased: function() {
            return ! this.isDown && 0 === this.durationUp
        }
    },
    Object.defineProperty(t.Key.prototype, "justDown", {
        get: function() {
            var t = this._justDown;
            return this._justDown = !1,
            t
        }
    }), Object.defineProperty(t.Key.prototype, "justUp", {
        get: function() {
            var t = this._justUp;
            return this._justUp = !1,
            t
        }
    }), Object.defineProperty(t.Key.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(t) { (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
        }
    }), t.Key.prototype.constructor = t.Key, t.Keyboard = function(t) {
        this.game = t,
        this.active = !1,
        this.enabled = !0,
        this.event = null,
        this.pressEvent = null,
        this.callbackContext = this,
        this.onDownCallback = null,
        this.onPressCallback = null,
        this.onUpCallback = null,
        this._keys = [],
        this._capture = [],
        this._onKeyDown = null,
        this._onKeyPress = null,
        this._onKeyUp = null,
        this._i = 0,
        this._k = 0
    },
    t.Keyboard.prototype = {
        addCallbacks: function(t, e, i, s) {
            this.callbackContext = t,
            null != e && (this.onDownCallback = e),
            null != i && (this.onUpCallback = i),
            null != s && (this.onPressCallback = s)
        },
        removeCallbacks: function() {
            this.callbackContext = this,
            this.onDownCallback = null,
            this.onUpCallback = null,
            this.onPressCallback = null
        },
        addKey: function(e) {
            return this._keys[e] || (this._keys[e] = new t.Key(this.game, e), this.addKeyCapture(e)),
            this._keys[e]
        },
        addKeys: function(t) {
            var e = {};
            for (var i in t) e[i] = this.addKey(t[i]);
            return e
        },
        removeKey: function(t) {
            this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
        },
        createCursorKeys: function() {
            return this.addKeys({
                up: t.KeyCode.UP,
                down: t.KeyCode.DOWN,
                left: t.KeyCode.LEFT,
                right: t.KeyCode.RIGHT
            })
        },
        start: function() {
            if (this.game.device.cocoonJS) return ! 1;
            if (this.active) return ! 1;
            var t = this;
            return this._onKeyDown = function(e) {
                return t.processKeyDown(e)
            },
            this._onKeyUp = function(e) {
                return t.processKeyUp(e)
            },
            this._onKeyPress = function(e) {
                return t.processKeyPress(e)
            },
            window.addEventListener("keydown", this._onKeyDown, !1),
            window.addEventListener("keyup", this._onKeyUp, !1),
            window.addEventListener("keypress", this._onKeyPress, !1),
            this.active = !0,
            !0
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown),
            window.removeEventListener("keyup", this._onKeyUp),
            window.removeEventListener("keypress", this._onKeyPress),
            this._onKeyDown = null,
            this._onKeyUp = null,
            this._onKeyPress = null,
            this.active = !1
        },
        destroy: function() {
            this.stop(),
            this.clearCaptures(),
            this._keys.length = 0,
            this._i = 0
        },
        addKeyCapture: function(t) {
            if ("object" == typeof t) for (var e in t) this._capture[t[e]] = !0;
            else this._capture[t] = !0
        },
        removeKeyCapture: function(t) {
            delete this._capture[t]
        },
        clearCaptures: function() {
            this._capture = {}
        },
        update: function() {
            for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
        },
        processKeyDown: function(e) {
            if (this.event = e, this.game.input.enabled && this.enabled) {
                var i = e.keyCode;
                this._capture[i] && e.preventDefault(),
                this._keys[i] || (this._keys[i] = new t.Key(this.game, i)),
                this._keys[i].processKeyDown(e),
                this._k = i,
                this.onDownCallback && this.onDownCallback.call(this.callbackContext, e)
            }
        },
        processKeyPress: function(t) {
            this.pressEvent = t,
            this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
        },
        processKeyUp: function(e) {
            if (this.event = e, this.game.input.enabled && this.enabled) {
                var i = e.keyCode;
                this._capture[i] && e.preventDefault(),
                this._keys[i] || (this._keys[i] = new t.Key(this.game, i)),
                this._keys[i].processKeyUp(e),
                this.onUpCallback && this.onUpCallback.call(this.callbackContext, e)
            }
        },
        reset: function(t) {
            void 0 === t && (t = !0),
            this.event = null;
            for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
        },
        downDuration: function(t, e) {
            return this._keys[t] ? this._keys[t].downDuration(e) : null
        },
        upDuration: function(t, e) {
            return this._keys[t] ? this._keys[t].upDuration(e) : null
        },
        justPressed: function(t) {
            return this._keys[t] ? this._keys[t].justPressed() : null
        },
        justReleased: function(t) {
            return this._keys[t] ? this._keys[t].justReleased() : null
        },
        isDown: function(t) {
            return this._keys[t] ? this._keys[t].isDown: null
        }
    },
    Object.defineProperty(t.Keyboard.prototype, "lastChar", {
        get: function() {
            return this.event && 32 === this.event.charCode ? "": this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
        }
    }), Object.defineProperty(t.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k]
        }
    }), t.Keyboard.prototype.constructor = t.Keyboard, t.KeyCode = {
        A: "A".charCodeAt(0),
        B: "B".charCodeAt(0),
        C: "C".charCodeAt(0),
        D: "D".charCodeAt(0),
        E: "E".charCodeAt(0),
        F: "F".charCodeAt(0),
        G: "G".charCodeAt(0),
        H: "H".charCodeAt(0),
        I: "I".charCodeAt(0),
        J: "J".charCodeAt(0),
        K: "K".charCodeAt(0),
        L: "L".charCodeAt(0),
        M: "M".charCodeAt(0),
        N: "N".charCodeAt(0),
        O: "O".charCodeAt(0),
        P: "P".charCodeAt(0),
        Q: "Q".charCodeAt(0),
        R: "R".charCodeAt(0),
        S: "S".charCodeAt(0),
        T: "T".charCodeAt(0),
        U: "U".charCodeAt(0),
        V: "V".charCodeAt(0),
        W: "W".charCodeAt(0),
        X: "X".charCodeAt(0),
        Y: "Y".charCodeAt(0),
        Z: "Z".charCodeAt(0),
        ZERO: "0".charCodeAt(0),
        ONE: "1".charCodeAt(0),
        TWO: "2".charCodeAt(0),
        THREE: "3".charCodeAt(0),
        FOUR: "4".charCodeAt(0),
        FIVE: "5".charCodeAt(0),
        SIX: "6".charCodeAt(0),
        SEVEN: "7".charCodeAt(0),
        EIGHT: "8".charCodeAt(0),
        NINE: "9".charCodeAt(0),
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_ENTER: 108,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        F13: 124,
        F14: 125,
        F15: 126,
        COLON: 186,
        EQUALS: 187,
        COMMA: 188,
        UNDERSCORE: 189,
        PERIOD: 190,
        QUESTION_MARK: 191,
        TILDE: 192,
        OPEN_BRACKET: 219,
        BACKWARD_SLASH: 220,
        CLOSED_BRACKET: 221,
        QUOTES: 222,
        BACKSPACE: 8,
        TAB: 9,
        CLEAR: 12,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        CAPS_LOCK: 20,
        ESC: 27,
        SPACEBAR: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        PLUS: 43,
        MINUS: 44,
        INSERT: 45,
        DELETE: 46,
        HELP: 47,
        NUM_LOCK: 144
    },
    t.KeyCode) t.KeyCode.hasOwnProperty(i) && !i.match(/[a-z]/) && (t.Keyboard[i] = t.KeyCode[i]);
    for (var s in t.Component = function() {},
    t.Component.Angle = function() {},
    t.Component.Angle.prototype = {
        angle: {
            get: function() {
                return t.Math.wrapAngle(t.Math.radToDeg(this.rotation))
            },
            set: function(e) {
                this.rotation = t.Math.degToRad(t.Math.wrapAngle(e))
            }
        }
    },
    t.Component.Animation = function() {},
    t.Component.Animation.prototype = {
        play: function(t, e, i, s) {
            if (this.animations) return this.animations.play(t, e, i, s)
        }
    },
    t.Component.AutoCull = function() {},
    t.Component.AutoCull.prototype = {
        autoCull: !1,
        inCamera: {
            get: function() {
                return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y),
                this.game.world.camera.view.intersects(this._bounds)
            }
        }
    },
    t.Component.Bounds = function() {},
    t.Component.Bounds.prototype = {
        offsetX: {
            get: function() {
                return this.anchor.x * this.width
            }
        },
        offsetY: {
            get: function() {
                return this.anchor.y * this.height
            }
        },
        centerX: {
            get: function() {
                return this.x - this.offsetX + .5 * this.width
            },
            set: function(t) {
                this.x = t + this.offsetX - .5 * this.width
            }
        },
        centerY: {
            get: function() {
                return this.y - this.offsetY + .5 * this.height
            },
            set: function(t) {
                this.y = t + this.offsetY - .5 * this.height
            }
        },
        left: {
            get: function() {
                return this.x - this.offsetX
            },
            set: function(t) {
                this.x = t + this.offsetX
            }
        },
        right: {
            get: function() {
                return this.x + this.width - this.offsetX
            },
            set: function(t) {
                this.x = t - this.width + this.offsetX
            }
        },
        top: {
            get: function() {
                return this.y - this.offsetY
            },
            set: function(t) {
                this.y = t + this.offsetY
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height - this.offsetY
            },
            set: function(t) {
                this.y = t - this.height + this.offsetY
            }
        },
        alignIn: function(e, i, s, n) {
            switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
            default:
            case t.TOP_LEFT:
                this.left = e.left - s,
                this.top = e.top - n;
                break;
            case t.TOP_CENTER:
                this.centerX = e.centerX + s,
                this.top = e.top - n;
                break;
            case t.TOP_RIGHT:
                this.right = e.right + s,
                this.top = e.top - n;
                break;
            case t.LEFT_CENTER:
                this.left = e.left - s,
                this.centerY = e.centerY + n;
                break;
            case t.CENTER:
                this.centerX = e.centerX + s,
                this.centerY = e.centerY + n;
                break;
            case t.RIGHT_CENTER:
                this.right = e.right + s,
                this.centerY = e.centerY + n;
                break;
            case t.BOTTOM_LEFT:
                this.left = e.left - s,
                this.bottom = e.bottom + n;
                break;
            case t.BOTTOM_CENTER:
                this.centerX = e.centerX + s,
                this.bottom = e.bottom + n;
                break;
            case t.BOTTOM_RIGHT:
                this.right = e.right + s,
                this.bottom = e.bottom + n
            }
            return this
        },
        alignTo: function(e, i, s, n) {
            switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
            default:
            case t.TOP_LEFT:
                this.left = e.left - s,
                this.bottom = e.top - n;
                break;
            case t.TOP_CENTER:
                this.centerX = e.centerX + s,
                this.bottom = e.top - n;
                break;
            case t.TOP_RIGHT:
                this.right = e.right + s,
                this.bottom = e.top - n;
                break;
            case t.LEFT_TOP:
                this.right = e.left - s,
                this.top = e.top - n;
                break;
            case t.LEFT_CENTER:
                this.right = e.left - s,
                this.centerY = e.centerY + n;
                break;
            case t.LEFT_BOTTOM:
                this.right = e.left - s,
                this.bottom = e.bottom + n;
                break;
            case t.RIGHT_TOP:
                this.left = e.right + s,
                this.top = e.top - n;
                break;
            case t.RIGHT_CENTER:
                this.left = e.right + s,
                this.centerY = e.centerY + n;
                break;
            case t.RIGHT_BOTTOM:
                this.left = e.right + s,
                this.bottom = e.bottom + n;
                break;
            case t.BOTTOM_LEFT:
                this.left = e.left - s,
                this.top = e.bottom + n;
                break;
            case t.BOTTOM_CENTER:
                this.centerX = e.centerX + s,
                this.top = e.bottom + n;
                break;
            case t.BOTTOM_RIGHT:
                this.right = e.right + s,
                this.top = e.bottom + n
            }
            return this
        }
    },
    t.Group.prototype.alignIn = t.Component.Bounds.prototype.alignIn, t.Group.prototype.alignTo = t.Component.Bounds.prototype.alignTo, t.Component.BringToTop = function() {},
    t.Component.BringToTop.prototype.bringToTop = function() {
        return this.parent && this.parent.bringChildToTop && this.parent.bringChildToTop(this),
        this
    },
    t.Component.BringToTop.prototype.sendToBack = function() {
        return this.parent && this.parent.sendChildToBack && this.parent.sendChildToBack(this),
        this
    },
    t.Component.BringToTop.prototype.moveUp = function() {
        return this.parent && this.parent.moveUp(this),
        this
    },
    t.Component.BringToTop.prototype.moveDown = function() {
        return this.parent && this.parent.moveDown(this),
        this
    },
    t.Component.Core = function() {},
    t.Component.Core.skipTypeChecks = !1, t.Component.Core.install = function(e) {
        t.Utils.mixinPrototype(this, t.Component.Core.prototype),
        this.components = {};
        for (var i = 0; i < e.length; i++) {
            var s = e[i],
            n = !1;
            "Destroy" === s && (n = !0),
            t.Utils.mixinPrototype(this, t.Component[s].prototype, n),
            this.components[s] = !0
        }
    },
    t.Component.Core.init = function(e, i, s, n, r) {
        if (!t.Component.Core.skipTypeChecks) {
            if (! (e instanceof t.Game)) throw new Error("The value passed as the `game` argument (" + e + ") is not an instance of Phaser.Game.");
            "number" != typeof i && (console.warn("The `x` argument value (%s) should be a number.", i), i = 0),
            "number" != typeof s && (console.warn("The `y` argument value (%s) should be a number.", s), s = 0)
        }
        this.game = e,
        this.key = n,
        this.data = {},
        this.position.set(i, s),
        this.world = new t.Point(i, s),
        this.previousPosition = new t.Point(i, s),
        this.events = new t.Events(this),
        this._bounds = new t.Rectangle,
        this.components.PhysicsBody && (this.body = this.body),
        this.components.Animation && (this.animations = new t.AnimationManager(this)),
        this.components.LoadTexture && null !== n && this.loadTexture(n, r),
        this.components.FixedToCamera && (this.cameraOffset = new t.Point(i, s))
    },
    t.Component.Core.preUpdate = function() {
        return this.pendingDestroy ? (this.destroy(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), !0) : (this.renderOrderID = -1, !1))
    },
    t.Component.Core.prototype = {
        game: null,
        name: "",
        data: {},
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
            get: function() {
                return this._exists
            },
            set: function(e) {
                e ? (this._exists = !0, this.body && this.body.type === t.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === t.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
            }
        },
        preUpdateChildren: function() {
            for (var t = 0; t < this.children.length;) {
                var e = this.children[t];
                e.preUpdate(),
                this === e.parent && t++
            }
        },
        update: function() {},
        postUpdate: function() {
            this.customRender && this.key.render(),
            this.components.PhysicsBody && t.Component.PhysicsBody.postUpdate.call(this),
            this.components.FixedToCamera && t.Component.FixedToCamera.postUpdate.call(this);
            for (var e = 0; e < this.children.length; e++) this.children[e].postUpdate()
        }
    },
    t.Component.Crop = function() {},
    t.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function(e, i) {
            void 0 === i && (i = !1),
            e ? (i && null !== this.cropRect ? this.cropRect.setTo(e.x, e.y, e.width, e.height) : i && null === this.cropRect ? this.cropRect = new t.Rectangle(e.x, e.y, e.width, e.height) : this.cropRect = e, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
        },
        updateCrop: function() {
            if (this.cropRect) {
                var e = this.texture.crop.x,
                i = this.texture.crop.y,
                s = this.texture.crop.width,
                n = this.texture.crop.height;
                this._crop = t.Rectangle.clone(this.cropRect, this._crop),
                this._crop.x += this._frame.x,
                this._crop.y += this._frame.y;
                var r = Math.max(this._frame.x, this._crop.x),
                o = Math.max(this._frame.y, this._crop.y),
                a = Math.min(this._frame.right, this._crop.right) - r,
                h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                this.texture.crop.x = r,
                this.texture.crop.y = o,
                this.texture.crop.width = a,
                this.texture.crop.height = h,
                this.texture.frame.width = Math.min(a, this.cropRect.width),
                this.texture.frame.height = Math.min(h, this.cropRect.height),
                this.texture.width = this.texture.frame.width,
                this.texture.height = this.texture.frame.height,
                this.texture._updateUvs(),
                16777215 === this.tint || e === r && i === o && s === a && n === h || (this.texture.requiresReTint = !0)
            }
        }
    },
    t.Component.Delta = function() {},
    t.Component.Delta.prototype = {
        deltaX: {
            get: function() {
                return this.world.x - this.previousPosition.x
            }
        },
        deltaY: {
            get: function() {
                return this.world.y - this.previousPosition.y
            }
        },
        deltaZ: {
            get: function() {
                return this.rotation - this.previousRotation
            }
        }
    },
    t.Component.Destroy = function() {},
    t.Component.Destroy.prototype = {
        destroyPhase: !1,
        destroy: function(e, i) {
            if (null !== this.game && !this.destroyPhase) {
                void 0 === e && (e = !0),
                void 0 === i && (i = !1),
                this.destroyPhase = !0,
                this.events && this.events.onDestroy$dispatch(this),
                this.parent && (this.parent instanceof t.Group ? this.parent.remove(this) : this.parent.removeChild(this)),
                this.input && this.input.destroy(),
                this.animations && this.animations.destroy(),
                this.body && this.body.destroy(),
                this.events && this.events.destroy(),
                this.game.tweens.removeFrom(this);
                var s = this.children.length;
                if (e) for (; s--;) this.children[s].destroy(e);
                else for (; s--;) this.removeChild(this.children[s]);
                this._crop && (this._crop = null, this.cropRect = null),
                this._frame && (this._frame = null),
                t.Video && this.key instanceof t.Video && this.key.onChangeSource.remove(this.resizeFrame, this),
                t.BitmapText && this._glyphs && (this._glyphs = []),
                this.alive = !1,
                this.exists = !1,
                this.visible = !1,
                this.filters = null,
                this.mask = null,
                this.game = null,
                this.data = {},
                this.renderable = !1,
                this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null),
                this.hitArea = null,
                this.parent = null,
                this.stage = null,
                this.worldTransform = null,
                this.filterArea = null,
                this._bounds = null,
                this._currentBounds = null,
                this._mask = null,
                this._destroyCachedSprite(),
                i && this.texture.destroy(!0),
                this.destroyPhase = !1,
                this.pendingDestroy = !1
            }
        }
    },
    t.Events = function(t) {
        this.parent = t
    },
    t.Events.prototype = {
        destroy: function() {
            this._parent = null,
            this._onDestroy && this._onDestroy.dispose(),
            this._onAddedToGroup && this._onAddedToGroup.dispose(),
            this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(),
            this._onKilled && this._onKilled.dispose(),
            this._onRevived && this._onRevived.dispose(),
            this._onEnterBounds && this._onEnterBounds.dispose(),
            this._onOutOfBounds && this._onOutOfBounds.dispose(),
            this._onInputOver && this._onInputOver.dispose(),
            this._onInputOut && this._onInputOut.dispose(),
            this._onInputDown && this._onInputDown.dispose(),
            this._onInputUp && this._onInputUp.dispose(),
            this._onDragStart && this._onDragStart.dispose(),
            this._onDragUpdate && this._onDragUpdate.dispose(),
            this._onDragStop && this._onDragStop.dispose(),
            this._onAnimationStart && this._onAnimationStart.dispose(),
            this._onAnimationComplete && this._onAnimationComplete.dispose(),
            this._onAnimationLoop && this._onAnimationLoop.dispose()
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    },
    t.Events.prototype.constructor = t.Events, t.Events.prototype) t.Events.prototype.hasOwnProperty(s) && 0 === s.indexOf("on") && null === t.Events.prototype[s] &&
    function(e, i) {
        "use strict";
        Object.defineProperty(t.Events.prototype, e, {
            get: function() {
                return this[i] || (this[i] = new t.Signal)
            }
        }),
        t.Events.prototype[e + "$dispatch"] = function() {
            return this[i] ? this[i].dispatch.apply(this[i], arguments) : null
        }
    } (s, "_" + s);
    return t.Component.FixedToCamera = function() {},
    t.Component.FixedToCamera.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    },
    t.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1,
        fixedToCamera: {
            get: function() {
                return this._fixedToCamera
            },
            set: function(t) {
                t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
            }
        },
        cameraOffset: new t.Point
    },
    t.Component.Health = function() {},
    t.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function(t) {
            return this.alive && (this.health -= t, this.health <= 0 && this.kill()),
            this
        },
        setHealth: function(t) {
            return this.health = t,
            this.health > this.maxHealth && (this.health = this.maxHealth),
            this
        },
        heal: function(t) {
            return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)),
            this
        }
    },
    t.Component.InCamera = function() {},
    t.Component.InCamera.prototype = {
        inCamera: {
            get: function() {
                return this.game.world.camera.view.intersects(this._bounds)
            }
        }
    },
    t.Component.InputEnabled = function() {},
    t.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
            get: function() {
                return this.input && this.input.enabled
            },
            set: function(e) {
                e ? null === this.input ? (this.input = new t.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
            }
        }
    },
    t.Component.InWorld = function() {},
    t.Component.InWorld.preUpdate = function() {
        if (this.pendingDestroy) return this.destroy(),
        !1;
        if (this.autoCull || this.checkWorldBounds) {
            if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull) if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0,
            this.game.world.camera.totalInView++;
            else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(),
            !1;
            if (this.checkWorldBounds) if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1,
            this.events.onEnterBounds$dispatch(this);
            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(),
            !1
        }
        return ! 0
    },
    t.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        outOfCameraBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
            get: function() {
                return this.game.world.bounds.intersects(this.getBounds())
            }
        }
    },
    t.Component.LifeSpan = function() {},
    t.Component.LifeSpan.preUpdate = function() {
        return this.pendingDestroy ? (this.destroy(), !1) : !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1))
    },
    t.Component.LifeSpan.prototype = {
        alive: !0,
        lifespan: 0,
        revive: function(t) {
            return void 0 === t && (t = 100),
            this.alive = !0,
            this.exists = !0,
            this.visible = !0,
            "function" == typeof this.setHealth && this.setHealth(t),
            this.events && this.events.onRevived$dispatch(this),
            this
        },
        kill: function() {
            return this.alive = !1,
            this.exists = !1,
            this.visible = !1,
            this.events && this.events.onKilled$dispatch(this),
            this
        }
    },
    t.Component.LoadTexture = function() {},
    t.Component.LoadTexture.prototype = {
        customRender: !1,
        _frame: null,
        loadTexture: function(e, i, s) {
            e === t.PENDING_ATLAS ? (e = i, i = 0) : i = i || 0,
            (s || void 0 === s) && this.animations && this.animations.stop(),
            this.key = e,
            this.customRender = !1;
            var n = this.game.cache,
            r = !0,
            o = !this.texture.baseTexture.scaleMode;
            if (t.RenderTexture && e instanceof t.RenderTexture) this.key = e.key,
            this.setTexture(e);
            else if (t.BitmapData && e instanceof t.BitmapData) this.customRender = !0,
            this.setTexture(e.texture),
            r = n.hasFrameData(e.key, t.Cache.BITMAPDATA) ? !this.animations.loadFrameData(n.getFrameData(e.key, t.Cache.BITMAPDATA), i) : !this.animations.loadFrameData(e.frameData, 0);
            else if (t.Video && e instanceof t.Video) {
                this.customRender = !0;
                var a = e.texture.valid;
                this.setTexture(e.texture),
                this.setFrame(e.texture.frame.clone()),
                e.onChangeSource.add(this.resizeFrame, this),
                this.texture.valid = a
            } else if (t.Tilemap && e instanceof t.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(e.canvas));
            else if (e instanceof PIXI.Texture) this.setTexture(e);
            else {
                var h = n.getImage(e, !0);
                this.key = h.key,
                this.setTexture(new PIXI.Texture(h.base)),
                this.texture.baseTexture.skipRender = "__default" === e,
                r = !this.animations.loadFrameData(h.frameData, i)
            }
            r && (this._frame = t.Rectangle.clone(this.texture.frame)),
            o || (this.texture.baseTexture.scaleMode = 1)
        },
        setFrame: function(t) {
            this._frame = t,
            this.texture.frame.x = t.x,
            this.texture.frame.y = t.y,
            this.texture.frame.width = t.width,
            this.texture.frame.height = t.height,
            this.texture.crop.x = t.x,
            this.texture.crop.y = t.y,
            this.texture.crop.width = t.width,
            this.texture.crop.height = t.height,
            t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                x: t.spriteSourceSizeX,
                y: t.spriteSourceSizeY,
                width: t.sourceSizeW,
                height: t.sourceSizeH
            },
            this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null),
            t.rotated && (this.texture.rotated = !0),
            this.cropRect && this.updateCrop(),
            this.texture.requiresReTint = !0,
            this.texture._updateUvs(),
            this.tilingTexture && (this.refreshTexture = !0)
        },
        resizeFrame: function(t, e, i) {
            this.texture.frame.resize(e, i),
            this.texture.setFrame(this.texture.frame)
        },
        resetFrame: function() {
            this._frame && this.setFrame(this._frame)
        },
        frame: {
            get: function() {
                return this.animations.frame
            },
            set: function(t) {
                this.animations.frame = t
            }
        },
        frameName: {
            get: function() {
                return this.animations.frameName
            },
            set: function(t) {
                this.animations.frameName = t
            }
        }
    },
    t.Component.Overlap = function() {},
    t.Component.Overlap.prototype = {
        overlap: function(e) {
            return t.Rectangle.intersects(this.getBounds(), e.getBounds())
        }
    },
    t.Component.PhysicsBody = function() {},
    t.Component.PhysicsBody.preUpdate = function() {
        return this.pendingDestroy ? (this.destroy(), !1) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, this.preUpdateChildren(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
    },
    t.Component.PhysicsBody.postUpdate = function() {
        this.exists && this.body && this.body.postUpdate()
    },
    t.Component.PhysicsBody.prototype = {
        body: null,
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t,
                this.body && !this.body.dirty && (this.body._reset = !0)
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t,
                this.body && !this.body.dirty && (this.body._reset = !0)
            }
        }
    },
    t.Component.Reset = function() {},
    t.Component.Reset.prototype.reset = function(t, e, i) {
        return void 0 === i && (i = 1),
        this.world.set(t, e),
        this.position.set(t, e),
        this.fresh = !0,
        this.exists = !0,
        this.visible = !0,
        this.renderable = !0,
        this.components.InWorld && (this._outOfBoundsFired = !1),
        this.components.LifeSpan && (this.alive = !0, this.health = i),
        this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1),
        this
    },
    t.Component.ScaleMinMax = function() {},
    t.Component.ScaleMinMax.prototype = {
        transformCallback: null,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function(t) {
            this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)),
            this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
        },
        setScaleMinMax: function(e, i, s, n) {
            void 0 === i ? i = s = n = e: void 0 === s && (s = n = i, i = e),
            null === e ? this.scaleMin = null: this.scaleMin ? this.scaleMin.set(e, i) : this.scaleMin = new t.Point(e, i),
            null === s ? this.scaleMax = null: this.scaleMax ? this.scaleMax.set(s, n) : this.scaleMax = new t.Point(s, n),
            null === this.scaleMin ? this.transformCallback = null: (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
        }
    },
    t.Component.Smoothed = function() {},
    t.Component.Smoothed.prototype = {
        smoothed: {
            get: function() {
                return ! this.texture.baseTexture.scaleMode
            },
            set: function(t) {
                t ? this.texture && (this.texture.baseTexture.scaleMode = 0, this.texture.baseTexture.dirty()) : this.texture && (this.texture.baseTexture.scaleMode = 1, this.texture.baseTexture.dirty())
            }
        }
    },
    t.GameObjectFactory = function(t) {
        this.game = t,
        this.world = this.game.world
    },
    t.GameObjectFactory.prototype = {
        existing: function(t) {
            return this.world.add(t)
        },
        weapon: function(e, i, s, n, r) {
            var o = this.game.plugins.add(t.Weapon);
            return r && (o.bulletClass = r),
            o.createBullets(e, i, s, n),
            o
        },
        image: function(e, i, s, n, r) {
            return void 0 === r && (r = this.world),
            r.add(new t.Image(this.game, e, i, s, n))
        },
        sprite: function(e, i, s, n, r) {
            return void 0 === r && (r = this.world),
            r.add(new t.Sprite(this.game, e, i, s, n))
        },
        creature: function(e, i, s, n, r, o, a) {
            void 0 === r && (r = this.world);
            var h = new t.Creature(this.game, e, i, s, n, o, a);
            return r.add(h),
            h
        },
        tween: function(t) {
            return this.game.tweens.create(t)
        },
        group: function(e, i, s, n, r) {
            return new t.Group(this.game, e, i, s, n, r)
        },
        physicsGroup: function(e, i, s, n) {
            return new t.Group(this.game, i, s, n, !0, e)
        },
        spriteBatch: function(e, i, s) {
            return void 0 === e && (e = null),
            void 0 === i && (i = "group"),
            void 0 === s && (s = !1),
            new t.SpriteBatch(this.game, e, i, s)
        },
        audio: function(t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        },
        sound: function(t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        },
        audioSprite: function(t) {
            return this.game.sound.addSprite(t)
        },
        tileSprite: function(e, i, s, n, r, o, a) {
            return void 0 === a && (a = this.world),
            a.add(new t.TileSprite(this.game, e, i, s, n, r, o))
        },
        rope: function(e, i, s, n, r, o) {
            return void 0 === o && (o = this.world),
            o.add(new t.Rope(this.game, e, i, s, n, r))
        },
        text: function(e, i, s, n, r) {
            return void 0 === r && (r = this.world),
            r.add(new t.Text(this.game, e, i, s, n))
        },
        button: function(e, i, s, n, r, o, a, h, l, c) {
            return void 0 === c && (c = this.world),
            c.add(new t.Button(this.game, e, i, s, n, r, o, a, h, l))
        },
        graphics: function(e, i, s) {
            return void 0 === s && (s = this.world),
            s.add(new t.Graphics(this.game, e, i))
        },
        emitter: function(e, i, s) {
            return this.game.particles.add(new t.Particles.Arcade.Emitter(this.game, e, i, s))
        },
        retroFont: function(e, i, s, n, r, o, a, h, l) {
            return new t.RetroFont(this.game, e, i, s, n, r, o, a, h, l)
        },
        bitmapText: function(e, i, s, n, r, o) {
            return void 0 === o && (o = this.world),
            o.add(new t.BitmapText(this.game, e, i, s, n, r))
        },
        tilemap: function(e, i, s, n, r) {
            return new t.Tilemap(this.game, e, i, s, n, r)
        },
        renderTexture: function(e, i, s, n) {
            void 0 !== s && "" !== s || (s = this.game.rnd.uuid()),
            void 0 === n && (n = !1);
            var r = new t.RenderTexture(this.game, e, i, s);
            return n && this.game.cache.addRenderTexture(s, r),
            r
        },
        video: function(e, i) {
            return new t.Video(this.game, e, i)
        },
        bitmapData: function(e, i, s, n) {
            void 0 === n && (n = !1),
            void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
            var r = new t.BitmapData(this.game, s, e, i);
            return n && this.game.cache.addBitmapData(s, r),
            r
        },
        filter: function(e) {
            var i = Array.prototype.slice.call(arguments, 1);
            return (e = new t.Filter[e](this.game)).init.apply(e, i),
            e
        },
        plugin: function() {
            return this.game.plugins.add.apply(this.game.plugins, arguments)
        }
    },
    t.GameObjectFactory.prototype.constructor = t.GameObjectFactory,
    t.GameObjectCreator = function(t) {
        this.game = t,
        this.world = this.game.world
    },
    t.GameObjectCreator.prototype = {
        image: function(e, i, s, n) {
            return new t.Image(this.game, e, i, s, n)
        },
        sprite: function(e, i, s, n) {
            return new t.Sprite(this.game, e, i, s, n)
        },
        tween: function(e) {
            return new t.Tween(e, this.game, this.game.tweens)
        },
        group: function(e, i, s, n, r) {
            return new t.Group(this.game, e || null, i, s, n, r)
        },
        spriteBatch: function(e, i, s) {
            return void 0 === i && (i = "group"),
            void 0 === s && (s = !1),
            new t.SpriteBatch(this.game, e, i, s)
        },
        audio: function(t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        },
        audioSprite: function(t) {
            return this.game.sound.addSprite(t)
        },
        sound: function(t, e, i, s) {
            return this.game.sound.add(t, e, i, s)
        },
        tileSprite: function(e, i, s, n, r, o) {
            return new t.TileSprite(this.game, e, i, s, n, r, o)
        },
        rope: function(e, i, s, n, r) {
            return new t.Rope(this.game, e, i, s, n, r)
        },
        text: function(e, i, s, n) {
            return new t.Text(this.game, e, i, s, n)
        },
        button: function(e, i, s, n, r, o, a, h, l) {
            return new t.Button(this.game, e, i, s, n, r, o, a, h, l)
        },
        graphics: function(e, i) {
            return new t.Graphics(this.game, e, i)
        },
        emitter: function(e, i, s) {
            return new t.Particles.Arcade.Emitter(this.game, e, i, s)
        },
        retroFont: function(e, i, s, n, r, o, a, h, l) {
            return new t.RetroFont(this.game, e, i, s, n, r, o, a, h, l)
        },
        bitmapText: function(e, i, s, n, r, o) {
            return new t.BitmapText(this.game, e, i, s, n, r, o)
        },
        tilemap: function(e, i, s, n, r) {
            return new t.Tilemap(this.game, e, i, s, n, r)
        },
        renderTexture: function(e, i, s, n) {
            void 0 !== s && "" !== s || (s = this.game.rnd.uuid()),
            void 0 === n && (n = !1);
            var r = new t.RenderTexture(this.game, e, i, s);
            return n && this.game.cache.addRenderTexture(s, r),
            r
        },
        bitmapData: function(e, i, s, n) {
            void 0 === n && (n = !1),
            void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
            var r = new t.BitmapData(this.game, s, e, i);
            return n && this.game.cache.addBitmapData(s, r),
            r
        },
        filter: function(e) {
            var i = Array.prototype.slice.call(arguments, 1);
            return (e = new t.Filter[e](this.game)).init.apply(e, i),
            e
        }
    },
    t.GameObjectCreator.prototype.constructor = t.GameObjectCreator,
    t.Sprite = function(e, i, s, n, r) {
        i = i || 0,
        s = s || 0,
        n = n || null,
        r = r || null,
        this.type = t.SPRITE,
        this.physicsType = t.SPRITE,
        PIXI.Sprite.call(this, t.Cache.DEFAULT),
        t.Component.Core.init.call(this, e, i, s, n, r)
    },
    t.Sprite.prototype = Object.create(PIXI.Sprite.prototype),
    t.Sprite.prototype.constructor = t.Sprite,
    t.Component.Core.install.call(t.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
    t.Sprite.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate,
    t.Sprite.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.Sprite.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.Sprite.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.Sprite.prototype.preUpdate = function() {
        return !! (this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.Image = function(e, i, s, n, r) {
        i = i || 0,
        s = s || 0,
        n = n || null,
        r = r || null,
        this.type = t.IMAGE,
        PIXI.Sprite.call(this, t.Cache.DEFAULT),
        t.Component.Core.init.call(this, e, i, s, n, r)
    },
    t.Image.prototype = Object.create(PIXI.Sprite.prototype),
    t.Image.prototype.constructor = t.Image,
    t.Component.Core.install.call(t.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]),
    t.Image.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.Image.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.Image.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.Image.prototype.preUpdate = function() {
        return ! (!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
    },
    t.Button = function(e, i, s, n, r, o, a, h, l, c) {
        i = i || 0,
        s = s || 0,
        n = n || null,
        r = r || null,
        o = o || this,
        t.Image.call(this, e, i, s, n, h),
        this.type = t.BUTTON,
        this.physicsType = t.SPRITE,
        this._onOverFrame = null,
        this._onOutFrame = null,
        this._onDownFrame = null,
        this._onUpFrame = null,
        this.onOverSound = null,
        this.onOutSound = null,
        this.onDownSound = null,
        this.onUpSound = null,
        this.onOverSoundMarker = "",
        this.onOutSoundMarker = "",
        this.onDownSoundMarker = "",
        this.onUpSoundMarker = "",
        this.onInputOver = new t.Signal,
        this.onInputOut = new t.Signal,
        this.onInputDown = new t.Signal,
        this.onInputUp = new t.Signal,
        this.onOverMouseOnly = !0,
        this.justReleasedPreventsOver = t.PointerMode.CONTACT,
        this.freezeFrames = !1,
        this.forceOut = !1,
        this.inputEnabled = !0,
        this.input.start(0, !0),
        this.input.useHandCursor = !0,
        this.setFrames(a, h, l, c),
        null !== r && this.onInputUp.add(r, o),
        this.events.onInputOver.add(this.onInputOverHandler, this),
        this.events.onInputOut.add(this.onInputOutHandler, this),
        this.events.onInputDown.add(this.onInputDownHandler, this),
        this.events.onInputUp.add(this.onInputUpHandler, this)
    },
    t.Button.prototype = Object.create(t.Image.prototype),
    t.Button.prototype.constructor = t.Button,
    t.Button.prototype.clearFrames = function() {
        this.setFrames(null, null, null, null)
    },
    t.Button.prototype.setStateFrame = function(t, e, i) {
        var s = "_on" + t + "Frame";
        null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
    },
    t.Button.prototype.changeStateFrame = function(t) {
        if (this.freezeFrames) return ! 1;
        var e = this["_on" + t + "Frame"];
        return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
    },
    t.Button.prototype.setFrames = function(t, e, i, s) {
        this.setStateFrame("Over", t, this.input.pointerOver()),
        this.setStateFrame("Out", e, !this.input.pointerOver()),
        this.setStateFrame("Down", i, this.input.pointerDown()),
        this.setStateFrame("Up", s, this.input.pointerUp())
    },
    t.Button.prototype.setStateSound = function(e, i, s) {
        var n = "on" + e + "Sound",
        r = "on" + e + "SoundMarker";
        i instanceof t.Sound || i instanceof t.AudioSprite ? (this[n] = i, this[r] = "string" == typeof s ? s: "") : (this[n] = null, this[r] = "")
    },
    t.Button.prototype.playStateSound = function(t) {
        var e = this["on" + t + "Sound"];
        if (e) {
            var i = this["on" + t + "SoundMarker"];
            return e.play(i),
            !0
        }
        return ! 1
    },
    t.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
        this.setStateSound("Over", t, e),
        this.setStateSound("Out", n, r),
        this.setStateSound("Down", i, s),
        this.setStateSound("Up", o, a)
    },
    t.Button.prototype.setOverSound = function(t, e) {
        this.setStateSound("Over", t, e)
    },
    t.Button.prototype.setOutSound = function(t, e) {
        this.setStateSound("Out", t, e)
    },
    t.Button.prototype.setDownSound = function(t, e) {
        this.setStateSound("Down", t, e)
    },
    t.Button.prototype.setUpSound = function(t, e) {
        this.setStateSound("Up", t, e)
    },
    t.Button.prototype.onInputOverHandler = function(t, e) {
        e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
    },
    t.Button.prototype.onInputOutHandler = function(t, e) {
        this.changeStateFrame("Out"),
        this.playStateSound("Out"),
        this.onInputOut && this.onInputOut.dispatch(this, e)
    },
    t.Button.prototype.onInputDownHandler = function(t, e) {
        this.changeStateFrame("Down"),
        this.playStateSound("Down"),
        this.onInputDown && this.onInputDown.dispatch(this, e)
    },
    t.Button.prototype.onInputUpHandler = function(t, e, i) {
        this.playStateSound("Up"),
        this.onInputUp && this.onInputUp.dispatch(this, e, i),
        this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
    },
    t.SpriteBatch = function(e, i, s, n) {
        null != i || (i = e.world),
        t.Group.call(this, e, i, s, n),
        this.type = t.SPRITEBATCH,
        this.fastSpriteBatch = null,
        this.ready = !1
    },
    t.SpriteBatch.prototype = Object.create(t.Group.prototype),
    t.SpriteBatch.prototype.constructor = t.SpriteBatch,
    t.SpriteBatch.prototype._renderWebGL = function(t) { ! this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl), this.ready = !0), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
    },
    t.SpriteBatch.prototype._renderCanvas = function(t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha,
            this.displayObjectUpdateTransform();
            for (var i = this.worldTransform,
            s = !0,
            n = 0; n < this.children.length; n++) {
                var r = this.children[n];
                if (r.visible) {
                    var o = r.texture,
                    a = o.frame;
                    if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1),
                    e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * ( - a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * ( - a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                    else {
                        s || (s = !0),
                        r.displayObjectUpdateTransform();
                        var h = r.worldTransform,
                        l = h.tx * t.resolution + t.shakeX,
                        c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c),
                        e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                    }
                }
            }
        }
    },
    t.BitmapData = function(e, i, s, n, r) {
        void 0 !== s && 0 !== s || (s = 256),
        void 0 !== n && 0 !== n || (n = 256),
        void 0 === r && (r = !1),
        this.game = e,
        this.key = i,
        this.width = s,
        this.height = n,
        this.canvas = t.Canvas.create(this, s, n, null, r),
        this.context = this.canvas.getContext("2d", {
            alpha: !0
        }),
        this.ctx = this.context,
        this.smoothProperty = e.renderType === t.CANVAS ? e.renderer.renderSession.smoothProperty: t.Canvas.getSmoothingPrefix(this.context),
        this.imageData = this.context.getImageData(0, 0, s, n),
        this.data = null,
        this.imageData && (this.data = this.imageData.data),
        this.pixels = null,
        this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data),
        this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution),
        this.texture = new PIXI.Texture(this.baseTexture),
        this.frameData = new t.FrameData,
        this.textureFrame = this.frameData.addFrame(new t.Frame(0, 0, 0, s, n, "bitmapData")),
        this.texture.frame = this.textureFrame,
        this.type = t.BITMAPDATA,
        this.disableTextureUpload = !1,
        this.dirty = !1,
        this.cls = this.clear,
        this._image = null,
        this._pos = new t.Point,
        this._size = new t.Point,
        this._scale = new t.Point,
        this._rotate = 0,
        this._alpha = {
            prev: 1,
            current: 1
        },
        this._anchor = new t.Point,
        this._tempR = 0,
        this._tempG = 0,
        this._tempB = 0,
        this._circle = new t.Circle,
        this._swapCanvas = void 0
    },
    t.BitmapData.prototype = {
        move: function(t, e, i) {
            return 0 !== t && this.moveH(t, i),
            0 !== e && this.moveV(e, i),
            this
        },
        moveH: function(e, i) {
            void 0 === i && (i = !0),
            void 0 === this._swapCanvas && (this._swapCanvas = t.CanvasPool.create(this, this.width, this.height));
            var s = this._swapCanvas.getContext("2d"),
            n = this.height,
            r = this.canvas;
            if (s.clearRect(0, 0, this.width, this.height), e < 0) e = Math.abs(e),
            o = this.width - e,
            i && s.drawImage(r, 0, 0, e, n, o, 0, e, n),
            s.drawImage(r, e, 0, o, n, 0, 0, o, n);
            else {
                var o = this.width - e;
                i && s.drawImage(r, o, 0, e, n, 0, 0, e, n),
                s.drawImage(r, 0, 0, o, n, e, 0, o, n)
            }
            return this.clear(),
            this.copy(this._swapCanvas)
        },
        moveV: function(e, i) {
            void 0 === i && (i = !0),
            void 0 === this._swapCanvas && (this._swapCanvas = t.CanvasPool.create(this, this.width, this.height));
            var s = this._swapCanvas.getContext("2d"),
            n = this.width,
            r = this.canvas;
            if (s.clearRect(0, 0, this.width, this.height), e < 0) e = Math.abs(e),
            o = this.height - e,
            i && s.drawImage(r, 0, 0, n, e, 0, o, n, e),
            s.drawImage(r, 0, e, n, o, 0, 0, n, o);
            else {
                var o = this.height - e;
                i && s.drawImage(r, 0, o, n, e, 0, 0, n, e),
                s.drawImage(r, 0, 0, n, o, 0, e, n, o)
            }
            return this.clear(),
            this.copy(this._swapCanvas)
        },
        add: function(t) {
            if (Array.isArray(t)) for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
            else t.loadTexture(this);
            return this
        },
        load: function(t) {
            if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height),
            this.cls(),
            this.draw(t),
            this.update(),
            this
        },
        clear: function(t, e, i, s) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            void 0 === i && (i = this.width),
            void 0 === s && (s = this.height),
            this.context.clearRect(t, e, i, s),
            this.dirty = !0,
            this
        },
        fill: function(t, e, i, s) {
            return void 0 === s && (s = 1),
            this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")",
            this.context.fillRect(0, 0, this.width, this.height),
            this.dirty = !0,
            this
        },
        generateTexture: function(t, e, i) {
            var s = this.game.cache,
            n = new Image;
            if (e && (n.onload = function() {
                var r = s.addImage(t, "", n),
                o = new PIXI.Texture(r.base);
                e.call(i || null, o),
                n.onload = null
            }), n.src = this.canvas.toDataURL("image/png"), !e) {
                var r = s.addImage(t, "", n);
                return new PIXI.Texture(r.base)
            }
            return null
        },
        resize: function(t, e) {
            return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0),
            this
        },
        update: function(t, e, i, s) {
            return void 0 === t && (t = 0),
            void 0 === e && (e = 0),
            void 0 === i && (i = Math.max(1, this.width)),
            void 0 === s && (s = Math.max(1, this.height)),
            this.imageData = this.context.getImageData(t, e, i, s),
            this.data = this.imageData.data,
            this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data,
            this
        },
        processPixelRGB: function(e, i, s, n, r, o) {
            void 0 === s && (s = 0),
            void 0 === n && (n = 0),
            void 0 === r && (r = this.width),
            void 0 === o && (o = this.height);
            for (var a = s + r,
            h = n + o,
            l = t.Color.createColor(), c = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            u = !1, d = n; d < h; d++) for (var p = s; p < a; p++) t.Color.unpackPixel(this.getPixel32(p, d), l),
            !1 !== (c = e.call(i, l, p, d)) && null != c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
            return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0),
            this
        },
        processPixel: function(t, e, i, s, n, r) {
            void 0 === i && (i = 0),
            void 0 === s && (s = 0),
            void 0 === n && (n = this.width),
            void 0 === r && (r = this.height);
            for (var o = i + n,
            a = s + r,
            h = 0,
            l = 0,
            c = !1,
            u = s; u < a; u++) for (var d = i; d < o; d++) h = this.getPixel32(d, u),
            (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l, c = !0);
            return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0),
            this
        },
        replaceRGB: function(e, i, s, n, r, o, a, h, l) {
            var c = 0,
            u = 0,
            d = this.width,
            p = this.height,
            f = t.Color.packPixel(e, i, s, n);
            void 0 !== l && l instanceof t.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
            for (var g = 0; g < p; g++) for (var m = 0; m < d; m++) this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
            return this.context.putImageData(this.imageData, 0, 0),
            this.dirty = !0,
            this
        },
        setHSL: function(e, i, s, n) {
            var r = e || 0 === e,
            o = i || 0 === i,
            a = s || 0 === s;
            if (r || o || a) {
                void 0 === n && (n = new t.Rectangle(0, 0, this.width, this.height));
                for (var h = t.Color.createColor(), l = n.y; l < n.bottom; l++) for (var c = n.x; c < n.right; c++) t.Color.unpackPixel(this.getPixel32(c, l), h, !0),
                r && (h.h = e),
                o && (h.s = i),
                a && (h.l = s),
                t.Color.HSLtoRGB(h.h, h.s, h.l, h),
                this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                return this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0,
                this
            }
        },
        shiftHSL: function(e, i, s, n) {
            if (null != e || (e = !1), null != i || (i = !1), null != s || (s = !1), e || i || s) {
                void 0 === n && (n = new t.Rectangle(0, 0, this.width, this.height));
                for (var r = t.Color.createColor(), o = n.y; o < n.bottom; o++) for (var a = n.x; a < n.right; a++) t.Color.unpackPixel(this.getPixel32(a, o), r, !0),
                e && (r.h = this.game.math.wrap(r.h + e, 0, 1)),
                i && (r.s = this.game.math.clamp(r.s + i, 0, 1)),
                s && (r.l = this.game.math.clamp(r.l + s, 0, 1)),
                t.Color.HSLtoRGB(r.h, r.s, r.l, r),
                this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                return this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0,
                this
            }
        },
        setPixel32: function(e, i, s, n, r, o, a) {
            return void 0 === a && (a = !0),
            e >= 0 && e <= this.width && i >= 0 && i <= this.height && (t.Device.LITTLE_ENDIAN ? this.pixels[i * this.width + e] = o << 24 | r << 16 | n << 8 | s: this.pixels[i * this.width + e] = s << 24 | n << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)),
            this
        },
        setPixel: function(t, e, i, s, n, r) {
            return this.setPixel32(t, e, i, s, n, 255, r)
        },
        getPixel: function(e, i, s) {
            s || (s = t.Color.createColor());
            var n = ~~ (e + i * this.width);
            return n *= 4,
            s.r = this.data[n],
            s.g = this.data[++n],
            s.b = this.data[++n],
            s.a = this.data[++n],
            s
        },
        getPixel32: function(t, e) {
            if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
        },
        getPixelRGB: function(e, i, s, n, r) {
            return t.Color.unpackPixel(this.getPixel32(e, i), s, n, r)
        },
        getPixels: function(t) {
            return this.context.getImageData(t.x, t.y, t.width, t.height)
        },
        getFirstPixel: function(e) {
            void 0 === e && (e = 0);
            var i = t.Color.createColor(),
            s = 0,
            n = 0,
            r = 1,
            o = !1;
            1 === e ? (r = -1, n = this.height) : 3 === e && (r = -1, s = this.width);
            do {
                t.Color.unpackPixel(this.getPixel32(s, n), i), 0 === e || 1 === e ? ++s === this.width && (s = 0, ((n += r) >= this.height || n <= 0) && (o = !0)) : 2 !== e && 3 !== e || ++n === this.height && (n = 0, ((s += r) >= this.width || s <= 0) && (o = !0))
            } while ( 0 === i . a && ! o );
            return i.x = s,
            i.y = n,
            i
        },
        getBounds: function(e) {
            return void 0 === e && (e = new t.Rectangle),
            e.x = this.getFirstPixel(2).x,
            e.x === this.width ? e.setTo(0, 0, 0, 0) : (e.y = this.getFirstPixel(0).y, e.width = this.getFirstPixel(3).x - e.x + 1, e.height = this.getFirstPixel(1).y - e.y + 1, e)
        },
        addToWorld: function(t, e, i, s, n, r) {
            n = n || 1,
            r = r || 1;
            var o = this.game.add.image(t, e, this);
            return o.anchor.set(i, s),
            o.scale.set(n, r),
            o
        },
        copy: function(e, i, s, n, r, o, a, h, l, c, u, d, p, f, g, m, y) {
            if (null != e || (e = this), e instanceof t.RenderTexture && (e = e.getCanvas()), this._image = e, e instanceof t.Sprite || e instanceof t.Image || e instanceof t.Text || e instanceof PIXI.Sprite) this._pos.set(e.texture.crop.x, e.texture.crop.y),
            this._size.set(e.texture.crop.width, e.texture.crop.height),
            this._scale.set(e.scale.x, e.scale.y),
            this._anchor.set(e.anchor.x, e.anchor.y),
            this._rotate = e.rotation,
            this._alpha.current = e.alpha,
            e.texture instanceof t.RenderTexture ? this._image = e.texture.getCanvas() : this._image = e.texture.baseTexture.source,
            null != o || (o = e.x),
            null != a || (a = e.y),
            e.texture.trim && (o += e.texture.trim.x - e.anchor.x * e.texture.trim.width, a += e.texture.trim.y - e.anchor.y * e.texture.trim.height),
            16777215 !== e.tint && (e.cachedTint !== e.tint && (e.cachedTint = e.tint, e.tintedTexture = PIXI.CanvasTinter.getTintedTexture(e, e.tint)), this._image = e.tintedTexture, this._pos.set(0));
            else {
                if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, e instanceof t.BitmapData) this._image = e.canvas;
                else if ("string" == typeof e) {
                    if (null === (e = this.game.cache.getImage(e))) return this;
                    this._image = e
                }
                this._size.set(this._image.width, this._image.height)
            }
            if (null != i || (i = 0), null != s || (s = 0), n && (this._size.x = n), r && (this._size.y = r), null != o || (o = i), null != a || (a = s), null != h || (h = this._size.x), null != l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y) return this;
            var v = this.context;
            return this._alpha.prev = v.globalAlpha,
            v.save(),
            v.globalAlpha = this._alpha.current,
            m && (this.op = m),
            y && (o |= 0, a |= 0),
            v.translate(o, a),
            v.scale(this._scale.x, this._scale.y),
            v.rotate(this._rotate),
            v.drawImage(this._image, this._pos.x + i, this._pos.y + s, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l),
            v.restore(),
            v.globalAlpha = this._alpha.prev,
            this.dirty = !0,
            this
        },
        copyTransform: function(e, i, s) {
            if (void 0 === i && (i = null), void 0 === s && (s = !1), !e.hasOwnProperty("worldTransform") || !e.worldVisible || 0 === e.worldAlpha) return this;
            var n = e.worldTransform;
            if (this._pos.set(e.texture.crop.x, e.texture.crop.y), this._size.set(e.texture.crop.width, e.texture.crop.height), 0 === n.a || 0 === n.d || 0 === this._size.x || 0 === this._size.y) return this;
            e.texture instanceof t.RenderTexture ? this._image = e.texture.getCanvas() : this._image = e.texture.baseTexture.source;
            var r = n.tx,
            o = n.ty;
            e.texture.trim && (r += e.texture.trim.x - e.anchor.x * e.texture.trim.width, o += e.texture.trim.y - e.anchor.y * e.texture.trim.height),
            16777215 !== e.tint && (e.cachedTint !== e.tint && (e.cachedTint = e.tint, e.tintedTexture = PIXI.CanvasTinter.getTintedTexture(e, e.tint)), this._image = e.tintedTexture, this._pos.set(0)),
            s && (r |= 0, o |= 0);
            var a = this.context;
            return this._alpha.prev = a.globalAlpha,
            a.save(),
            a.globalAlpha = this._alpha.current,
            i && (this.op = i),
            a[this.smoothProperty] = e.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR,
            a.setTransform(n.a, n.b, n.c, n.d, r, o),
            a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * e.anchor.x, -this._size.y * e.anchor.y, this._size.x, this._size.y),
            a.restore(),
            a.globalAlpha = this._alpha.prev,
            this.dirty = !0,
            this
        },
        copyRect: function(t, e, i, s, n, r, o) {
            return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, o)
        },
        draw: function(t, e, i, s, n, r, o) {
            return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, o)
        },
        drawGroup: function(t, e, i) {
            return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i),
            this
        },
        drawGroupProxy: function(e, i, s) {
            if (e.hasOwnProperty("texture") && this.copyTransform(e, i, s), e.type === t.GROUP && e.exists) this.drawGroup(e, i, s);
            else if (e.hasOwnProperty("children") && e.children.length > 0) for (var n = 0; n < e.children.length; n++) e.children[n].exists && this.copyTransform(e.children[n], i, s)
        },
        drawFull: function(e, i, s) {
            if (!1 === e.worldVisible || 0 === e.worldAlpha || e.hasOwnProperty("exists") && !1 === e.exists) return this;
            if (e.type !== t.GROUP && e.type !== t.EMITTER && e.type !== t.BITMAPTEXT) if (e.type === t.GRAPHICS) {
                var n = e.getBounds();
                this.ctx.save(),
                this.ctx.translate(n.x, n.y),
                PIXI.CanvasGraphics.renderGraphics(e, this.ctx),
                this.ctx.restore()
            } else this.copy(e, null, null, null, null, e.worldPosition.x, e.worldPosition.y, null, null, e.worldRotation, null, null, e.worldScale.x, e.worldScale.y, e.worldAlpha, i, s);
            if (e.children) for (var r = 0; r < e.children.length; r++) this.drawFull(e.children[r], i, s);
            return this
        },
        shadow: function(t, e, i, s) {
            var n = this.context;
            return null == t ? n.shadowColor = "rgba(0,0,0,0)": (n.shadowColor = t, n.shadowBlur = 0 === e ? 0 : e || 5, n.shadowOffsetX = 0 === i ? 0 : i || 10, n.shadowOffsetY = 0 === s ? 0 : s || 10),
            this
        },
        alphaMask: function(t, e, i, s) {
            return null == s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(),
            null == i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(),
            this
        },
        extract: function(t, e, i, s, n, r, o, a, h) {
            return void 0 === n && (n = 255),
            void 0 === r && (r = !1),
            void 0 === o && (o = e),
            void 0 === a && (a = i),
            void 0 === h && (h = s),
            r && t.resize(this.width, this.height),
            this.processPixelRGB(function(r, l, c) {
                return r.r === e && r.g === i && r.b === s && t.setPixel32(l, c, o, a, h, n, !1),
                !1
            },
            this),
            t.context.putImageData(t.imageData, 0, 0),
            t.dirty = !0,
            t
        },
        rect: function(t, e, i, s, n) {
            return void 0 !== n && (this.context.fillStyle = n),
            this.context.fillRect(t, e, i, s),
            this
        },
        text: function(t, e, i, s, n, r) {
            void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = "14px Courier"),
            void 0 === n && (n = "rgb(255,255,255)"),
            void 0 === r && (r = !0);
            var o = this.context,
            a = o.font;
            return o.font = s,
            r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)),
            o.fillStyle = n,
            o.fillText(t, e, i),
            o.font = a,
            this
        },
        circle: function(t, e, i, s) {
            var n = this.context;
            return void 0 !== s && (n.fillStyle = s),
            n.beginPath(),
            n.arc(t, e, i, 0, 2 * Math.PI, !1),
            n.closePath(),
            n.fill(),
            this
        },
        line: function(t, e, i, s, n, r) {
            void 0 === n && (n = "#fff"),
            void 0 === r && (r = 1);
            var o = this.context;
            return o.beginPath(),
            o.moveTo(t, e),
            o.lineTo(i, s),
            o.lineWidth = r,
            o.strokeStyle = n,
            o.stroke(),
            o.closePath(),
            this
        },
        polygon: function(t, e, i, s) {
            void 0 === s && (s = "#fff"),
            void 0 === i && (i = 0);
            var n = this.context;
            e && (n.fillStyle = e),
            i && (n.lineWidth = i, n.strokeStyle = s),
            n.beginPath(),
            n.moveTo(t[0].x, t[0].y);
            for (var r = 1,
            o = t.length; r < o; r++) {
                var a = t[r];
                n.lineTo(a.x, a.y)
            }
            return n.closePath(),
            e && n.fill(),
            i && n.stroke(),
            this
        },
        textureLine: function(e, i, s) {
            if (void 0 === s && (s = "repeat-x"), "string" != typeof i || (i = this.game.cache.getImage(i))) {
                var n = e.length;
                "no-repeat" === s && n > i.width && (n = i.width);
                var r = this.context;
                return r.fillStyle = r.createPattern(i, s),
                this._circle = new t.Circle(e.start.x, e.start.y, i.height),
                this._circle.circumferencePoint(e.angle - 1.5707963267948966, !1, this._pos),
                r.save(),
                r.translate(this._pos.x, this._pos.y),
                r.rotate(e.angle),
                r.fillRect(0, 0, n, i.height),
                r.restore(),
                this.dirty = !0,
                this
            }
        },
        render: function() {
            return ! this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1),
            this
        },
        destroy: function() {
            this.frameData.destroy(),
            this.texture.destroy(!0),
            t.CanvasPool.remove(this)
        },
        blendReset: function() {
            return this.op = "source-over",
            this
        },
        blendSourceOver: function() {
            return this.op = "source-over",
            this
        },
        blendSourceIn: function() {
            return this.op = "source-in",
            this
        },
        blendSourceOut: function() {
            return this.op = "source-out",
            this
        },
        blendSourceAtop: function() {
            return this.op = "source-atop",
            this
        },
        blendDestinationOver: function() {
            return this.op = "destination-over",
            this
        },
        blendDestinationIn: function() {
            return this.op = "destination-in",
            this
        },
        blendDestinationOut: function() {
            return this.op = "destination-out",
            this
        },
        blendDestinationAtop: function() {
            return this.op = "destination-atop",
            this
        },
        blendXor: function() {
            return this.op = "xor",
            this
        },
        blendAdd: function() {
            return this.op = "lighter",
            this
        },
        blendMultiply: function() {
            return this.op = "multiply",
            this
        },
        blendScreen: function() {
            return this.op = "screen",
            this
        },
        blendOverlay: function() {
            return this.op = "overlay",
            this
        },
        blendDarken: function() {
            return this.op = "darken",
            this
        },
        blendLighten: function() {
            return this.op = "lighten",
            this
        },
        blendColorDodge: function() {
            return this.op = "color-dodge",
            this
        },
        blendColorBurn: function() {
            return this.op = "color-burn",
            this
        },
        blendHardLight: function() {
            return this.op = "hard-light",
            this
        },
        blendSoftLight: function() {
            return this.op = "soft-light",
            this
        },
        blendDifference: function() {
            return this.op = "difference",
            this
        },
        blendExclusion: function() {
            return this.op = "exclusion",
            this
        },
        blendHue: function() {
            return this.op = "hue",
            this
        },
        blendSaturation: function() {
            return this.op = "saturation",
            this
        },
        blendColor: function() {
            return this.op = "color",
            this
        },
        blendLuminosity: function() {
            return this.op = "luminosity",
            this
        },
        copyBitmapData: function(t, e, i) {
            t.update();
            for (var s, n = 0; n < t.height; n++) {
                s = (i + n) * this.width + e;
                for (var r = 0; r < t.width; r++) this.pixels[s + r] = t.pixels[n * t.width + r]
            }
            return this
        }
    },
    Object.defineProperty(t.BitmapData.prototype, "smoothed", {
        get: function() {
            t.Canvas.getSmoothingEnabled(this.context)
        },
        set: function(e) {
            t.Canvas.setSmoothingEnabled(this.context, e)
        }
    }),
    Object.defineProperty(t.BitmapData.prototype, "op", {
        get: function() {
            return this.context.globalCompositeOperation
        },
        set: function(t) {
            this.context.globalCompositeOperation = t
        }
    }),
    t.BitmapData.getTransform = function(t, e, i, s, n, r) {
        return "number" != typeof t && (t = 0),
        "number" != typeof e && (e = 0),
        "number" != typeof i && (i = 1),
        "number" != typeof s && (s = 1),
        "number" != typeof n && (n = 0),
        "number" != typeof r && (r = 0),
        {
            sx: i,
            sy: s,
            scaleX: i,
            scaleY: s,
            skewX: n,
            skewY: r,
            translateX: t,
            translateY: e,
            tx: t,
            ty: e
        }
    },
    t.BitmapData.prototype.constructor = t.BitmapData,
    t.EarCut = {},
    t.EarCut.Triangulate = function(e, i, s) {
        s = s || 2;
        var n, r, o, a, h, l, c, u = i && i.length,
        d = u ? i[0] * s: e.length,
        p = t.EarCut.linkedList(e, 0, d, s, !0),
        f = [];
        if (!p) return f;
        if (u && (p = t.EarCut.eliminateHoles(e, i, p, s)), e.length > 80 * s) {
            n = o = e[0],
            r = a = e[1];
            for (var g = s; g < d; g += s)(h = e[g]) < n && (n = h),
            (l = e[g + 1]) < r && (r = l),
            h > o && (o = h),
            l > a && (a = l);
            c = Math.max(o - n, a - r)
        }
        return t.EarCut.earcutLinked(p, f, s, n, r, c),
        f
    },
    t.EarCut.linkedList = function(e, i, s, n, r) {
        var o, a, h, l = 0;
        for (o = i, a = s - n; o < s; o += n) l += (e[a] - e[o]) * (e[o + 1] + e[a + 1]),
        a = o;
        if (r === l > 0) for (o = i; o < s; o += n) h = t.EarCut.insertNode(o, e[o], e[o + 1], h);
        else for (o = s - n; o >= i; o -= n) h = t.EarCut.insertNode(o, e[o], e[o + 1], h);
        return h
    },
    t.EarCut.filterPoints = function(e, i) {
        if (!e) return e;
        i || (i = e);
        var s, n = e;
        do {
            if (s = !1, n.steiner || !t.EarCut.equals(n, n.next) && 0 !== t.EarCut.area(n.prev, n, n.next)) n = n.next;
            else {
                if (t.EarCut.removeNode(n), (n = i = n.prev) === n.next) return null;
                s = !0
            }
        } while ( s || n !== i );
        return i
    },
    t.EarCut.earcutLinked = function(e, i, s, n, r, o, a) {
        if (e) { ! a && o && t.EarCut.indexCurve(e, n, r, o);
            for (var h, l, c = e; e.prev !== e.next;) if (h = e.prev, l = e.next, o ? t.EarCut.isEarHashed(e, n, r, o) : t.EarCut.isEar(e)) i.push(h.i / s),
            i.push(e.i / s),
            i.push(l.i / s),
            t.EarCut.removeNode(e),
            e = l.next,
            c = l.next;
            else if ((e = l) === c) {
                a ? 1 === a ? (e = t.EarCut.cureLocalIntersections(e, i, s), t.EarCut.earcutLinked(e, i, s, n, r, o, 2)) : 2 === a && t.EarCut.splitEarcut(e, i, s, n, r, o) : t.EarCut.earcutLinked(t.EarCut.filterPoints(e), i, s, n, r, o, 1);
                break
            }
        }
    },
    t.EarCut.isEar = function(e) {
        var i = e.prev,
        s = e,
        n = e.next;
        if (t.EarCut.area(i, s, n) >= 0) return ! 1;
        for (var r = e.next.next; r !== e.prev;) {
            if (t.EarCut.pointInTriangle(i.x, i.y, s.x, s.y, n.x, n.y, r.x, r.y) && t.EarCut.area(r.prev, r, r.next) >= 0) return ! 1;
            r = r.next
        }
        return ! 0
    },
    t.EarCut.isEarHashed = function(e, i, s, n) {
        var r = e.prev,
        o = e,
        a = e.next;
        if (t.EarCut.area(r, o, a) >= 0) return ! 1;
        for (var h = r.x < o.x ? r.x < a.x ? r.x: a.x: o.x < a.x ? o.x: a.x, l = r.y < o.y ? r.y < a.y ? r.y: a.y: o.y < a.y ? o.y: a.y, c = r.x > o.x ? r.x > a.x ? r.x: a.x: o.x > a.x ? o.x: a.x, u = r.y > o.y ? r.y > a.y ? r.y: a.y: o.y > a.y ? o.y: a.y, d = t.EarCut.zOrder(h, l, i, s, n), p = t.EarCut.zOrder(c, u, i, s, n), f = e.nextZ; f && f.z <= p;) {
            if (f !== e.prev && f !== e.next && t.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && t.EarCut.area(f.prev, f, f.next) >= 0) return ! 1;
            f = f.nextZ
        }
        for (f = e.prevZ; f && f.z >= d;) {
            if (f !== e.prev && f !== e.next && t.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && t.EarCut.area(f.prev, f, f.next) >= 0) return ! 1;
            f = f.prevZ
        }
        return ! 0
    },
    t.EarCut.cureLocalIntersections = function(e, i, s) {
        var n = e;
        do {
            var r = n.prev,
            o = n.next.next;
            t.EarCut.intersects(r, n, n.next, o) && t.EarCut.locallyInside(r, o) && t.EarCut.locallyInside(o, r) && (i.push(r.i / s), i.push(n.i / s), i.push(o.i / s), t.EarCut.removeNode(n), t.EarCut.removeNode(n.next), n = e = o), n = n.next
        } while ( n !== e );
        return n
    },
    t.EarCut.splitEarcut = function(e, i, s, n, r, o) {
        var a = e;
        do {
            for (var h = a.next.next; h !== a.prev;) {
                if (a.i !== h.i && t.EarCut.isValidDiagonal(a, h)) {
                    var l = t.EarCut.splitPolygon(a, h);
                    return a = t.EarCut.filterPoints(a, a.next),
                    l = t.EarCut.filterPoints(l, l.next),
                    t.EarCut.earcutLinked(a, i, s, n, r, o),
                    void t.EarCut.earcutLinked(l, i, s, n, r, o)
                }
                h = h.next
            }
            a = a.next
        } while ( a !== e )
    },
    t.EarCut.eliminateHoles = function(e, i, s, n) {
        var r, o, a, h, l, c = [];
        for (r = 0, o = i.length; r < o; r++) a = i[r] * n,
        h = r < o - 1 ? i[r + 1] * n: e.length,
        (l = t.EarCut.linkedList(e, a, h, n, !1)) === l.next && (l.steiner = !0),
        c.push(t.EarCut.getLeftmost(l));
        for (c.sort(t.EarCut.compareX), r = 0; r < c.length; r++) t.EarCut.eliminateHole(c[r], s),
        s = t.EarCut.filterPoints(s, s.next);
        return s
    },
    t.EarCut.compareX = function(t, e) {
        return t.x - e.x
    },
    t.EarCut.eliminateHole = function(e, i) {
        if (i = t.EarCut.findHoleBridge(e, i)) {
            var s = t.EarCut.splitPolygon(i, e);
            t.EarCut.filterPoints(s, s.next)
        }
    },
    t.EarCut.findHoleBridge = function(e, i) {
        var s, n = i,
        r = e.x,
        o = e.y,
        a = -1 / 0;
        do {
            if (o <= n.y && o >= n.next.y) {
                var h = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                h <= r && h > a && (a = h, s = n.x < n.next.x ? n: n.next)
            }
            n = n.next
        } while ( n !== i );
        if (!s) return null;
        if (e.x === s.x) return s.prev;
        var l, c = s,
        u = 1 / 0;
        for (n = s.next; n !== c;) r >= n.x && n.x >= s.x && t.EarCut.pointInTriangle(o < s.y ? r: a, o, s.x, s.y, o < s.y ? a: r, o, n.x, n.y) && ((l = Math.abs(o - n.y) / (r - n.x)) < u || l === u && n.x > s.x) && t.EarCut.locallyInside(n, e) && (s = n, u = l),
        n = n.next;
        return s
    },
    t.EarCut.indexCurve = function(e, i, s, n) {
        var r = e;
        do {
            null === r.z && (r.z = t.EarCut.zOrder(r.x, r.y, i, s, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
        } while ( r !== e );
        r.prevZ.nextZ = null,
        r.prevZ = null,
        t.EarCut.sortLinked(r)
    },
    t.EarCut.sortLinked = function(t) {
        var e, i, s, n, r, o, a, h, l = 1;
        do {
            for (i = t, t = null, r = null, o = 0; i;) {
                for (o++, s = i, a = 0, e = 0; e < l && (a++, s = s.nextZ); e++);
                for (h = l; a > 0 || h > 0 && s;) 0 === a ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, a--),
                r ? r.nextZ = n: t = n,
                n.prevZ = r,
                r = n;
                i = s
            }
            r.nextZ = null, l *= 2
        } while ( o > 1 );
        return t
    },
    t.EarCut.zOrder = function(t, e, i, s, n) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    },
    t.EarCut.getLeftmost = function(t) {
        var e = t,
        i = t;
        do {
            e.x < i.x && (i = e), e = e.next
        } while ( e !== t );
        return i
    },
    t.EarCut.pointInTriangle = function(t, e, i, s, n, r, o, a) {
        return (n - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (s - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (n - o) * (s - a) >= 0
    },
    t.EarCut.isValidDiagonal = function(e, i) {
        return t.EarCut.equals(e, i) || e.next.i !== i.i && e.prev.i !== i.i && !t.EarCut.intersectsPolygon(e, i) && t.EarCut.locallyInside(e, i) && t.EarCut.locallyInside(i, e) && t.EarCut.middleInside(e, i)
    },
    t.EarCut.area = function(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    },
    t.EarCut.equals = function(t, e) {
        return t.x === e.x && t.y === e.y
    },
    t.EarCut.intersects = function(e, i, s, n) {
        return t.EarCut.area(e, i, s) > 0 != t.EarCut.area(e, i, n) > 0 && t.EarCut.area(s, n, e) > 0 != t.EarCut.area(s, n, i) > 0
    },
    t.EarCut.intersectsPolygon = function(e, i) {
        var s = e;
        do {
            if (s.i !== e.i && s.next.i !== e.i && s.i !== i.i && s.next.i !== i.i && t.EarCut.intersects(s, s.next, e, i)) return ! 0;
            s = s.next
        } while ( s !== e );
        return ! 1
    },
    t.EarCut.locallyInside = function(e, i) {
        return t.EarCut.area(e.prev, e, e.next) < 0 ? t.EarCut.area(e, i, e.next) >= 0 && t.EarCut.area(e, e.prev, i) >= 0 : t.EarCut.area(e, i, e.prev) < 0 || t.EarCut.area(e, e.next, i) < 0
    },
    t.EarCut.middleInside = function(t, e) {
        var i = t,
        s = !1,
        n = (t.x + e.x) / 2,
        r = (t.y + e.y) / 2;
        do {
            i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
        } while ( i !== t );
        return s
    },
    t.EarCut.splitPolygon = function(e, i) {
        var s = new t.EarCut.Node(e.i, e.x, e.y),
        n = new t.EarCut.Node(i.i, i.x, i.y),
        r = e.next,
        o = i.prev;
        return e.next = i,
        i.prev = e,
        s.next = r,
        r.prev = s,
        n.next = s,
        s.prev = n,
        o.next = n,
        n.prev = o,
        n
    },
    t.EarCut.insertNode = function(e, i, s, n) {
        var r = new t.EarCut.Node(e, i, s);
        return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r),
        r
    },
    t.EarCut.removeNode = function(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    },
    t.EarCut.Node = function(t, e, i) {
        this.i = t,
        this.x = e,
        this.y = i,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    },
    PIXI.WebGLGraphics = function() {},
    PIXI.WebGLGraphics.stencilBufferLimit = 6,
    PIXI.WebGLGraphics.renderGraphics = function(e, i) {
        var s, n = i.gl,
        r = i.projection,
        o = i.offset,
        a = i.shaderManager.primitiveShader;
        e.dirty && PIXI.WebGLGraphics.updateGraphics(e, n);
        var h = e._webGL[n.id];
        if (h) for (var l = 0; l < h.data.length; l++) 1 === h.data[l].mode ? (s = h.data[l], i.stencilManager.pushStencil(e, s, i), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (s.indices.length - 4)), i.stencilManager.popStencil(e, s, i)) : (s = h.data[l], i.shaderManager.setShader(a), a = i.shaderManager.primitiveShader, n.uniformMatrix3fv(a.translationMatrix, !1, e.worldTransform.toArray(!0)), n.uniform1f(a.flipY, 1), n.uniform2f(a.projectionVector, r.x, -r.y), n.uniform2f(a.offsetVector, -o.x, -o.y), n.uniform3fv(a.tintColor, t.Color.hexToRGBArray(e.tint)), n.uniform1f(a.alpha, e.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, s.buffer), n.vertexAttribPointer(a.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(a.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, s.indexBuffer), n.drawElements(n.TRIANGLE_STRIP, s.indices.length, n.UNSIGNED_SHORT, 0))
    },
    PIXI.WebGLGraphics.updateGraphics = function(e, i) {
        var s, n, r = e._webGL[i.id];
        if (r || (r = e._webGL[i.id] = {
            lastIndex: 0,
            data: [],
            gl: i
        }), e.dirty = !1, e.clearDirty) {
            for (e.clearDirty = !1, s = 0; s < r.data.length; s++) {
                var o = r.data[s];
                o.reset(),
                PIXI.WebGLGraphics.graphicsDataPool.push(o)
            }
            r.data = [],
            r.lastIndex = 0
        }
        for (s = r.lastIndex; s < e.graphicsData.length; s++) {
            var a = e.graphicsData[s];
            a.type === t.POLYGON ? (a.points = a.shape.points.slice(), a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill && a.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (a.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (n = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildPoly(a, n) || (n = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))) : (n = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))), a.lineWidth > 0 && (n = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildLine(a, n))) : (n = PIXI.WebGLGraphics.switchMode(r, 0), a.type === t.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(a, n) : a.type === t.CIRCLE || a.type === t.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(a, n) : a.type === t.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(a, n)),
            r.lastIndex++
        }
        for (s = 0; s < r.data.length; s++)(n = r.data[s]).dirty && n.upload()
    },
    PIXI.WebGLGraphics.switchMode = function(t, e) {
        var i;
        return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)),
        i.dirty = !0,
        i
    },
    PIXI.WebGLGraphics.buildRectangle = function(e, i) {
        var s = e.shape,
        n = s.x,
        r = s.y,
        o = s.width,
        a = s.height;
        if (e.fill) {
            var h = t.Color.hexToRGBArray(e.fillColor),
            l = e.fillAlpha,
            c = h[0] * l,
            u = h[1] * l,
            d = h[2] * l,
            p = i.points,
            f = i.indices,
            g = p.length / 6;
            p.push(n, r),
            p.push(c, u, d, l),
            p.push(n + o, r),
            p.push(c, u, d, l),
            p.push(n, r + a),
            p.push(c, u, d, l),
            p.push(n + o, r + a),
            p.push(c, u, d, l),
            f.push(g, g, g + 1, g + 2, g + 3, g + 3)
        }
        if (e.lineWidth) {
            var m = e.points;
            e.points = [n, r, n + o, r, n + o, r + a, n, r + a, n, r],
            PIXI.WebGLGraphics.buildLine(e, i),
            e.points = m
        }
    },
    PIXI.WebGLGraphics.buildRoundedRectangle = function(e, i) {
        var s = e.shape,
        n = s.x,
        r = s.y,
        o = s.width,
        a = s.height,
        h = s.radius,
        l = [];
        if (l.push(n, r + h), l = (l = (l = (l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n, r + a - h, n, r + a, n + h, r + a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o - h, r + a, n + o, r + a, n + o, r + a - h))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o, r + h, n + o, r, n + o - h, r))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + h, r, n, r, n, r + h)), e.fill) {
            var c = t.Color.hexToRGBArray(e.fillColor),
            u = e.fillAlpha,
            d = c[0] * u,
            p = c[1] * u,
            f = c[2] * u,
            g = i.points,
            m = i.indices,
            y = g.length / 6,
            v = t.EarCut.Triangulate(l, null, 2),
            x = 0;
            for (x = 0; x < v.length; x += 3) m.push(v[x] + y),
            m.push(v[x] + y),
            m.push(v[x + 1] + y),
            m.push(v[x + 2] + y),
            m.push(v[x + 2] + y);
            for (x = 0; x < l.length; x++) g.push(l[x], l[++x], d, p, f, u)
        }
        if (e.lineWidth) {
            var b = e.points;
            e.points = l,
            PIXI.WebGLGraphics.buildLine(e, i),
            e.points = b
        }
    },
    PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
        function o(t, e, i) {
            return t + (e - t) * i
        }
        for (var a, h, l, c, u, d, p = [], f = 0, g = 0; g <= 20; g++) a = o(t, i, f = g / 20),
        h = o(e, s, f),
        l = o(i, n, f),
        c = o(s, r, f),
        u = o(a, l, f),
        d = o(h, c, f),
        p.push(u, d);
        return p
    },
    PIXI.WebGLGraphics.buildCircle = function(e, i) {
        var s, n, r = e.shape,
        o = r.x,
        a = r.y;
        e.type === t.CIRCLE ? (s = r.radius, n = r.radius) : (s = r.width, n = r.height);
        var h = 2 * Math.PI / 40,
        l = 0;
        if (e.fill) {
            var c = t.Color.hexToRGBArray(e.fillColor),
            u = e.fillAlpha,
            d = c[0] * u,
            p = c[1] * u,
            f = c[2] * u,
            g = i.points,
            m = i.indices,
            y = g.length / 6;
            for (m.push(y), l = 0; l < 41; l++) g.push(o, a, d, p, f, u),
            g.push(o + Math.sin(h * l) * s, a + Math.cos(h * l) * n, d, p, f, u),
            m.push(y++, y++);
            m.push(y - 1)
        }
        if (e.lineWidth) {
            var v = e.points;
            for (e.points = [], l = 0; l < 41; l++) e.points.push(o + Math.sin(h * l) * s, a + Math.cos(h * l) * n);
            PIXI.WebGLGraphics.buildLine(e, i),
            e.points = v
        }
    },
    PIXI.WebGLGraphics.buildLine = function(e, i) {
        var s = 0,
        n = e.points;
        if (0 !== n.length) {
            if (e.lineWidth % 2) for (s = 0; s < n.length; s++) n[s] += .5;
            var r = new PIXI.Point(n[0], n[1]),
            o = new PIXI.Point(n[n.length - 2], n[n.length - 1]);
            if (r.x === o.x && r.y === o.y) { (n = n.slice()).pop(),
                n.pop();
                var a = (o = new PIXI.Point(n[n.length - 2], n[n.length - 1])).x + .5 * (r.x - o.x),
                h = o.y + .5 * (r.y - o.y);
                n.unshift(a, h),
                n.push(a, h)
            }
            var l, c, u, d, p, f, g, m, y, v, x, b, _, w, T, P, C, S, A, E, M, R, L = i.points,
            B = i.indices,
            I = n.length / 2,
            O = n.length,
            k = L.length / 6,
            F = e.lineWidth / 2,
            D = t.Color.hexToRGBArray(e.lineColor),
            U = e.lineAlpha,
            G = D[0] * U,
            N = D[1] * U,
            X = D[2] * U;
            for (u = n[0], d = n[1], p = n[2], y = -(d - (f = n[3])), v = u - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, L.push(u - y, d - v, G, N, X, U), L.push(u + y, d + v, G, N, X, U), s = 1; s < I - 1; s++) u = n[2 * (s - 1)],
            d = n[2 * (s - 1) + 1],
            p = n[2 * s],
            f = n[2 * s + 1],
            g = n[2 * (s + 1)],
            m = n[2 * (s + 1) + 1],
            y = -(d - f),
            v = u - p,
            y /= R = Math.sqrt(y * y + v * v),
            v /= R,
            y *= F,
            v *= F,
            x = -(f - m),
            b = p - g,
            x /= R = Math.sqrt(x * x + b * b),
            b /= R,
            C = ( - y + u) * ( - v + f) - ( - y + p) * ( - v + d),
            E = ( - (x *= F) + g) * ( - (b *= F) + f) - ( - x + p) * ( - b + m),
            M = (T = -v + d - ( - v + f)) * (A = -x + p - ( - x + g)) - (S = -b + m - ( - b + f)) * (P = -y + p - ( - y + u)),
            Math.abs(M) < .1 ? (M += 10.1, L.push(p - y, f - v, G, N, X, U), L.push(p + y, f + v, G, N, X, U)) : ((l = (P * E - A * C) / M) - p) * (l - p) + ((c = (S * C - T * E) / M) - f) + (c - f) > 19600 ? (_ = y - x, w = v - b, _ /= R = Math.sqrt(_ * _ + w * w), w /= R, _ *= F, w *= F, L.push(p - _, f - w), L.push(G, N, X, U), L.push(p + _, f + w), L.push(G, N, X, U), L.push(p - _, f - w), L.push(G, N, X, U), O++) : (L.push(l, c), L.push(G, N, X, U), L.push(p - (l - p), f - (c - f)), L.push(G, N, X, U));
            for (u = n[2 * (I - 2)], d = n[2 * (I - 2) + 1], p = n[2 * (I - 1)], y = -(d - (f = n[2 * (I - 1) + 1])), v = u - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, L.push(p - y, f - v), L.push(G, N, X, U), L.push(p + y, f + v), L.push(G, N, X, U), B.push(k), s = 0; s < O; s++) B.push(k++);
            B.push(k - 1)
        }
    },
    PIXI.WebGLGraphics.buildComplexPoly = function(e, i) {
        var s = e.points.slice();
        if (! (s.length < 6)) {
            var n = i.indices;
            i.points = s,
            i.alpha = e.fillAlpha,
            i.color = t.Color.hexToRGBArray(e.fillColor);
            for (var r, o, a = 1 / 0,
            h = -1 / 0,
            l = 1 / 0,
            c = -1 / 0,
            u = 0; u < s.length; u += 2) a = (r = s[u]) < a ? r: a,
            h = r > h ? r: h,
            l = (o = s[u + 1]) < l ? o: l,
            c = o > c ? o: c;
            s.push(a, l, h, l, h, c, a, c);
            var d = s.length / 2;
            for (u = 0; u < d; u++) n.push(u)
        }
    },
    PIXI.WebGLGraphics.buildPoly = function(e, i) {
        var s = e.points;
        if (! (s.length < 6)) {
            var n = i.points,
            r = i.indices,
            o = s.length / 2,
            a = t.Color.hexToRGBArray(e.fillColor),
            h = e.fillAlpha,
            l = a[0] * h,
            c = a[1] * h,
            u = a[2] * h,
            d = t.EarCut.Triangulate(s, null, 2);
            if (!d) return ! 1;
            var p = n.length / 6,
            f = 0;
            for (f = 0; f < d.length; f += 3) r.push(d[f] + p),
            r.push(d[f] + p),
            r.push(d[f + 1] + p),
            r.push(d[f + 2] + p),
            r.push(d[f + 2] + p);
            for (f = 0; f < o; f++) n.push(s[2 * f], s[2 * f + 1], l, c, u, h);
            return ! 0
        }
    },
    PIXI.WebGLGraphics.graphicsDataPool = [],
    PIXI.WebGLGraphicsData = function(t) {
        this.gl = t,
        this.color = [0, 0, 0],
        this.points = [],
        this.indices = [],
        this.buffer = t.createBuffer(),
        this.indexBuffer = t.createBuffer(),
        this.mode = 1,
        this.alpha = 1,
        this.dirty = !0
    },
    PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [],
        this.indices = []
    },
    PIXI.WebGLGraphicsData.prototype.upload = function() {
        var t = this.gl;
        this.glPoints = new Float32Array(this.points),
        t.bindBuffer(t.ARRAY_BUFFER, this.buffer),
        t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW),
        this.glIndicies = new Uint16Array(this.indices),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW),
        this.dirty = !1
    },
    PIXI.CanvasGraphics = function() {},
    PIXI.CanvasGraphics.renderGraphics = function(e, i) {
        var s = e.worldAlpha;
        e.dirty && (this.updateGraphicsTint(e), e.dirty = !1);
        for (var n = 0; n < e.graphicsData.length; n++) {
            var r = e.graphicsData[n],
            o = r.shape,
            a = r._fillTint,
            h = r._lineTint;
            if (i.lineWidth = r.lineWidth, r.type === t.POLYGON) {
                i.beginPath();
                var l = o.points;
                i.moveTo(l[0], l[1]);
                for (var c = 1; c < l.length / 2; c++) i.lineTo(l[2 * c], l[2 * c + 1]);
                o.closed && i.lineTo(l[0], l[1]),
                l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && i.closePath(),
                r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr( - 6), i.fill()),
                r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr( - 6), i.stroke())
            } else if (r.type === t.RECTANGLE)(r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr( - 6), i.fillRect(o.x, o.y, o.width, o.height)),
            r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr( - 6), i.strokeRect(o.x, o.y, o.width, o.height));
            else if (r.type === t.CIRCLE) i.beginPath(),
            i.arc(o.x, o.y, o.radius, 0, 2 * Math.PI),
            i.closePath(),
            r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr( - 6), i.fill()),
            r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr( - 6), i.stroke());
            else if (r.type === t.ELLIPSE) {
                var u = 2 * o.width,
                d = 2 * o.height,
                p = o.x - u / 2,
                f = o.y - d / 2;
                i.beginPath();
                var g = u / 2 * .5522848,
                m = d / 2 * .5522848,
                y = p + u,
                v = f + d,
                x = p + u / 2,
                b = f + d / 2;
                i.moveTo(p, b),
                i.bezierCurveTo(p, b - m, x - g, f, x, f),
                i.bezierCurveTo(x + g, f, y, b - m, y, b),
                i.bezierCurveTo(y, b + m, x + g, v, x, v),
                i.bezierCurveTo(x - g, v, p, b + m, p, b),
                i.closePath(),
                r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr( - 6), i.fill()),
                r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr( - 6), i.stroke())
            } else if (r.type === t.ROUNDEDRECTANGLE) {
                var _ = o.x,
                w = o.y,
                T = o.width,
                P = o.height,
                C = o.radius,
                S = Math.min(T, P) / 2 | 0;
                C = C > S ? S: C,
                i.beginPath(),
                i.moveTo(_, w + C),
                i.lineTo(_, w + P - C),
                i.quadraticCurveTo(_, w + P, _ + C, w + P),
                i.lineTo(_ + T - C, w + P),
                i.quadraticCurveTo(_ + T, w + P, _ + T, w + P - C),
                i.lineTo(_ + T, w + C),
                i.quadraticCurveTo(_ + T, w, _ + T - C, w),
                i.lineTo(_ + C, w),
                i.quadraticCurveTo(_, w, _, w + C),
                i.closePath(),
                (r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr( - 6), i.fill()),
                r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr( - 6), i.stroke())
            }
        }
    },
    PIXI.CanvasGraphics.renderGraphicsMask = function(e, i) {
        var s = e.graphicsData.length;
        if (0 !== s) {
            i.beginPath();
            for (var n = 0; n < s; n++) {
                var r = e.graphicsData[n],
                o = r.shape;
                if (r.type === t.POLYGON) {
                    var a = o.points;
                    i.moveTo(a[0], a[1]);
                    for (var h = 1; h < a.length / 2; h++) i.lineTo(a[2 * h], a[2 * h + 1]);
                    a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && i.closePath()
                } else if (r.type === t.RECTANGLE) i.rect(o.x, o.y, o.width, o.height),
                i.closePath();
                else if (r.type === t.CIRCLE) i.arc(o.x, o.y, o.radius, 0, 2 * Math.PI),
                i.closePath();
                else if (r.type === t.ELLIPSE) {
                    var l = 2 * o.width,
                    c = 2 * o.height,
                    u = o.x - l / 2,
                    d = o.y - c / 2,
                    p = l / 2 * .5522848,
                    f = c / 2 * .5522848,
                    g = u + l,
                    m = d + c,
                    y = u + l / 2,
                    v = d + c / 2;
                    i.moveTo(u, v),
                    i.bezierCurveTo(u, v - f, y - p, d, y, d),
                    i.bezierCurveTo(y + p, d, g, v - f, g, v),
                    i.bezierCurveTo(g, v + f, y + p, m, y, m),
                    i.bezierCurveTo(y - p, m, u, v + f, u, v),
                    i.closePath()
                } else if (r.type === t.ROUNDEDRECTANGLE) {
                    var x = o.x,
                    b = o.y,
                    _ = o.width,
                    w = o.height,
                    T = o.radius,
                    P = Math.min(_, w) / 2 | 0;
                    T = T > P ? P: T,
                    i.moveTo(x, b + T),
                    i.lineTo(x, b + w - T),
                    i.quadraticCurveTo(x, b + w, x + T, b + w),
                    i.lineTo(x + _ - T, b + w),
                    i.quadraticCurveTo(x + _, b + w, x + _, b + w - T),
                    i.lineTo(x + _, b + T),
                    i.quadraticCurveTo(x + _, b, x + _ - T, b),
                    i.lineTo(x + T, b),
                    i.quadraticCurveTo(x, b, x, b + T),
                    i.closePath()
                }
            }
        }
    },
    PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
        if (16777215 !== t.tint) for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
            var r = t.graphicsData[n],
            o = 0 | r.fillColor,
            a = 0 | r.lineColor;
            r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255,
            r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
        }
    },
    t.GraphicsData = function(t, e, i, s, n, r, o) {
        this.lineWidth = t,
        this.lineColor = e,
        this.lineAlpha = i,
        this._lineTint = e,
        this.fillColor = s,
        this.fillAlpha = n,
        this._fillTint = s,
        this.fill = r,
        this.shape = o,
        this.type = o.type
    },
    t.GraphicsData.prototype.constructor = t.GraphicsData,
    t.GraphicsData.prototype.clone = function() {
        return new t.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
    },
    t.Graphics = function(e, i, s) {
        void 0 === i && (i = 0),
        void 0 === s && (s = 0),
        this.type = t.GRAPHICS,
        this.physicsType = t.SPRITE,
        this.anchor = new t.Point,
        PIXI.DisplayObjectContainer.call(this),
        this.renderable = !0,
        this.fillAlpha = 1,
        this.lineWidth = 0,
        this.lineColor = 0,
        this.graphicsData = [],
        this.tint = 16777215,
        this.blendMode = PIXI.blendModes.NORMAL,
        this.currentPath = null,
        this._webGL = [],
        this.isMask = !1,
        this.boundsPadding = 0,
        this._localBounds = new t.Rectangle(0, 0, 1, 1),
        this.dirty = !0,
        this._boundsDirty = !1,
        this.webGLDirty = !1,
        this.cachedSpriteDirty = !1,
        t.Component.Core.init.call(this, e, i, s, "", null)
    },
    t.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    t.Graphics.prototype.constructor = t.Graphics,
    t.Component.Core.install.call(t.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
    t.Graphics.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate,
    t.Graphics.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.Graphics.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.Graphics.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.Graphics.prototype.preUpdate = function() {
        return !! (this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.Graphics.prototype.postUpdate = function() {
        t.Component.PhysicsBody.postUpdate.call(this),
        t.Component.FixedToCamera.postUpdate.call(this),
        this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
        for (var e = 0; e < this.children.length; e++) this.children[e].postUpdate()
    },
    t.Graphics.prototype.destroy = function(e) {
        this.clear(),
        t.Component.Destroy.prototype.destroy.call(this, e)
    },
    t.Graphics.prototype.drawTriangle = function(e, i) {
        void 0 === i && (i = !1);
        var s = new t.Polygon(e);
        if (i) {
            var n = new t.Point(this.game.camera.x - e[0].x, this.game.camera.y - e[0].y),
            r = new t.Point(e[1].x - e[0].x, e[1].y - e[0].y),
            o = new t.Point(e[1].x - e[2].x, e[1].y - e[2].y).cross(r);
            n.dot(o) > 0 && this.drawPolygon(s)
        } else this.drawPolygon(s)
    },
    t.Graphics.prototype.drawTriangles = function(e, i, s) {
        void 0 === s && (s = !1);
        var n, r = new t.Point,
        o = new t.Point,
        a = new t.Point,
        h = [];
        if (i) if (e[0] instanceof t.Point) for (n = 0; n < i.length / 3; n++) h.push(e[i[3 * n]]),
        h.push(e[i[3 * n + 1]]),
        h.push(e[i[3 * n + 2]]),
        3 === h.length && (this.drawTriangle(h, s), h = []);
        else for (n = 0; n < i.length; n++) r.x = e[2 * i[n]],
        r.y = e[2 * i[n] + 1],
        h.push(r.copyTo({})),
        3 === h.length && (this.drawTriangle(h, s), h = []);
        else if (e[0] instanceof t.Point) for (n = 0; n < e.length / 3; n++) this.drawTriangle([e[3 * n], e[3 * n + 1], e[3 * n + 2]], s);
        else for (n = 0; n < e.length / 6; n++) r.x = e[6 * n + 0],
        r.y = e[6 * n + 1],
        o.x = e[6 * n + 2],
        o.y = e[6 * n + 3],
        a.x = e[6 * n + 4],
        a.y = e[6 * n + 5],
        this.drawTriangle([r, o, a], s)
    },
    t.Graphics.prototype.lineStyle = function(e, i, s) {
        return this.lineWidth = e || 0,
        this.lineColor = i || 0,
        this.lineAlpha = void 0 === s ? 1 : s,
        this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new t.Polygon(this.currentPath.shape.points.slice( - 2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)),
        this
    },
    t.Graphics.prototype.moveTo = function(e, i) {
        return this.drawShape(new t.Polygon([e, i])),
        this
    },
    t.Graphics.prototype.lineTo = function(t, e) {
        return this.currentPath || this.moveTo(0, 0),
        this.currentPath.shape.points.push(t, e),
        this.dirty = !0,
        this._boundsDirty = !0,
        this
    },
    t.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        var n, r, o = this.currentPath.shape.points;
        0 === o.length && this.moveTo(0, 0);
        for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c) n = a + (t - a) * (l = c / 20),
        r = h + (e - h) * l,
        o.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    },
    t.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        for (var o, a, h, l, c, u = this.currentPath.shape.points,
        d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o,
        c = (l = f * f) * f,
        u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * n, h * p + 3 * a * f * e + 3 * o * l * s + c * r);
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    },
    t.Graphics.prototype.arcTo = function(t, e, i, s, n) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
        var r = this.currentPath.shape.points,
        o = r[r.length - 2],
        a = r[r.length - 1] - e,
        h = o - t,
        l = s - e,
        c = i - t,
        u = Math.abs(a * c - h * l);
        if (u < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
        else {
            var d = a * a + h * h,
            p = l * l + c * c,
            f = a * l + h * c,
            g = n * Math.sqrt(d) / u,
            m = n * Math.sqrt(p) / u,
            y = g * f / d,
            v = m * f / p,
            x = g * c + m * h,
            b = g * l + m * a,
            _ = h * (m + y),
            w = a * (m + y),
            T = c * (g + v),
            P = l * (g + v),
            C = Math.atan2(w - b, _ - x),
            S = Math.atan2(P - b, T - x);
            this.arc(x + t, b + e, n, C, S, h * l > c * a)
        }
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    },
    t.Graphics.prototype.arc = function(t, e, i, s, n, r, o) {
        if (s === n) return this;
        void 0 === r && (r = !1),
        void 0 === o && (o = 40),
        !r && n <= s ? n += 2 * Math.PI: r && s <= n && (s += 2 * Math.PI);
        var a = r ? -1 * (s - n) : n - s,
        h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
        if (0 === a) return this;
        var l = t + Math.cos(s) * i,
        c = e + Math.sin(s) * i;
        r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
        for (var u = this.currentPath.shape.points,
        d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
            var x = d + s + p * (v + y * v),
            b = Math.cos(x),
            _ = -Math.sin(x);
            u.push((f * b + g * _) * i + t, (f * -_ + g * b) * i + e)
        }
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    },
    t.Graphics.prototype.beginFill = function(t, e) {
        return this.filling = !0,
        this.fillColor = t || 0,
        this.fillAlpha = void 0 === e ? 1 : e,
        this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha),
        this
    },
    t.Graphics.prototype.endFill = function() {
        return this.filling = !1,
        this.fillColor = null,
        this.fillAlpha = 1,
        this
    },
    t.Graphics.prototype.drawRect = function(e, i, s, n) {
        return this.drawShape(new t.Rectangle(e, i, s, n)),
        this
    },
    t.Graphics.prototype.drawRoundedRect = function(e, i, s, n, r) {
        return this.drawShape(new t.RoundedRectangle(e, i, s, n, r)),
        this
    },
    t.Graphics.prototype.drawCircle = function(e, i, s) {
        return this.drawShape(new t.Circle(e, i, s)),
        this
    },
    t.Graphics.prototype.drawEllipse = function(e, i, s, n) {
        return this.drawShape({
            x: e,
            y: i,
            width: s,
            height: n,
            type: t.ELLIPSE
        }),
        this
    },
    t.Graphics.prototype.drawPolygon = function(e) {
        e instanceof t.Polygon && (e = e.points);
        var i = e;
        if (!Array.isArray(i)) {
            i = new Array(arguments.length);
            for (var s = 0; s < i.length; ++s) i[s] = arguments[s]
        }
        return this.drawShape(new t.Polygon(i)),
        this
    },
    t.Graphics.prototype.clear = function() {
        return this.lineWidth = 0,
        this.filling = !1,
        this.dirty = !0,
        this._boundsDirty = !0,
        this.clearDirty = !0,
        this.graphicsData = [],
        this.updateLocalBounds(),
        this
    },
    t.Graphics.prototype.generateTexture = function(t, e, i) {
        void 0 === t && (t = 1),
        void 0 === e && (e = PIXI.scaleModes.DEFAULT),
        void 0 === i && (i = 0);
        var s = this.getBounds();
        s.width += i,
        s.height += i;
        var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
        r = PIXI.Texture.fromCanvas(n.canvas, e);
        return r.baseTexture.resolution = t,
        n.context.scale(t, t),
        n.context.translate( - s.x, -s.y),
        PIXI.CanvasGraphics.renderGraphics(this, n.context),
        r
    },
    t.Graphics.prototype._renderWebGL = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1),
            this._cachedSprite.worldAlpha = this.worldAlpha,
            void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
            if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                t.spriteBatch.currentBlendMode = this.blendMode;
                var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                t.spriteBatch.gl.blendFunc(e[0], e[1])
            }
            if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                t.spriteBatch.start();
                for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                t.spriteBatch.stop()
            }
            this._filters && t.filterManager.popFilter(),
            this._mask && t.maskManager.popMask(this.mask, t),
            t.drawCount++,
            t.spriteBatch.start()
        }
    },
    t.Graphics.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1),
            this._cachedSprite.alpha = this.alpha,
            void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
            var e = t.context,
            i = this.worldTransform;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]),
            this._mask && t.maskManager.pushMask(this._mask, t);
            var s = t.resolution,
            n = i.tx * t.resolution + t.shakeX,
            r = i.ty * t.resolution + t.shakeY;
            e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r),
            PIXI.CanvasGraphics.renderGraphics(this, e);
            for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    },
    t.Graphics.prototype.getBounds = function(e) {
        if (this._currentBounds) return this._currentBounds;
        if (this.isMask) return t.EmptyRectangle;
        this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
        var i = this._localBounds,
        s = i.x,
        n = i.width + i.x,
        r = i.y,
        o = i.height + i.y,
        a = e || this.worldTransform,
        h = a.a,
        l = a.b,
        c = a.c,
        u = a.d,
        d = a.tx,
        p = a.ty,
        f = h * n + c * o + d,
        g = u * o + l * n + p,
        m = h * s + c * o + d,
        y = u * o + l * s + p,
        v = h * s + c * r + d,
        x = u * r + l * s + p,
        b = h * n + c * r + d,
        _ = u * r + l * n + p,
        w = f,
        T = g,
        P = f,
        C = g;
        return P = b < (P = v < (P = m < P ? m: P) ? v: P) ? b: P,
        C = _ < (C = x < (C = y < C ? y: C) ? x: C) ? _: C,
        w = b > (w = v > (w = m > w ? m: w) ? v: w) ? b: w,
        T = _ > (T = x > (T = y > T ? y: T) ? x: T) ? _: T,
        this._bounds.x = P,
        this._bounds.width = w - P,
        this._bounds.y = C,
        this._bounds.height = T - C,
        this._currentBounds = this._bounds,
        this._currentBounds
    },
    t.Graphics.prototype.getLocalBounds = function() {
        var e = this.worldTransform;
        this.worldTransform = t.identityMatrix;
        for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        var s = this.getBounds();
        for (this.worldTransform = e, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        return s
    },
    t.Graphics.prototype.containsPoint = function(e, i) {
        void 0 === i && (i = new t.Point),
        this.worldTransform.applyInverse(e, i);
        for (var s = this.graphicsData,
        n = 0; n < s.length; n++) {
            var r = s[n];
            if (r.fill && r.shape && r.shape.contains(i.x, i.y)) return ! 0
        }
        return ! 1
    },
    t.Graphics.prototype.getVisualBounds = function(t) {
        return this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1),
        this._localBounds.clone(t)
    },
    t.Graphics.prototype.updateLocalBounds = function() {
        var e = 1 / 0,
        i = -1 / 0,
        s = 1 / 0,
        n = -1 / 0;
        if (this.graphicsData.length) for (var r, o, a, h, l, c, u = 0; u < this.graphicsData.length; u++) {
            var d = this.graphicsData[u],
            p = d.type,
            f = d.lineWidth;
            if (r = d.shape, p === t.RECTANGLE || p === t.ROUNDEDRECTANGLE) a = r.x - f / 2,
            h = r.y - f / 2,
            e = a < e ? a: e,
            i = a + (l = r.width + f) > i ? a + l: i,
            s = h < s ? h: s,
            n = h + (c = r.height + f) > n ? h + c: n;
            else if (p === t.CIRCLE) a = r.x,
            h = r.y,
            e = a - (l = r.radius + f / 2) < e ? a - l: e,
            i = a + l > i ? a + l: i,
            s = h - (c = r.radius + f / 2) < s ? h - c: s,
            n = h + c > n ? h + c: n;
            else if (p === t.ELLIPSE) a = r.x,
            h = r.y,
            e = a - (l = r.width + f / 2) < e ? a - l: e,
            i = a + l > i ? a + l: i,
            s = h - (c = r.height + f / 2) < s ? h - c: s,
            n = h + c > n ? h + c: n;
            else {
                o = r.points;
                for (var g = 0; g < o.length; g++) o[g] instanceof t.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++),
                e = a - f < e ? a - f: e,
                i = a + f > i ? a + f: i,
                s = h - f < s ? h - f: s,
                n = h + f > n ? h + f: n
            }
        } else e = 0,
        i = 0,
        s = 0,
        n = 0;
        var m = this.boundsPadding;
        this._localBounds.x = e - m,
        this._localBounds.width = i - e + 2 * m,
        this._localBounds.y = s - m,
        this._localBounds.height = n - s + 2 * m
    },
    t.Graphics.prototype._generateCachedSprite = function() {
        var t = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
        else {
            var e = new PIXI.CanvasBuffer(t.width, t.height),
            i = PIXI.Texture.fromCanvas(e.canvas);
            this._cachedSprite = new PIXI.Sprite(i),
            this._cachedSprite.buffer = e,
            this._cachedSprite.worldTransform = this.worldTransform
        }
        this._cachedSprite.anchor.x = -t.x / t.width,
        this._cachedSprite.anchor.y = -t.y / t.height,
        this._cachedSprite.buffer.context.translate( - t.x, -t.y),
        this.worldAlpha = 1,
        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context),
        this._cachedSprite.alpha = this.alpha
    },
    t.Graphics.prototype.updateCachedSpriteTexture = function() {
        var t = this._cachedSprite,
        e = t.texture,
        i = t.buffer.canvas;
        e.baseTexture.width = i.width,
        e.baseTexture.height = i.height,
        e.crop.width = e.frame.width = i.width,
        e.crop.height = e.frame.height = i.height,
        t._width = i.width,
        t._height = i.height,
        e.baseTexture.dirty()
    },
    t.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0),
        this._cachedSprite = null
    },
    t.Graphics.prototype.drawShape = function(e) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(),
        this.currentPath = null,
        e instanceof t.Polygon && (e = e.clone()).flatten();
        var i = new t.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, e);
        return this.graphicsData.push(i),
        i.type === t.POLYGON && (i.shape.closed = this.filling, this.currentPath = i),
        this.dirty = !0,
        this._boundsDirty = !0,
        i
    },
    Object.defineProperty(t.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(t) {
            this._cacheAsBitmap = t,
            this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(),
            this.dirty = !0,
            this.webGLDirty = !0
        }
    }),
    t.RenderTexture = function(e, i, s, n, r, o, a, h) {
        if (void 0 === i && (i = 100), void 0 === s && (s = 100), void 0 === n && (n = ""), void 0 === r && (r = t.scaleModes.DEFAULT), void 0 === o && (o = 1), void 0 === a && (a = PIXI.defaultRenderer), void 0 === h && (h = 0), this.game = e, this.key = n, this.type = t.RENDERTEXTURE, this._tempMatrix = new t.Matrix, this.width = i, this.height = s, this.resolution = o, this.frame = new t.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = r, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = a, this.renderer.type === t.WEBGL) {
            var l = this.renderer.gl;
            this.baseTexture.textureIndex = h,
            this.baseTexture._dirty[l.id] = !1,
            this.textureBuffer = new PIXI.FilterTexture(l, this.width, this.height, this.baseTexture.scaleMode, h),
            this.baseTexture._glTextures[l.id] = this.textureBuffer.texture,
            this.projection = new t.Point(.5 * this.width, .5 * -this.height)
        } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution),
        this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0,
        this.tempMatrix = new t.Matrix,
        this._updateUvs()
    },
    t.RenderTexture.prototype = Object.create(PIXI.Texture.prototype),
    t.RenderTexture.prototype.constructor = t.RenderTexture,
    t.RenderTexture.prototype.renderXY = function(e, i, s, n) {
        e.updateTransform(),
        this._tempMatrix.copyFrom(e.worldTransform),
        this._tempMatrix.tx = i,
        this._tempMatrix.ty = s,
        this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, n) : this._renderCanvas(e, this._tempMatrix, n)
    },
    t.RenderTexture.prototype.renderRawXY = function(e, i, s, n) {
        this._tempMatrix.identity().translate(i, s),
        this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, n) : this._renderCanvas(e, this._tempMatrix, n)
    },
    t.RenderTexture.prototype.render = function(e, i, s) {
        null == i ? this._tempMatrix.copyFrom(e.worldTransform) : this._tempMatrix.copyFrom(i),
        this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, s) : this._renderCanvas(e, this._tempMatrix, s)
    },
    t.RenderTexture.prototype.resize = function(e, i, s) {
        e === this.width && i === this.height || (this.valid = e > 0 && i > 0, this.width = e, this.height = i, this.frame.width = this.crop.width = e * this.resolution, this.frame.height = this.crop.height = i * this.resolution, s && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === t.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
    },
    t.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === t.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
    },
    t.RenderTexture.prototype._renderWebGL = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(),
            s.translate(0, 2 * this.projection.y),
            e && s.append(e),
            s.scale(1, -1);
            for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            var r = this.renderer.gl;
            r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution),
            r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            i && this.textureBuffer.clear(),
            this.renderer.spriteBatch.dirty = !0,
            this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e),
            this.renderer.spriteBatch.dirty = !0,
            r.bindFramebuffer(r.FRAMEBUFFER, null)
        }
    },
    t.RenderTexture.prototype._renderCanvas = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(),
            e && s.append(e);
            for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            i && this.textureBuffer.clear();
            var r = this.renderer.resolution;
            this.renderer.resolution = this.resolution,
            this.renderer.renderDisplayObject(t, this.textureBuffer.context, e),
            this.renderer.resolution = r
        }
    },
    t.RenderTexture.prototype.getImage = function() {
        var t = new Image;
        return t.src = this.getBase64(),
        t
    },
    t.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL()
    },
    t.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === t.WEBGL) {
            var e = this.renderer.gl,
            i = this.textureBuffer.width,
            s = this.textureBuffer.height,
            n = new Uint8Array(4 * i * s);
            e.bindFramebuffer(e.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, n),
            e.bindFramebuffer(e.FRAMEBUFFER, null);
            var r = new PIXI.CanvasBuffer(i, s),
            o = r.context.getImageData(0, 0, i, s);
            return o.data.set(n),
            r.context.putImageData(o, 0, 0),
            r.canvas
        }
        return this.textureBuffer.canvas
    },
    t.Text = function(e, i, s, n, r) {
        i = i || 0,
        s = s || 0,
        n = null == n ? "": n.toString(),
        this.canvas = t.CanvasPool.create(this),
        t.Sprite.call(this, e, i, s, PIXI.Texture.fromCanvas(this.canvas)),
        this.type = t.TEXT,
        this.physicsType = t.SPRITE,
        this.padding = new t.Point,
        this.textBounds = null,
        this.context = this.canvas.getContext("2d"),
        this.colors = [],
        this.strokeColors = [],
        this.fontStyles = [],
        this.fontWeights = [],
        this.autoRound = !1,
        this.useAdvancedWrap = !1,
        this.splitRegExp = /(?:\r\n|\r|\n)/,
        this.characterLimitSize = -1,
        this.characterLimitSuffix = "",
        this._testString = "|Mq",
        this._res = e.renderer.resolution,
        this._text = n,
        this._fontComponents = null,
        this._lineSpacing = 0,
        this._charCount = 0,
        this._width = 0,
        this._height = 0,
        this.style = {},
        this.setStyle(r || {}),
        "" !== n && this.updateText()
    },
    t.Text.prototype = Object.create(t.Sprite.prototype),
    t.Text.prototype.constructor = t.Text,
    t.Text.prototype.preUpdate = function() {
        return !! (this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.Text.prototype.update = function() {},
    t.Text.prototype.destroy = function(e) {
        this.texture.destroy(!0),
        t.Component.Destroy.prototype.destroy.call(this, e)
    },
    t.Text.prototype.setShadow = function(t, e, i, s, n, r) {
        return void 0 === t && (t = 0),
        void 0 === e && (e = 0),
        void 0 === i && (i = "rgba(0, 0, 0, 1)"),
        void 0 === s && (s = 0),
        void 0 === n && (n = !0),
        void 0 === r && (r = !0),
        this.style.shadowOffsetX = t,
        this.style.shadowOffsetY = e,
        this.style.shadowColor = i,
        this.style.shadowBlur = s,
        this.style.shadowStroke = n,
        this.style.shadowFill = r,
        this.dirty = !0,
        this
    },
    t.Text.prototype.setStyle = function(t, e) {
        void 0 === e && (e = !1);
        var i = Object.assign({},
        t);
        i.font = t.font || "bold 20pt Arial",
        i.backgroundColor = t.backgroundColor || null,
        i.fill = t.fill || "black",
        i.align = (t.align || "left").toLowerCase(),
        i.boundsAlignH = (t.boundsAlignH || "left").toLowerCase(),
        i.boundsAlignV = (t.boundsAlignV || "top").toLowerCase(),
        i.stroke = t.stroke || "black",
        i.strokeThickness = Number(t.strokeThickness) || 0,
        i.wordWrap = t.wordWrap || !1,
        i.wordWrapWidth = t.wordWrapWidth || 100,
        i.maxLines = t.maxLines || 0,
        i.shadowOffsetX = t.shadowOffsetX || 0,
        i.shadowOffsetY = t.shadowOffsetY || 0,
        i.shadowColor = t.shadowColor || "rgba(0,0,0,0)",
        i.shadowBlur = t.shadowBlur || 0,
        i.tabs = t.tabs || 0;
        var s = this.fontToComponents(i.font);
        return i.fontStyle && (s.fontStyle = i.fontStyle),
        i.fontVariant && (s.fontVariant = i.fontVariant),
        i.fontWeight && (s.fontWeight = i.fontWeight),
        i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"), s.fontSize = i.fontSize),
        this._fontComponents = s,
        i.font = this.componentsToFont(this._fontComponents),
        this.style = i,
        this.dirty = !0,
        e && this.updateText(),
        this
    },
    t.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this._res,
        this.context.font = this.style.font;
        var t = this.text;
        this.characterLimitSize > -1 && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix),
        this.style.wordWrap && (t = this.runWordWrap(this.text));
        var e = t.split(this.splitRegExp),
        i = this.style.tabs,
        s = [],
        n = 0,
        r = this.determineFontProperties(this.style.font),
        o = e.length;
        this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines),
        this._charCount = 0;
        for (var a = 0; a < o; a++) {
            if (0 === i) l = this.style.strokeThickness + this.padding.x,
            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(e[a]) : l += this.context.measureText(e[a]).width,
            this.style.wordWrap && (l -= this.context.measureText(" ").width);
            else {
                var h = e[a].split(/(?:\t)/),
                l = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(i)) for (var c = 0,
                u = 0; u < h.length; u++) {
                    var d;
                    d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[u]) : Math.ceil(this.context.measureText(h[u]).width),
                    u > 0 && (c += i[u - 1]),
                    l = c + d
                } else for (u = 0; u < h.length; u++) this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(h[u]) : l += Math.ceil(this.context.measureText(h[u]).width),
                l += this.game.math.snapToCeil(l, i) - l
            }
            s[a] = Math.ceil(l),
            n = Math.max(n, s[a])
        }
        this.canvas.width = n * this._res;
        var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y,
        m = g * o,
        y = this._lineSpacing;
        for (y < 0 && Math.abs(y) > g && (y = -g), 0 !== y && (m += y > 0 ? y * e.length: y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", this._charCount = 0, a = 0; a < o; a++) p = this.style.strokeThickness / 2,
        f = this.style.strokeThickness / 2 + a * g + r.ascent,
        a > 0 && (f += y * a),
        "right" === this.style.align ? p += n - s[a] : "center" === this.style.align && (p += (n - s[a]) / 2),
        this.autoRound && (p = Math.round(p), f = Math.round(f)),
        this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
        this.updateTexture(),
        this.dirty = !1
    },
    t.Text.prototype.renderTabLine = function(t, e, i, s) {
        var n = t.split(/(?:\t)/),
        r = this.style.tabs,
        o = 0;
        if (Array.isArray(r)) for (var a = 0,
        h = 0; h < n.length; h++) h > 0 && (a += r[h - 1]),
        o = e + a,
        s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
        else for (h = 0; h < n.length; h++) {
            var l = Math.ceil(this.context.measureText(n[h]).width);
            o = this.game.math.snapToCeil(e, r),
            s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i),
            e = o + l
        }
    },
    t.Text.prototype.updateShadow = function(t) {
        t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
    },
    t.Text.prototype.measureLine = function(t) {
        for (var e = 0,
        i = 0; i < t.length; i++) {
            var s = t[i];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var n = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]),
                this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]),
                this.context.font = this.componentsToFont(n)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)),
            e += this.context.measureText(s).width,
            this._charCount++
        }
        return Math.ceil(e)
    },
    t.Text.prototype.updateLine = function(t, e, i) {
        for (var s = 0; s < t.length; s++) {
            var n = t[s];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var r = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]),
                this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]),
                this.context.font = this.componentsToFont(r)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)),
            e += this.context.measureText(n).width,
            this._charCount++
        }
    },
    t.Text.prototype.clearColors = function() {
        return this.colors = [],
        this.strokeColors = [],
        this.dirty = !0,
        this
    },
    t.Text.prototype.clearFontValues = function() {
        return this.fontStyles = [],
        this.fontWeights = [],
        this.dirty = !0,
        this
    },
    t.Text.prototype.addColor = function(t, e) {
        return this.colors[e] = t,
        this.dirty = !0,
        this
    },
    t.Text.prototype.addStrokeColor = function(t, e) {
        return this.strokeColors[e] = t,
        this.dirty = !0,
        this
    },
    t.Text.prototype.addFontStyle = function(t, e) {
        return this.fontStyles[e] = t,
        this.dirty = !0,
        this
    },
    t.Text.prototype.addFontWeight = function(t, e) {
        return this.fontWeights[e] = t,
        this.dirty = !0,
        this
    },
    t.Text.prototype.precalculateWordWrap = function(t) {
        return this.texture.baseTexture.resolution = this._res,
        this.context.font = this.style.font,
        this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
    },
    t.Text.prototype.runWordWrap = function(t) {
        return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
    },
    t.Text.prototype.advancedWordWrap = function(t) {
        for (var e = this.context,
        i = this.style.wordWrapWidth,
        s = "",
        n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
            var a = n[o],
            h = "";
            if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) s += a + "\n";
            else {
                for (var l = i,
                c = a.split(" "), u = 0; u < c.length; u++) {
                    var d = c[u],
                    p = d + " ",
                    f = e.measureText(p).width;
                    if (f > l) {
                        if (0 === u) {
                            for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l)););
                            if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                            var m = d.substr(g.length);
                            c[u] = m,
                            h += g
                        }
                        var y = c[u].length ? u: u + 1,
                        v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                        n[o + 1] = v + " " + (n[o + 1] || ""),
                        r = n.length;
                        break
                    }
                    h += p,
                    l -= f
                }
                s += h.replace(/[ \n]*$/gi, "") + "\n"
            }
        }
        return s.replace(/[\s|\n]*$/gi, "")
    },
    t.Text.prototype.basicWordWrap = function(t) {
        for (var e = "",
        i = t.split("\n"), s = 0; s < i.length; s++) {
            for (var n = this.style.wordWrapWidth,
            r = i[s].split(" "), o = 0; o < r.length; o++) {
                var a = this.context.measureText(r[o]).width,
                h = a + this.context.measureText(" ").width;
                h > n ? (o > 0 && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
            }
            s < i.length - 1 && (e += "\n")
        }
        return e
    },
    t.Text.prototype.updateFont = function(t) {
        var e = this.componentsToFont(t);
        this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
    },
    t.Text.prototype.fontToComponents = function(t) {
        var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        if (e) {
            var i = e[5].trim();
            return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"),
            {
                font: t,
                fontStyle: e[1] || "normal",
                fontVariant: e[2] || "normal",
                fontWeight: e[3] || "normal",
                fontSize: e[4] || "medium",
                fontFamily: i
            }
        }
        return console.warn("Phaser.Text - unparsable CSS font: " + t),
        {
            font: t
        }
    },
    t.Text.prototype.componentsToFont = function(t) {
        var e, i = [];
        return (e = t.fontStyle) && "normal" !== e && i.push(e),
        (e = t.fontVariant) && "normal" !== e && i.push(e),
        (e = t.fontWeight) && "normal" !== e && i.push(e),
        (e = t.fontSize) && "medium" !== e && i.push(e),
        (e = t.fontFamily) && i.push(e),
        i.length || i.push(t.font),
        i.join(" ")
    },
    t.Text.prototype.setText = function(t, e) {
        return void 0 === e && (e = !1),
        (t = t.toString() || "") === this._text ? this: (this.text = t, e ? this.updateText() : this.dirty = !0, this)
    },
    t.Text.prototype.parseList = function(t) {
        if (!Array.isArray(t)) return this;
        for (var e = "",
        i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
        return this.text = e,
        this.dirty = !0,
        this
    },
    t.Text.prototype.setTextBounds = function(e, i, s, n) {
        return void 0 === e ? this.textBounds = null: (this.textBounds ? this.textBounds.setTo(e, i, s, n) : this.textBounds = new t.Rectangle(e, i, s, n), this.style.wordWrapWidth > s && (this.style.wordWrapWidth = s)),
        this.updateTexture(),
        this
    },
    t.Text.prototype.updateTexture = function() {
        var t = this.texture.baseTexture,
        e = this.texture.crop,
        i = this.texture.frame,
        s = this.canvas.width,
        n = this.canvas.height;
        if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
            var r = this.textBounds.x,
            o = this.textBounds.y;
            "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution: "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2),
            "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution: "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2),
            this.pivot.x = -r,
            this.pivot.y = -o
        }
        this.renderable = 0 !== s && 0 !== n,
        this.texture.requiresReTint = !0,
        this.texture.baseTexture.dirty()
    },
    t.Text.prototype._renderWebGL = function(t) {
        this.dirty && (this.updateText(), this.dirty = !1),
        PIXI.Sprite.prototype._renderWebGL.call(this, t)
    },
    t.Text.prototype._renderCanvas = function(t) {
        this.dirty && (this.updateText(), this.dirty = !1),
        PIXI.Sprite.prototype._renderCanvas.call(this, t)
    },
    t.Text.prototype.determineFontProperties = function(e) {
        var i = t.Text.fontPropertiesCache[e],
        s = this.testString || "|Mq";
        if (!i) {
            i = {};
            var n = t.Text.fontPropertiesCanvas,
            r = t.Text.fontPropertiesContext;
            r.font = e;
            var o = Math.ceil(r.measureText(s).width),
            a = Math.ceil(r.measureText(s).width),
            h = 2 * a;
            if (a = 1.4 * a | 0, n.width = o, n.height = h, r.fillStyle = "#f00", r.fillRect(0, 0, o, h), r.font = e, r.textBaseline = "alphabetic", r.fillStyle = "#000", r.fillText(s, 0, a), !r.getImageData(0, 0, o, h)) return i.ascent = a,
            i.descent = a + 6,
            i.fontSize = i.ascent + i.descent,
            t.Text.fontPropertiesCache[e] = i,
            i;
            var l, c, u = r.getImageData(0, 0, o, h).data,
            d = u.length,
            p = 4 * o,
            f = 0,
            g = !1;
            for (l = 0; l < a; l++) {
                for (c = 0; c < p; c += 4) if (255 !== u[f + c]) {
                    g = !0;
                    break
                }
                if (g) break;
                f += p
            }
            for (i.ascent = a - l, f = d - p, g = !1, l = h; l > a; l--) {
                for (c = 0; c < p; c += 4) if (255 !== u[f + c]) {
                    g = !0;
                    break
                }
                if (g) break;
                f -= p
            }
            i.descent = l - a,
            i.descent += 6,
            i.fontSize = i.ascent + i.descent,
            t.Text.fontPropertiesCache[e] = i
        }
        return i
    },
    t.Text.prototype.getBounds = function(t) {
        return this.dirty && (this.updateText(), this.dirty = !1),
        PIXI.Sprite.prototype.getBounds.call(this, t)
    },
    t.Text.prototype.setCharacterLimit = function(t, e) {
        this.characterLimitSuffix = void 0 === e ? "": e,
        this.characterLimitSize = t,
        this.updateText()
    },
    Object.defineProperty(t.Text.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(t) {
            t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
        }
    }),
    Object.defineProperty(t.Text.prototype, "cssFont", {
        get: function() {
            return this.componentsToFont(this._fontComponents)
        },
        set: function(t) {
            t = t || "bold 20pt Arial",
            this._fontComponents = this.fontToComponents(t),
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "font", {
        get: function() {
            return this._fontComponents.fontFamily
        },
        set: function(t) {
            t = (t = t || "Arial").trim(),
            /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"),
            this._fontComponents.fontFamily = t,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "fontSize", {
        get: function() {
            var t = this._fontComponents.fontSize;
            return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
        },
        set: function(t) {
            "number" == typeof(t = t || "0") && (t += "px"),
            this._fontComponents.fontSize = t,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontComponents.fontWeight || "normal"
        },
        set: function(t) {
            t = t || "normal",
            this._fontComponents.fontWeight = t,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "fontStyle", {
        get: function() {
            return this._fontComponents.fontStyle || "normal"
        },
        set: function(t) {
            t = t || "normal",
            this._fontComponents.fontStyle = t,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "fontVariant", {
        get: function() {
            return this._fontComponents.fontVariant || "normal"
        },
        set: function(t) {
            t = t || "normal",
            this._fontComponents.fontVariant = t,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(t.Text.prototype, "fill", {
        get: function() {
            return this.style.fill
        },
        set: function(t) {
            t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "align", {
        get: function() {
            return this.style.align
        },
        set: function(t) { (t = t.toLowerCase()) !== this.style.align && (this.style.align = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "resolution", {
        get: function() {
            return this._res
        },
        set: function(t) {
            t !== this._res && (this._res = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "tabs", {
        get: function() {
            return this.style.tabs
        },
        set: function(t) {
            t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "boundsAlignH", {
        get: function() {
            return this.style.boundsAlignH
        },
        set: function(t) { (t = t.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "boundsAlignV", {
        get: function() {
            return this.style.boundsAlignV
        },
        set: function(t) { (t = t.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke
        },
        set: function(t) {
            t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness
        },
        set: function(t) {
            t !== this.style.strokeThickness && (this.style.strokeThickness = Number(t), this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap
        },
        set: function(t) {
            t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth
        },
        set: function(t) {
            t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing
        },
        set: function(t) {
            t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX
        },
        set: function(t) {
            t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY
        },
        set: function(t) {
            t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor
        },
        set: function(t) {
            t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur
        },
        set: function(t) {
            t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowStroke", {
        get: function() {
            return this.style.shadowStroke
        },
        set: function(t) {
            t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "shadowFill", {
        get: function() {
            return this.style.shadowFill
        },
        set: function(t) {
            t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
        }
    }),
    Object.defineProperty(t.Text.prototype, "width", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1),
            this.scale.x * (this.texture.frame.width / this.resolution)
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width,
            this._width = t
        }
    }),
    Object.defineProperty(t.Text.prototype, "height", {
        get: function() {
            return this.dirty && (this.updateText(), this.dirty = !1),
            this.scale.y * (this.texture.frame.height / this.resolution)
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height,
            this._height = t
        }
    }),
    Object.defineProperty(t.Text.prototype, "testString", {
        get: function() {
            return this._testString
        },
        set: function(t) {
            this._testString = t,
            this.updateText()
        }
    }),
    t.Text.fontPropertiesCache = {},
    t.Text.fontPropertiesCanvas = document.createElement("canvas"),
    t.Text.fontPropertiesContext = t.Text.fontPropertiesCanvas.getContext("2d"),
    t.BitmapText = function(e, i, s, n, r, o, a) {
        i = i || 0,
        s = s || 0,
        n = n || "",
        r = r || "",
        o = o || 32,
        a = a || "left",
        PIXI.DisplayObjectContainer.call(this),
        this.type = t.BITMAPTEXT,
        this.physicsType = t.SPRITE,
        this.textWidth = 0,
        this.textHeight = 0,
        this.anchor = new t.Point,
        this._prevAnchor = new t.Point,
        this._glyphs = [],
        this._maxWidth = 0,
        this._text = r.toString() || "",
        this._data = e.cache.getBitmapFont(n),
        this._font = n,
        this._fontSize = o,
        this._align = a,
        this._letterSpacing = 0,
        this._tint = 16777215,
        this.updateText(),
        this.dirty = !1,
        t.Component.Core.init.call(this, e, i, s, "", null)
    },
    t.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    t.BitmapText.prototype.constructor = t.BitmapText,
    t.Component.Core.install.call(t.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
    t.BitmapText.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate,
    t.BitmapText.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.BitmapText.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.BitmapText.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.BitmapText.prototype.preUpdate = function() {
        return !! (this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.BitmapText.prototype.postUpdate = function() {
        t.Component.PhysicsBody.postUpdate.call(this),
        t.Component.FixedToCamera.postUpdate.call(this),
        this.body && this.body.type === t.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
    },
    t.BitmapText.prototype.setText = function(t) {
        this.text = t
    },
    t.BitmapText.prototype.scanLine = function(t, e, i) {
        for (var s = 0,
        n = 0,
        r = -1,
        o = 0,
        a = null,
        h = this._maxWidth > 0 ? this._maxWidth: null, l = [], c = 0; c < i.length; c++) {
            var u = c === i.length - 1;
            if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                width: n,
                text: i.substr(0, c),
                end: u,
                chars: l
            };
            var d, p = i.charCodeAt(c),
            f = t.chars[p];
            void 0 === f && (p = 32, f = t.chars[p]);
            var g = a && f.kerning[a] ? f.kerning[a] : 0;
            if (/(\s)/.test(i.charAt(c)) && (r = c, o = n), d = (g + f.texture.width + f.xOffset) * e, h && n + d >= h && r > -1) return {
                width: o || n,
                text: i.substr(0, c - (c - r)),
                end: !1,
                chars: l
            };
            n += (f.xAdvance + g + this.letterSpacing) * e,
            l.push(s + (f.xOffset + g + this.letterSpacing) * e),
            s += (f.xAdvance + g + this.letterSpacing) * e,
            a = p
        }
        return {
            width: n,
            text: i,
            end: u,
            chars: l
        }
    },
    t.BitmapText.prototype.cleanText = function(t, e) {
        void 0 === e && (e = "");
        var i = this._data.font;
        if (!i) return "";
        for (var s = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), n = 0; n < s.length; n++) {
            for (var r = "",
            o = s[n], a = 0; a < o.length; a++) r = i.chars[o.charCodeAt(a)] ? r.concat(o[a]) : r.concat(e);
            s[n] = r
        }
        return s.join("\n")
    },
    t.BitmapText.prototype.updateText = function() {
        var t = this._data.font;
        if (t) {
            var e = this.text,
            i = this._fontSize / t.size,
            s = [],
            n = 0;
            this.textWidth = 0;
            do { (c = this.scanLine(t, i, e)).y = n, s.push(c), c.width > this.textWidth && (this.textWidth = c.width), n += t.lineHeight * i, e = e.substr(c.text.length + 1)
            } while (! 1 === c . end );
            this.textHeight = n;
            for (var r = 0,
            o = 0,
            a = this.textWidth * this.anchor.x,
            h = this.textHeight * this.anchor.y,
            l = 0; l < s.length; l++) {
                var c = s[l];
                "right" === this._align ? o = this.textWidth - c.width: "center" === this._align && (o = (this.textWidth - c.width) / 2);
                for (var u = 0; u < c.text.length; u++) {
                    var d = c.text.charCodeAt(u),
                    p = t.chars[d];
                    void 0 === p && (d = 32, p = t.chars[d]);
                    var f = this._glyphs[r];
                    f ? f.texture = p.texture: ((f = new PIXI.Sprite(p.texture)).name = c.text[u], this._glyphs.push(f)),
                    f.position.x = c.chars[u] + o - a,
                    f.position.y = c.y + p.yOffset * i - h,
                    f.scale.set(i),
                    f.tint = this.tint,
                    f.texture.requiresReTint = !0,
                    f.cachedTint = 16777215,
                    f.parent || this.addChild(f),
                    r++
                }
            }
            for (l = r; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
        }
    },
    t.BitmapText.prototype.purgeGlyphs = function() {
        for (var t = this._glyphs.length,
        e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
        return this._glyphs = [],
        this._glyphs = e,
        this.updateText(),
        t - e.length
    },
    t.BitmapText.prototype.updateTransform = function() { ! this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)),
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
    },
    Object.defineProperty(t.BitmapText.prototype, "letterSpacing", {
        get: function() {
            return this._letterSpacing
        },
        set: function(t) {
            "number" == typeof t && (this._letterSpacing = t, this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "align", {
        get: function() {
            return this._align
        },
        set: function(t) {
            t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint
        },
        set: function(t) {
            t !== this._tint && (this._tint = t, this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(t) {
            t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(t) { (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(t) {
            t !== this._text && (this._text = t.toString() || "", this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "maxWidth", {
        get: function() {
            return this._maxWidth
        },
        set: function(t) {
            t !== this._maxWidth && (this._maxWidth = t, this.updateText())
        }
    }),
    Object.defineProperty(t.BitmapText.prototype, "smoothed", {
        get: function() {
            return ! this._data.base.scaleMode
        },
        set: function(t) {
            this._data.base.scaleMode = t ? 0 : 1,
            this._data.base.dirty()
        }
    }),
    t.RetroFont = function(e, i, s, n, r, o, a, h, l, c) {
        if (!e.cache.checkImageKey(i)) return ! 1;
        null != o || (o = e.cache.getImage(i).width / s),
        this.characterWidth = s,
        this.characterHeight = n,
        this.characterSpacingX = a || 0,
        this.characterSpacingY = h || 0,
        this.characterPerRow = o,
        this.offsetX = l || 0,
        this.offsetY = c || 0,
        this.align = "left",
        this.multiLine = !1,
        this.autoUpperCase = !0,
        this.customSpacingX = 0,
        this.customSpacingY = 0,
        this.fixedWidth = 0,
        this.fontSet = e.cache.getImage(i),
        this._text = "",
        this.grabData = [],
        this.frameData = new t.FrameData;
        for (var u = this.offsetX,
        d = this.offsetY,
        p = 0,
        f = 0; f < r.length; f++) {
            var g = this.frameData.addFrame(new t.Frame(f, u, d, this.characterWidth, this.characterHeight));
            this.grabData[r.charCodeAt(f)] = g.index,
            ++p === this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
        }
        e.cache.updateFrameData(i, this.frameData),
        this.stamp = new t.Image(e, 0, 0, i, 0),
        t.RenderTexture.call(this, e, 100, 100, "", t.scaleModes.NEAREST),
        this.type = t.RETROFONT
    },
    t.RetroFont.prototype = Object.create(t.RenderTexture.prototype),
    t.RetroFont.prototype.constructor = t.RetroFont,
    t.RetroFont.ALIGN_LEFT = "left",
    t.RetroFont.ALIGN_RIGHT = "right",
    t.RetroFont.ALIGN_CENTER = "center",
    t.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
    t.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    t.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
    t.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
    t.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
    t.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
    t.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
    t.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    t.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
    t.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    t.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
    t.RetroFont.prototype.setFixedWidth = function(t, e) {
        void 0 === e && (e = "left"),
        this.fixedWidth = t,
        this.align = e
    },
    t.RetroFont.prototype.setText = function(t, e, i, s, n, r) {
        this.multiLine = e || !1,
        this.customSpacingX = i || 0,
        this.customSpacingY = s || 0,
        this.align = n || "left",
        this.autoUpperCase = !r,
        t.length > 0 && (this.text = t)
    },
    t.RetroFont.prototype.buildRetroFontText = function() {
        var e = 0,
        i = 0;
        if (this.clear(), this.multiLine) {
            var s = this._text.split("\n");
            this.fixedWidth > 0 ? this.resize(this.fixedWidth, s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
            for (var n = 0; n < s.length; n++) e = 0,
            this.align === t.RetroFont.ALIGN_RIGHT ? e = this.width - s[n].length * (this.characterWidth + this.customSpacingX) : this.align === t.RetroFont.ALIGN_CENTER && (e = this.width / 2 - s[n].length * (this.characterWidth + this.customSpacingX) / 2, e += this.customSpacingX / 2),
            e < 0 && (e = 0),
            this.pasteLine(s[n], e, i, this.customSpacingX),
            i += this.characterHeight + this.customSpacingY
        } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0),
        e = 0,
        this.align === t.RetroFont.ALIGN_RIGHT ? e = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === t.RetroFont.ALIGN_CENTER && (e = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, e += this.customSpacingX / 2),
        e < 0 && (e = 0),
        this.pasteLine(this._text, e, 0, this.customSpacingX);
        this.requiresReTint = !0
    },
    t.RetroFont.prototype.pasteLine = function(t, e, i, s) {
        for (var n = 0; n < t.length; n++) if (" " === t.charAt(n)) e += this.characterWidth + s;
        else if (this.grabData[t.charCodeAt(n)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
    },
    t.RetroFont.prototype.getLongestLine = function() {
        var t = 0;
        if (this._text.length > 0) for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
        return t
    },
    t.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
        for (var e = "",
        i = 0; i < this._text.length; i++) {
            var s = this._text[i],
            n = s.charCodeAt(0); (this.grabData[n] >= 0 || !t && "\n" === s) && (e = e.concat(s))
        }
        return e
    },
    t.RetroFont.prototype.updateOffset = function(t, e) {
        if (this.offsetX !== t || this.offsetY !== e) {
            for (var i = t - this.offsetX,
            s = e - this.offsetY,
            n = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = n.length; r--;) n[r].x += i,
            n[r].y += s;
            this.buildRetroFontText()
        }
    },
    Object.defineProperty(t.RetroFont.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(t) {
            var e; (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
        }
    }),
    Object.defineProperty(t.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed
        },
        set: function(t) {
            this.stamp.smoothed = t,
            this.buildRetroFontText()
        }
    }),
    t.Rope = function(e, i, s, n, r, o) {
        this.points = o || [],
        this._hasUpdateAnimation = !1,
        this._updateAnimationCallback = null,
        i = i || 0,
        s = s || 0,
        n = n || null,
        r = r || null,
        this.type = t.ROPE,
        PIXI.DisplayObjectContainer.call(this),
        this.texture = t.Cache.DEFAULT,
        this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]),
        this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
        this.colors = new Float32Array([1, 1, 1, 1]),
        this.indices = new Uint16Array([0, 1, 2, 3]),
        o && (this.vertices = new Float32Array(4 * o.length), this.uvs = new Float32Array(4 * o.length), this.colors = new Float32Array(2 * o.length), this.indices = new Uint16Array(2 * o.length)),
        this.dirty = !0,
        this.canvasPadding = 0,
        this.drawMode = t.Rope.TRIANGLE_STRIP,
        t.Component.Core.init.call(this, e, i, s, n, r),
        this.refresh()
    },
    t.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    t.Rope.prototype.constructor = t.Rope,
    t.Component.Core.install.call(t.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
    t.Rope.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate,
    t.Rope.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.Rope.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.Rope.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.Rope.TRIANGLE_STRIP = 0,
    t.Rope.TRIANGLES = 1,
    t.Rope.prototype.preUpdate = function() {
        return !! (this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.Rope.prototype.update = function() {
        this._hasUpdateAnimation && this.updateAnimation.call(this)
    },
    t.Rope.prototype.reset = function(e, i) {
        return t.Component.Reset.prototype.reset.call(this, e, i),
        this
    },
    t.Rope.prototype.refresh = function() {
        var t = this.points;
        if (! (t.length < 1)) {
            var e = this.uvs,
            i = this.indices,
            s = this.colors;
            this.count -= .2,
            e[0] = 0,
            e[1] = 0,
            e[2] = 0,
            e[3] = 1,
            s[0] = 1,
            s[1] = 1,
            i[0] = 0,
            i[1] = 1;
            for (var n, r, o = t.length,
            a = 1; a < o; a++) r = a / (o - 1),
            e[n = 4 * a] = r,
            e[n + 1] = 0,
            e[n + 2] = r,
            e[n + 3] = 1,
            s[n = 2 * a] = 1,
            s[n + 1] = 1,
            i[n = 2 * a] = n,
            i[n + 1] = n + 1
        }
    },
    t.Rope.prototype.updateTransform = function() {
        var t = this.points;
        if (! (t.length < 1)) {
            var e, i = t[0],
            s = {
                x: 0,
                y: 0
            };
            this.count -= .2;
            for (var n, r, o, a, h = this.vertices,
            l = t.length,
            c = 0; c < l; c++) n = t[c],
            r = 4 * c,
            e = c < t.length - 1 ? t[c + 1] : n,
            s.y = -(e.x - i.x),
            s.x = e.y - i.y,
            o = Math.sqrt(s.x * s.x + s.y * s.y),
            a = this.texture.height / 2,
            s.x /= o,
            s.y /= o,
            s.x *= a,
            s.y *= a,
            h[r] = n.x + s.x,
            h[r + 1] = n.y + s.y,
            h[r + 2] = n.x - s.x,
            h[r + 3] = n.y - s.y,
            i = n;
            PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    },
    t.Rope.prototype.setTexture = function(t) {
        this.texture = t
    },
    t.Rope.prototype._renderWebGL = function(t) { ! this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
    },
    t.Rope.prototype._initWebGL = function(t) {
        var e = t.gl;
        this._vertexBuffer = e.createBuffer(),
        this._indexBuffer = e.createBuffer(),
        this._uvBuffer = e.createBuffer(),
        this._colorBuffer = e.createBuffer(),
        e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer),
        e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW),
        e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer),
        e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW),
        e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer),
        e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW),
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
        e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
    },
    t.Rope.prototype._renderStrip = function(e) {
        var i = e.gl,
        s = e.projection,
        n = e.offset,
        r = e.shaderManager.stripShader,
        o = this.drawMode === t.Rope.TRIANGLE_STRIP ? i.TRIANGLE_STRIP: i.TRIANGLES;
        e.blendModeManager.setBlendMode(this.blendMode),
        i.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)),
        i.uniform2f(r.projectionVector, s.x, -s.y),
        i.uniform2f(r.offsetVector, -n.x, -n.y),
        i.uniform1f(r.alpha, this.worldAlpha),
        this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? e.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? e.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)),
        i.drawElements(o, this.indices.length, i.UNSIGNED_SHORT, 0)
    },
    t.Rope.prototype._renderCanvas = function(e) {
        var i = e.context,
        s = this.worldTransform,
        n = s.tx * e.resolution + e.shakeX,
        r = s.ty * e.resolution + e.shakeY;
        e.roundPixels ? i.setTransform(s.a, s.b, s.c, s.d, 0 | n, 0 | r) : i.setTransform(s.a, s.b, s.c, s.d, n, r),
        this.drawMode === t.Rope.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
    },
    t.Rope.prototype._renderCanvasTriangleStrip = function(t) {
        var e = this.vertices,
        i = this.uvs,
        s = e.length / 2;
        this.count++;
        for (var n = 0; n < s - 2; n++) {
            var r = 2 * n;
            this._renderCanvasDrawTriangle(t, e, i, r, r + 2, r + 4)
        }
    },
    t.Rope.prototype._renderCanvasTriangles = function(t) {
        var e = this.vertices,
        i = this.uvs,
        s = this.indices,
        n = s.length;
        this.count++;
        for (var r = 0; r < n; r += 3) {
            var o = 2 * s[r],
            a = 2 * s[r + 1],
            h = 2 * s[r + 2];
            this._renderCanvasDrawTriangle(t, e, i, o, a, h)
        }
    },
    t.Rope.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, r) {
        var o = this.texture.baseTexture.source,
        a = this.texture.width,
        h = this.texture.height,
        l = e[s],
        c = e[n],
        u = e[r],
        d = e[s + 1],
        p = e[n + 1],
        f = e[r + 1],
        g = i[s] * a,
        m = i[n] * a,
        y = i[r] * a,
        v = i[s + 1] * h,
        x = i[n + 1] * h,
        b = i[r + 1] * h;
        if (this.canvasPadding > 0) {
            var _ = this.canvasPadding / this.worldTransform.a,
            w = this.canvasPadding / this.worldTransform.d,
            T = (l + c + u) / 3,
            P = (d + p + f) / 3,
            C = l - T,
            S = d - P,
            A = Math.sqrt(C * C + S * S);
            l = T + C / A * (A + _),
            d = P + S / A * (A + w),
            S = p - P,
            c = T + (C = c - T) / (A = Math.sqrt(C * C + S * S)) * (A + _),
            p = P + S / A * (A + w),
            S = f - P,
            u = T + (C = u - T) / (A = Math.sqrt(C * C + S * S)) * (A + _),
            f = P + S / A * (A + w)
        }
        t.save(),
        t.beginPath(),
        t.moveTo(l, d),
        t.lineTo(c, p),
        t.lineTo(u, f),
        t.closePath(),
        t.clip();
        var E = g * x + v * y + m * b - x * y - v * m - g * b,
        M = l * x + v * u + c * b - x * u - v * c - l * b,
        R = g * c + l * y + m * u - c * y - l * m - g * u,
        L = g * x * u + v * c * y + l * m * b - l * x * y - v * m * u - g * c * b,
        B = d * x + v * f + p * b - x * f - v * p - d * b,
        I = g * p + d * y + m * f - p * y - d * m - g * f,
        O = g * x * f + v * p * y + d * m * b - d * x * y - v * m * f - g * p * b;
        t.transform(M / E, B / E, R / E, I / E, L / E, O / E),
        t.drawImage(o, 0, 0),
        t.restore()
    },
    t.Rope.prototype.renderStripFlat = function(t) {
        var e = this.context,
        i = t.vertices,
        s = i.length / 2;
        this.count++,
        e.beginPath();
        for (var n = 1; n < s - 2; n++) {
            var r = 2 * n,
            o = i[r],
            a = i[r + 2],
            h = i[r + 4],
            l = i[r + 1],
            c = i[r + 3],
            u = i[r + 5];
            e.moveTo(o, l),
            e.lineTo(a, c),
            e.lineTo(h, u)
        }
        e.fillStyle = "#FF0000",
        e.fill(),
        e.closePath()
    },
    t.Rope.prototype.getBounds = function(e) {
        for (var i = e || this.worldTransform,
        s = i.a,
        n = i.b,
        r = i.c,
        o = i.d,
        a = i.tx,
        h = i.ty,
        l = -1 / 0,
        c = -1 / 0,
        u = 1 / 0,
        d = 1 / 0,
        p = this.vertices,
        f = 0; f < p.length; f += 2) {
            var g = p[f],
            m = p[f + 1],
            y = s * g + r * m + a,
            v = o * m + n * g + h;
            u = y < u ? y: u,
            d = v < d ? v: d,
            l = y > l ? y: l,
            c = v > c ? v: c
        }
        if (u === -1 / 0 || c === 1 / 0) return t.EmptyRectangle;
        var x = this._bounds;
        return x.x = u,
        x.width = l - u,
        x.y = d,
        x.height = c - d,
        this._currentBounds = x,
        x
    },
    Object.defineProperty(t.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation
        },
        set: function(t) {
            t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
        }
    }),
    Object.defineProperty(t.Rope.prototype, "segments", {
        get: function() {
            for (var e, i, s, n, r, o, a, h, l = [], c = 0; c < this.points.length; c++) e = 4 * c,
            i = this.vertices[e] * this.scale.x,
            s = this.vertices[e + 1] * this.scale.y,
            n = this.vertices[e + 4] * this.scale.x,
            r = this.vertices[e + 3] * this.scale.y,
            o = t.Math.difference(i, n),
            a = t.Math.difference(s, r),
            i += this.world.x,
            s += this.world.y,
            h = new t.Rectangle(i, s, o, a),
            l.push(h);
            return l
        }
    }),
    t.TileSprite = function(e, i, s, n, r, o, a) {
        i = i || 0,
        s = s || 0,
        n = n || 256,
        r = r || 256,
        o = o || null,
        a = a || null,
        PIXI.Sprite.call(this, new PIXI.Texture(t.Cache.DEFAULT.baseTexture), n, r),
        this.type = t.TILESPRITE,
        this.physicsType = t.SPRITE,
        this._scroll = new t.Point,
        this.tileScale = new t.Point(1, 1),
        this.tileScaleOffset = new t.Point(1, 1),
        this.tilePosition = new t.Point,
        this.textureDebug = !1,
        this.canvasBuffer = null,
        this.tilingTexture = null,
        this.tilePattern = null,
        this.refreshTexture = !0,
        this.frameWidth = 0,
        this.frameHeight = 0,
        this._width = n,
        this._height = r,
        t.Component.Core.init.call(this, e, i, s, o, a)
    },
    t.TileSprite.prototype = Object.create(PIXI.Sprite.prototype),
    t.TileSprite.prototype.constructor = t.TileSprite,
    t.Component.Core.install.call(t.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]),
    t.TileSprite.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate,
    t.TileSprite.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate,
    t.TileSprite.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate,
    t.TileSprite.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.TileSprite.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed),
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed),
        !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    },
    t.TileSprite.prototype.autoScroll = function(t, e) {
        return this._scroll.set(t, e),
        this
    },
    t.TileSprite.prototype.stopScroll = function() {
        return this._scroll.set(0, 0),
        this
    },
    t.TileSprite.prototype.destroy = function(e) {
        t.Component.Destroy.prototype.destroy.call(this, e),
        PIXI.Sprite.prototype.destroy.call(this),
        this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null),
        this.tileScale = null,
        this.tileScaleOffset = null,
        this.tilePosition = null,
        this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
    },
    t.TileSprite.prototype.reset = function(e, i) {
        return t.Component.Reset.prototype.reset.call(this, e, i),
        this.tilePosition.x = 0,
        this.tilePosition.y = 0,
        this
    },
    t.TileSprite.prototype.setTexture = function(t) {
        return this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215),
        this
    },
    t.TileSprite.prototype._renderWebGL = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
            }
            t.spriteBatch.renderTilingSprite(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            var i = !1;
            this._filters && (i = !0, t.spriteBatch.stop(), t.filterManager.popFilter()),
            this._mask && (i || t.spriteBatch.stop(), t.maskManager.popMask(this._mask, t)),
            i && t.spriteBatch.start()
        }
    },
    t.TileSprite.prototype._renderCanvas = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var e = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t),
            e.globalAlpha = this.worldAlpha;
            var i = this.worldTransform,
            s = t.resolution,
            n = i.tx * s + t.shakeX,
            r = i.ty * s + t.shakeY;
            if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), 16777215 === this.tint || !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1, this.refreshTexture = !0), this.refreshTexture) {
                if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var o = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
            var a = this.tilePosition,
            h = this.tileScale;
            a.x %= this.tilingTexture.baseTexture.width,
            a.y %= this.tilingTexture.baseTexture.height,
            e.scale(h.x, h.y),
            e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height),
            e.fillStyle = this.tilePattern,
            n = -a.x,
            r = -a.y;
            var l = this._width / h.x,
            c = this._height / h.y;
            t.roundPixels && (n |= 0, r |= 0, l |= 0, c |= 0),
            e.fillRect(n, r, l, c),
            e.scale(1 / h.x, 1 / h.y),
            e.translate( - a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height),
            this._mask && t.maskManager.popMask(t);
            for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
            o !== this.blendMode && (t.currentBlendMode = o, e.globalCompositeOperation = PIXI.blendModesCanvas[o])
        }
    },
    t.TileSprite.prototype.onTextureUpdate = function() {},
    t.TileSprite.prototype.generateTilingTexture = function(e) {
        if (this.texture.baseTexture.hasLoaded) {
            var i = this.texture,
            s = i.frame,
            n = this._frame.sourceSizeW || this._frame.width,
            r = this._frame.sourceSizeH || this._frame.height,
            o = 0,
            a = 0;
            this._frame.trimmed && (o = this._frame.spriteSourceSizeX, a = this._frame.spriteSourceSizeY),
            e && (n = t.Math.getNextPowerOfTwo(n), r = t.Math.getNextPowerOfTwo(r)),
            this.canvasBuffer ? (this.canvasBuffer.resize(n, r), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(n, r), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0),
            this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, r));
            var h = i.crop.width,
            l = i.crop.height;
            h === n && l === r || (h = n, l = r);
            var c = this.tintedTexture ? this.tintedTexture: i.baseTexture.source;
            this.canvasBuffer.context.drawImage(c, i.crop.x, i.crop.y, i.crop.width, i.crop.height, o, a, h, l),
            this.tileScaleOffset.x = s.width / n,
            this.tileScaleOffset.y = s.height / r,
            this.refreshTexture = !1,
            this.tilingTexture.baseTexture._powerOf2 = !0
        }
    },
    t.TileSprite.prototype.getBounds = function() {
        var t = this._width,
        e = this._height,
        i = t * (1 - this.anchor.x),
        s = t * -this.anchor.x,
        n = e * (1 - this.anchor.y),
        r = e * -this.anchor.y,
        o = this.worldTransform,
        a = o.a,
        h = o.b,
        l = o.c,
        c = o.d,
        u = o.tx,
        d = o.ty,
        p = a * s + l * r + u,
        f = c * r + h * s + d,
        g = a * i + l * r + u,
        m = c * r + h * i + d,
        y = a * i + l * n + u,
        v = c * n + h * i + d,
        x = a * s + l * n + u,
        b = c * n + h * s + d,
        _ = -1 / 0,
        w = -1 / 0,
        T = 1 / 0,
        P = 1 / 0;
        T = x < (T = y < (T = g < (T = p < T ? p: T) ? g: T) ? y: T) ? x: T,
        P = b < (P = v < (P = m < (P = f < P ? f: P) ? m: P) ? v: P) ? b: P,
        _ = x > (_ = y > (_ = g > (_ = p > _ ? p: _) ? g: _) ? y: _) ? x: _,
        w = b > (w = v > (w = m > (w = f > w ? f: w) ? m: w) ? v: w) ? b: w;
        var C = this._bounds;
        return C.x = T,
        C.width = _ - T,
        C.y = P,
        C.height = w - P,
        this._currentBounds = C,
        C
    },
    Object.defineProperty(t.TileSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(t) {
            this._width = t
        }
    }),
    Object.defineProperty(t.TileSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(t) {
            this._height = t
        }
    }),
    t.CanvasPool = {
        create: function(e, i, s) {
            var n, r = t.CanvasPool.getFirst();
            if ( - 1 === r) {
                var o = {
                    parent: e,
                    canvas: document.createElement("canvas")
                };
                t.CanvasPool.pool.push(o),
                n = o.canvas
            } else t.CanvasPool.pool[r].parent = e,
            n = t.CanvasPool.pool[r].canvas;
            return void 0 !== i && (n.width = i, n.height = s),
            n
        },
        getFirst: function() {
            for (var e = t.CanvasPool.pool,
            i = 0; i < e.length; i++) if (!e[i].parent) return i;
            return - 1
        },
        remove: function(e) {
            for (var i = t.CanvasPool.pool,
            s = 0; s < i.length; s++) i[s].parent === e && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
        },
        removeByCanvas: function(e) {
            for (var i = t.CanvasPool.pool,
            s = 0; s < i.length; s++) i[s].canvas === e && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
        },
        getTotal: function() {
            for (var e = t.CanvasPool.pool,
            i = 0,
            s = 0; s < e.length; s++) e[s].parent && i++;
            return i
        },
        getFree: function() {
            for (var e = t.CanvasPool.pool,
            i = 0,
            s = 0; s < e.length; s++) e[s].parent || i++;
            return i
        },
        log: function() {
            console.log("CanvasPool: %s used, %s free, %s total", this.getTotal(), this.getFree(), this.pool.length)
        }
    },
    t.CanvasPool.pool = [],
    Object.defineProperty(t.CanvasPool, "length", {
        get: function() {
            return this.pool.length
        }
    }),
    t.Device = function() {
        this.deviceReadyAt = 0,
        this.initialized = !1,
        this.desktop = !1,
        this.iOS = !1,
        this.iOSVersion = 0,
        this.cocoonJS = !1,
        this.cocoonJSApp = !1,
        this.cordova = !1,
        this.node = !1,
        this.nodeWebkit = !1,
        this.electron = !1,
        this.ejecta = !1,
        this.crosswalk = !1,
        this.android = !1,
        this.chromeOS = !1,
        this.linux = !1,
        this.macOS = !1,
        this.windows = !1,
        this.windowsPhone = !1,
        this.canvas = !1,
        this.canvasBitBltShift = null,
        this.canHandleAlpha = !1,
        this.canUseMultiply = !1,
        this.webGL = !1,
        this.file = !1,
        this.fileSystem = !1,
        this.localStorage = !1,
        this.worker = !1,
        this.css3D = !1,
        this.pointerLock = !1,
        this.typedArray = !1,
        this.vibration = !1,
        this.getUserMedia = !0,
        this.quirksMode = !1,
        this.touch = !1,
        this.mspointer = !1,
        this.wheelEvent = null,
        this.arora = !1,
        this.chrome = !1,
        this.chromeVersion = 0,
        this.epiphany = !1,
        this.firefox = !1,
        this.firefoxVersion = 0,
        this.ie = !1,
        this.ieVersion = 0,
        this.trident = !1,
        this.tridentVersion = 0,
        this.edge = !1,
        this.mobileSafari = !1,
        this.midori = !1,
        this.opera = !1,
        this.safari = !1,
        this.safariVersion = 0,
        this.webApp = !1,
        this.silk = !1,
        this.audioData = !1,
        this.webAudio = !1,
        this.ogg = !1,
        this.opus = !1,
        this.mp3 = !1,
        this.wav = !1,
        this.m4a = !1,
        this.webm = !1,
        this.dolby = !1,
        this.oggVideo = !1,
        this.h264Video = !1,
        this.mp4Video = !1,
        this.webmVideo = !1,
        this.vp9Video = !1,
        this.hlsVideo = !1,
        this.iPhone = !1,
        this.iPhone4 = !1,
        this.iPad = !1,
        this.pixelRatio = 0,
        this.littleEndian = !1,
        this.LITTLE_ENDIAN = !1,
        this.support32bit = !1,
        this.fullscreen = !1,
        this.requestFullscreen = "",
        this.cancelFullscreen = "",
        this.fullscreenKeyboard = !1
    },
    t.Device = new t.Device,
    t.Device.onInitialized = new t.Signal,
    t.Device.whenReady = function(t, e, i) {
        var s = this._readyCheck;
        if (this.deviceReadyAt || !s) t.call(e, this);
        else if (s._monitor || i) s._queue = s._queue || [],
        s._queue.push([t, e]);
        else {
            s._monitor = s.bind(this),
            s._queue = s._queue || [],
            s._queue.push([t, e]);
            var n = void 0 !== window.cordova,
            r = navigator.isCocoonJS;
            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
        }
    },
    t.Device._readyCheck = function() {
        var t = this._readyCheck;
        if (document.body) {
            if (!this.deviceReadyAt) {
                this.deviceReadyAt = Date.now(),
                document.removeEventListener("deviceready", t._monitor),
                document.removeEventListener("DOMContentLoaded", t._monitor),
                window.removeEventListener("load", t._monitor),
                this._initialize(),
                this.initialized = !0,
                this.onInitialized.dispatch(this);
                for (var e; e = t._queue.shift();) {
                    var i = e[0],
                    s = e[1];
                    i.call(s, this)
                }
                this._readyCheck = null,
                this._initialize = null,
                this.onInitialized = null
            }
        } else window.setTimeout(t._monitor, 20)
    },
    t.Device._initialize = function() {
        var e = this; !
        function() {
            var t = navigator.userAgent;
            /Playstation Vita/.test(t) ? e.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? e.kindle = !0 : /Android/.test(t) ? e.android = !0 : /CrOS/.test(t) ? e.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (e.iOS = !0, navigator.appVersion.match(/OS (\d+)/), e.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? e.linux = !0 : /Mac OS/.test(t) ? e.macOS = !0 : /Windows/.test(t) && (e.windows = !0),
            (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (e.android = !1, e.iOS = !1, e.macOS = !1, e.windows = !0, e.windowsPhone = !0);
            var i = /Silk/.test(t); (e.windows || e.macOS || e.linux && !i || e.chromeOS) && (e.desktop = !0),
            (e.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (e.desktop = !1)
        } (),
        function() {
            var t = navigator.userAgent;
            if (/Arora/.test(t) ? e.arora = !0 : /Edge\/\d+/.test(t) ? e.edge = !0 : /Chrome\/(\d+)/.test(t) && !e.windowsPhone ? (e.chrome = !0, e.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? e.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (e.firefox = !0, e.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && e.iOS ? e.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (e.ie = !0, e.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? e.midori = !0 : /Opera/.test(t) ? e.opera = !0 : /Safari\/(\d+)/.test(t) && !e.windowsPhone ? (e.safari = !0, /Version\/(\d+)\./.test(t) && (e.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (e.ie = !0, e.trident = !0, e.tridentVersion = parseInt(RegExp.$1, 10), e.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (e.silk = !0), navigator.standalone && (e.webApp = !0), void 0 !== window.cordova && (e.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (e.node = !0), e.node && "object" == typeof process.versions && (e.nodeWebkit = !!process.versions["node-webkit"], e.electron = !!process.versions.electron), navigator.isCocoonJS && (e.cocoonJS = !0), e.cocoonJS) try {
                e.cocoonJSApp = "undefined" != typeof CocoonJS
            } catch(t) {
                e.cocoonJSApp = !1
            }
            void 0 !== window.ejecta && (e.ejecta = !0),
            /Crosswalk/.test(t) && (e.crosswalk = !0)
        } (),
        function() {
            e.audioData = !!window.Audio,
            e.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
            var t = document.createElement("audio");
            try {
                if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (e.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (e.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (e.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (e.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (e.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (e.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"'))) if (e.edge) e.dolby = !0;
                else if (e.safari && e.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                    var i = parseInt(RegExp.$1, 10),
                    s = parseInt(RegExp.$2, 10); (10 === i && s >= 11 || i > 10) && (e.dolby = !0)
                }
            } catch(t) {}
        } (),
        function() {
            var t = document.createElement("video");
            try {
                t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (e.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (e.h264Video = !0, e.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (e.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (e.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (e.hlsVideo = !0))
            } catch(t) {}
        } (),
        function() {
            var t, i = document.createElement("p"),
            s = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            for (var n in document.body.insertBefore(i, null), s) void 0 !== i.style[n] && (i.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(i).getPropertyValue(s[n]));
            document.body.removeChild(i),
            e.css3D = void 0 !== t && t.length > 0 && "none" !== t
        } (),
        e.pixelRatio = window.devicePixelRatio || 1,
        e.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"),
        e.iPhone4 = 2 === e.pixelRatio && e.iPhone,
        e.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"),
        "undefined" != typeof Int8Array ? e.typedArray = !0 : e.typedArray = !1,
        "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (e.littleEndian = function() {
            var t = new ArrayBuffer(4),
            e = new Uint8Array(t),
            i = new Uint32Array(t);
            return e[0] = 161,
            e[1] = 178,
            e[2] = 195,
            e[3] = 212,
            3569595041 === i[0] || 2712847316 !== i[0] && null
        } (), e.LITTLE_ENDIAN = e.littleEndian),
        e.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== e.littleEndian &&
        function() {
            if (void 0 === Uint8ClampedArray) return ! 1;
            var e = t.CanvasPool.create(this, 1, 1).getContext("2d");
            if (!e) return ! 1;
            var i = e.createImageData(1, 1);
            return t.CanvasPool.remove(this),
            i.data instanceof Uint8ClampedArray
        } (),
        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate,
        navigator.vibrate && (e.vibration = !0),
        function() {
            e.canvas = !!window.CanvasRenderingContext2D || e.cocoonJS;
            try {
                e.localStorage = !!localStorage.getItem
            } catch(t) {
                e.localStorage = !1
            }
            e.file = !!(window.File && window.FileReader && window.FileList && window.Blob),
            e.fileSystem = !!window.requestFileSystem,
            e.webGL = !!window.WebGLRenderingContext,
            e.worker = !!window.Worker,
            e.pointerLockElement = ("pointerLockElement" in document ? "pointerLockElement": "mozPointerLockElement" in document && "mozPointerLockElement") || "webkitPointerLockElement" in document && "webkitPointerLockElement",
            e.pointerlockchange = ("onpointerlockchange" in document ? "pointerlockchange": "onmozpointerlockchange" in document && "mozpointerlockchange") || "onwebkitpointerlockchange" in document && "webkitpointerlockchange",
            e.pointerlockerror = ("onpointerlockerror" in document ? "pointerlockerror": "onmozpointerlockerror" in document && "mozpointerlockerror") || "onwebkitpointerlockerror" in document && "webkitpointerlockerror",
            e.pointerLock = !!e.pointerLockElement,
            e.quirksMode = "CSS1Compat" !== document.compatMode,
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia,
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL,
            e.getUserMedia = e.getUserMedia && !!navigator.getUserMedia && !!window.URL,
            e.firefox && e.firefoxVersion < 21 && (e.getUserMedia = !1),
            !e.iOS && (e.ie || e.firefox || e.chrome) && (e.canvasBitBltShift = !0),
            (e.safari || e.mobileSafari) && (e.canvasBitBltShift = !1)
        } (),
        function() {
            var i = t.CanvasPool.create(this, 6, 1),
            s = i.getContext("2d");
            s.fillStyle = "rgba(10, 20, 30, 0.5)",
            s.fillRect(0, 0, 1, 1);
            var n = s.getImageData(0, 0, 1, 1);
            if (n) {
                s.putImageData(n, 1, 0);
                var r = s.getImageData(1, 0, 1, 1);
                e.canHandleAlpha = r.data[0] === n.data[0] && r.data[1] === n.data[1] && r.data[2] === n.data[2] && r.data[3] === n.data[3]
            }
            s.globalCompositeOperation = "multiply",
            e.canUseMultiply = "multiply" === s.globalCompositeOperation,
            t.CanvasPool.removeByCanvas(i),
            PIXI.CanvasTinter.tintMethod = e.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply: PIXI.CanvasTinter.tintWithPerPixel
        } (),
        function() {
            for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], i = document.createElement("div"), s = 0; s < t.length; s++) if (i[t[s]]) {
                e.fullscreen = !0,
                e.requestFullscreen = t[s];
                break
            }
            var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
            if (e.fullscreen) for (s = 0; s < n.length; s++) if (document[n[s]]) {
                e.cancelFullscreen = n[s];
                break
            }
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (e.fullscreenKeyboard = !0)
        } (),
        ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (e.touch = !0),
        (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (e.mspointer = !0),
        e.cocoonJS || ("onwheel" in window || e.ie && "WheelEvent" in window ? e.wheelEvent = "wheel": "onmousewheel" in window ? e.wheelEvent = "mousewheel": e.firefox && "MouseScrollEvent" in window && (e.wheelEvent = "DOMMouseScroll"))
    },
    t.Device.canPlayAudio = function(t) {
        return !! ("mp3" === t && this.mp3 || "ogg" === t && (this.ogg || this.opus) || "m4a" === t && this.m4a || "opus" === t && this.opus || "wav" === t && this.wav || "webm" === t && this.webm || "mp4" === t && this.dolby)
    },
    t.Device.canPlayVideo = function(t) {
        return !! ("webm" === t && (this.webmVideo || this.vp9Video) || "mp4" === t && (this.mp4Video || this.h264Video) || ("ogg" === t || "ogv" === t) && this.oggVideo || "mpeg" === t && this.hlsVideo)
    },
    t.Device.needsTouchUnlock = function() {
        return !! (!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)
    },
    t.Device.isAndroidStockBrowser = function() {
        var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return t && t[1] < 537
    },
    t.Canvas = {
        create: function(e, i, s, n, r) {
            i = i || 256,
            s = s || 256;
            var o = r ? document.createElement("canvas") : t.CanvasPool.create(e, i, s);
            return "string" == typeof n && "" !== n && (o.id = n),
            o.width = i,
            o.height = s,
            o.style.display = "block",
            o
        },
        setBackgroundColor: function(t, e) {
            return e = e || "rgb(0,0,0)",
            t.style.backgroundColor = e,
            t
        },
        setTouchAction: function(t, e) {
            return e = e || "none",
            t.style.msTouchAction = e,
            t.style["ms-touch-action"] = e,
            t.style["touch-action"] = e,
            t
        },
        setUserSelect: function(t, e) {
            return e = e || "none",
            t.style["-webkit-touch-callout"] = e,
            t.style["-webkit-user-select"] = e,
            t.style["-khtml-user-select"] = e,
            t.style["-moz-user-select"] = e,
            t.style["-ms-user-select"] = e,
            t.style["user-select"] = e,
            t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)",
            t
        },
        addToDOM: function(t, e, i) {
            var s;
            return void 0 === i && (i = !0),
            e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)),
            s || (s = document.body),
            i && s.style && (s.style.overflow = "hidden"),
            s.appendChild(t),
            t
        },
        removeFromDOM: function(t) {
            t.parentNode && t.parentNode.removeChild(t)
        },
        setTransform: function(t, e, i, s, n, r, o) {
            return t.setTransform(s, r, o, n, e, i),
            t
        },
        setSmoothingEnabled: function(e, i) {
            var s = t.Canvas.getSmoothingPrefix(e);
            return s && (e[s] = i),
            e
        },
        getSmoothingPrefix: function(t) {
            var e = ["i", "webkitI", "msI", "mozI", "oI"];
            for (var i in e) {
                var s = e[i] + "mageSmoothingEnabled";
                if (s in t) return s
            }
            return null
        },
        getSmoothingEnabled: function(e) {
            var i = t.Canvas.getSmoothingPrefix(e);
            if (i) return e[i]
        },
        setImageRenderingCrisp: function(t) {
            for (var e = ["-webkit-optimize-contrast", "-moz-crisp-edges", "crisp-edges", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
            return t.style.msInterpolationMode = "nearest-neighbor",
            t
        },
        setImageRenderingBicubic: function(t) {
            return t.style["image-rendering"] = "auto",
            t.style.msInterpolationMode = "bicubic",
            t
        }
    },
    t.RequestAnimationFrame = function(t, e) {
        void 0 === e && (e = !1),
        this.game = t,
        this.isRunning = !1,
        this.forceSetTimeOut = e;
        for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"],
        window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
        this._isSetTimeOut = !1,
        this._onLoop = null,
        this._timeOutID = null
    },
    t.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = !0;
            var t = this; ! window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                return t.updateSetTimeout()
            },
            this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                return t.updateRAF(e)
            },
            this._timeOutID = window.requestAnimationFrame(this._onLoop))
        },
        updateRAF: function(t) {
            this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
        },
        updateSetTimeout: function() {
            this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
        },
        stop: function() {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID),
            this.isRunning = !1
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut
        },
        isRAF: function() {
            return ! 1 === this._isSetTimeOut
        }
    },
    t.RequestAnimationFrame.prototype.constructor = t.RequestAnimationFrame,
    t.Math = {
        PI2: 2 * Math.PI,
        HALF_PI: .5 * Math.PI,
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        degToRad: function(e) {
            return e * t.Math.DEG_TO_RAD
        },
        radToDeg: function(e) {
            return e * t.Math.RAD_TO_DEG
        },
        getNextPowerOfTwo: function(t) {
            if (t > 0 && 0 == (t & t - 1)) return t;
            for (var e = 1; e < t;) e <<= 1;
            return e
        },
        isPowerOfTwo: function(t, e) {
            return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
        },
        random: function(t, e) {
            if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
            if (t > e) {
                var i = t;
                t = e,
                e = i
            }
            return Math.random() * (e - t) + t
        },
        between: function(t, e) {
            if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
            if (t > e) {
                var i = t;
                t = e,
                e = i
            }
            return t = Math.ceil(t),
            e = Math.floor(e),
            Math.floor(Math.random() * (e - t + 1)) + t
        },
        fuzzyEqual: function(t, e, i) {
            return void 0 === i && (i = 1e-4),
            Math.abs(t - e) < i
        },
        fuzzyLessThan: function(t, e, i) {
            return void 0 === i && (i = 1e-4),
            t < e + i
        },
        fuzzyGreaterThan: function(t, e, i) {
            return void 0 === i && (i = 1e-4),
            t > e - i
        },
        fuzzyCeil: function(t, e) {
            return void 0 === e && (e = 1e-4),
            Math.ceil(t - e)
        },
        fuzzyFloor: function(t, e) {
            return void 0 === e && (e = 1e-4),
            Math.floor(t + e)
        },
        average: function() {
            for (var t = 0,
            e = arguments.length,
            i = 0; i < e; i++) t += +arguments[i];
            return t / e
        },
        shear: function(t) {
            return t % 1
        },
        snapTo: function(t, e, i) {
            return void 0 === i && (i = 0),
            0 === e ? t: (t -= i, i + (t = e * Math.round(t / e)))
        },
        snapToFloor: function(t, e, i) {
            return void 0 === i && (i = 0),
            0 === e ? t: (t -= i, i + (t = e * Math.floor(t / e)))
        },
        snapToCeil: function(t, e, i) {
            return void 0 === i && (i = 0),
            0 === e ? t: (t -= i, i + (t = e * Math.ceil(t / e)))
        },
        roundTo: function(t, e, i) {
            void 0 === e && (e = 0),
            void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.round(t * s) / s
        },
        floorTo: function(t, e, i) {
            void 0 === e && (e = 0),
            void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.floor(t * s) / s
        },
        ceilTo: function(t, e, i) {
            void 0 === e && (e = 0),
            void 0 === i && (i = 10);
            var s = Math.pow(i, -e);
            return Math.ceil(t * s) / s
        },
        trunc: function(t) {
            return isFinite(t) ? t - t % 1 || (t < 0 ? -0 : 0 === t ? t: 0) : t
        },
        rotateToAngle: function(e, i, s) {
            return void 0 === s && (s = .05),
            e === i ? e: (Math.abs(i - e) <= s || Math.abs(i - e) >= t.Math.PI2 - s ? e = i: (Math.abs(i - e) > Math.PI && (i < e ? i += t.Math.PI2: i -= t.Math.PI2), i > e ? e += s: i < e && (e -= s)), e)
        },
        getShortestAngle: function(t, e) {
            var i = e - t;
            return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
        },
        angleBetween: function(t, e, i, s) {
            return Math.atan2(s - e, i - t)
        },
        angleBetweenY: function(t, e, i, s) {
            return Math.atan2(i - t, s - e)
        },
        angleBetweenPoints: function(t, e) {
            return Math.atan2(e.y - t.y, e.x - t.x)
        },
        angleBetweenPointsY: function(t, e) {
            return Math.atan2(e.x - t.x, e.y - t.y)
        },
        reverseAngle: function(t) {
            return this.normalizeAngle(t + Math.PI, !0)
        },
        normalizeAngle: function(t) {
            return (t %= 2 * Math.PI) >= 0 ? t: t + 2 * Math.PI
        },
        maxAdd: function(t, e, i) {
            return Math.min(t + e, i)
        },
        minSub: function(t, e, i) {
            return Math.max(t - e, i)
        },
        wrap: function(t, e, i) {
            var s = i - e;
            if (s <= 0) return 0;
            var n = (t - e) % s;
            return n < 0 && (n += s),
            n + e
        },
        wrapValue: function(t, e, i) {
            return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
        },
        isOdd: function(t) {
            return !! (1 & t)
        },
        isEven: function(t) {
            return ! (1 & t)
        },
        min: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
            else var t = arguments;
            for (var e = 1,
            i = 0,
            s = t.length; e < s; e++) t[e] < t[i] && (i = e);
            return t[i]
        },
        max: function() {
            if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
            else var t = arguments;
            for (var e = 1,
            i = 0,
            s = t.length; e < s; e++) t[e] > t[i] && (i = e);
            return t[i]
        },
        minProperty: function(t) {
            if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
            else var e = arguments.slice(1);
            for (var i = 1,
            s = 0,
            n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
            return e[s][t]
        },
        maxProperty: function(t) {
            if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
            else var e = arguments.slice(1);
            for (var i = 1,
            s = 0,
            n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
            return e[s][t]
        },
        wrapAngle: function(t, e) {
            return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
        },
        linearInterpolation: function(t, e) {
            var i = t.length - 1,
            s = i * e,
            n = Math.floor(s);
            return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i: n + 1], s - n)
        },
        bezierInterpolation: function(t, e) {
            for (var i = 0,
            s = t.length - 1,
            n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
            return i
        },
        catmullRomInterpolation: function(t, e) {
            var i = t.length - 1,
            s = i * e,
            n = Math.floor(s);
            return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i: n + 1], t[i < n + 2 ? i: n + 2], s - n)
        },
        linear: function(t, e, i) {
            return (e - t) * i + t
        },
        bernstein: function(t, e) {
            return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
        },
        factorial: function(t) {
            if (0 === t) return 1;
            for (var e = t; --t;) e *= t;
            return e
        },
        catmullRom: function(t, e, i, s, n) {
            var r = .5 * (i - t),
            o = .5 * (s - e),
            a = n * n;
            return (2 * e - 2 * i + r + o) * (n * a) + ( - 3 * e + 3 * i - 2 * r - o) * a + r * n + e
        },
        difference: function(t, e) {
            return Math.abs(t - e)
        },
        roundAwayFromZero: function(t) {
            return t > 0 ? Math.ceil(t) : Math.floor(t)
        },
        sinCosGenerator: function(t, e, i, s) {
            void 0 === e && (e = 1),
            void 0 === i && (i = 1),
            void 0 === s && (s = 1);
            for (var n = e,
            r = i,
            o = s * Math.PI / t,
            a = [], h = [], l = 0; l < t; l++) n += (r -= n * o) * o,
            a[l] = r,
            h[l] = n;
            return {
                sin: h,
                cos: a,
                length: t
            }
        },
        hypot: function(t, e) {
            return Math.sqrt(t * t + e * e)
        },
        distance: function(t, e, i, s) {
            var n = t - i,
            r = e - s;
            return Math.sqrt(n * n + r * r)
        },
        distanceSq: function(t, e, i, s) {
            var n = t - i,
            r = e - s;
            return n * n + r * r
        },
        distancePow: function(t, e, i, s, n) {
            return void 0 === n && (n = 2),
            Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
        },
        clamp: function(t, e, i) {
            return t < e ? e: i < t ? i: t
        },
        clampBottom: function(t, e) {
            return t < e ? e: t
        },
        within: function(t, e, i) {
            return Math.abs(t - e) <= i
        },
        mapLinear: function(t, e, i, s, n) {
            return s + (t - e) * (n - s) / (i - e)
        },
        smoothstep: function(t, e, i) {
            return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, i) {
            return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
        },
        sign: function(t) {
            return t < 0 ? -1 : t > 0 ? 1 : 0
        },
        percent: function(t, e, i) {
            return void 0 === i && (i = 0),
            t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
        }
    },
    t.RandomDataGenerator = function(t) {
        void 0 === t && (t = []),
        this.c = 1,
        this.s0 = 0,
        this.s1 = 0,
        this.s2 = 0,
        "string" == typeof t ? this.state(t) : this.sow(t)
    },
    t.RandomDataGenerator.prototype = {
        rnd: function() {
            var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
            return this.c = 0 | t,
            this.s0 = this.s1,
            this.s1 = this.s2,
            this.s2 = t - this.c,
            this.s2
        },
        sow: function(t) {
            if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t) for (var e = 0; e < t.length && null != t[e]; e++) {
                var i = t[e];
                this.s0 -= this.hash(i),
                this.s0 += ~~ (this.s0 < 0),
                this.s1 -= this.hash(i),
                this.s1 += ~~ (this.s1 < 0),
                this.s2 -= this.hash(i),
                this.s2 += ~~ (this.s2 < 0)
            }
        },
        hash: function(t) {
            var e, i, s;
            for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)),
            e -= s = e >>> 0,
            s = (e *= s) >>> 0,
            s += 4294967296 * (e -= s);
            return 2.3283064365386963e-10 * (s >>> 0)
        },
        integer: function() {
            return 4294967296 * this.rnd.apply(this)
        },
        frac: function() {
            return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
        },
        real: function() {
            return this.integer() + this.frac()
        },
        integerInRange: function(t, e) {
            return Math.floor(this.realInRange(0, e - t + 1) + t)
        },
        between: function(t, e) {
            return this.integerInRange(t, e)
        },
        realInRange: function(t, e) {
            return this.frac() * (e - t) + t
        },
        normal: function() {
            return 1 - 2 * this.frac()
        },
        uuid: function() {
            var t = "",
            e = "";
            for (e = t = ""; t++<36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
            return e
        },
        pick: function(t) {
            return t[this.integerInRange(0, t.length - 1)]
        },
        sign: function() {
            return this.pick([ - 1, 1])
        },
        weightedPick: function(t) {
            return t[~~ (Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
        },
        timestamp: function(t, e) {
            return this.realInRange(t || 9466848e5, e || 1577862e6)
        },
        angle: function() {
            return this.integerInRange( - 180, 180)
        },
        state: function(t) {
            return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])),
            ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
        }
    },
    t.RandomDataGenerator.prototype.constructor = t.RandomDataGenerator,
    t.QuadTree = function(t, e, i, s, n, r, o) {
        this.maxObjects = 10,
        this.maxLevels = 4,
        this.level = 0,
        this.bounds = {},
        this.objects = [],
        this.nodes = [],
        this._empty = [],
        this.reset(t, e, i, s, n, r, o)
    },
    t.QuadTree.prototype = {
        reset: function(t, e, i, s, n, r, o) {
            this.maxObjects = n || 10,
            this.maxLevels = r || 4,
            this.level = o || 0,
            this.bounds = {
                x: Math.round(t),
                y: Math.round(e),
                width: i,
                height: s,
                subWidth: Math.floor(i / 2),
                subHeight: Math.floor(s / 2),
                right: Math.round(t) + Math.floor(i / 2),
                bottom: Math.round(e) + Math.floor(s / 2)
            },
            this.objects.length = 0,
            this.nodes.length = 0
        },
        populate: function(t) {
            t.forEach(this.populateHandler, this, !0)
        },
        populateHandler: function(t) {
            t.body && t.exists && this.insert(t.body)
        },
        split: function() {
            this.nodes[0] = new t.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1),
            this.nodes[1] = new t.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1),
            this.nodes[2] = new t.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1),
            this.nodes[3] = new t.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
        },
        insert: function(t) {
            var e, i = 0;
            if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels) for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
            } else this.nodes[e].insert(t)
        },
        getIndex: function(t) {
            var e = -1;
            return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)),
            e
        },
        retrieve: function(e) {
            if (e instanceof t.Rectangle) var i = this.objects,
            s = this.getIndex(e);
            else {
                if (!e.body) return this._empty;
                i = this.objects,
                s = this.getIndex(e.body)
            }
            return this.nodes[0] && (i = -1 !== s ? i.concat(this.nodes[s].retrieve(e)) : (i = (i = (i = i.concat(this.nodes[0].retrieve(e))).concat(this.nodes[1].retrieve(e))).concat(this.nodes[2].retrieve(e))).concat(this.nodes[3].retrieve(e))),
            i
        },
        clear: function() {
            this.objects.length = 0;
            for (var t = this.nodes.length; t--;) this.nodes[t].clear(),
            this.nodes.splice(t, 1);
            this.nodes.length = 0
        }
    },
    t.QuadTree.prototype.constructor = t.QuadTree,
    t.Net = function(t) {
        this.game = t
    },
    t.Net.prototype = {
        getHostName: function() {
            return window.location && window.location.hostname ? window.location.hostname: null
        },
        checkDomainName: function(t) {
            return - 1 !== window.location.hostname.indexOf(t)
        },
        updateQueryString: function(t, e, i, s) {
            void 0 === i && (i = !1),
            void 0 !== s && "" !== s || (s = window.location.href);
            var n = "",
            r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
            if (r.test(s)) n = null != e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
            else if (null != e) {
                var o = -1 !== s.indexOf("?") ? "&": "?",
                a = s.split("#");
                s = a[0] + o + t + "=" + e,
                a[1] && (s += "#" + a[1]),
                n = s
            } else n = s;
            if (!i) return n;
            window.location.href = n
        },
        getQueryString: function(t) {
            void 0 === t && (t = "");
            var e = {},
            i = location.search.substring(1).split("&");
            for (var s in i) {
                var n = i[s].split("=");
                if (n.length > 1) {
                    if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                    e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                }
            }
            return e
        },
        decodeURI: function(t) {
            return decodeURIComponent(t.replace(/\+/g, " "))
        }
    },
    t.Net.prototype.constructor = t.Net,
    t.TweenManager = function(e) {
        this.game = e,
        this.frameBased = !1,
        this._tweens = [],
        this._add = [],
        this.easeMap = {
            Power0: t.Easing.Power0,
            Power1: t.Easing.Power1,
            Power2: t.Easing.Power2,
            Power3: t.Easing.Power3,
            Power4: t.Easing.Power4,
            Linear: t.Easing.Linear.None,
            Quad: t.Easing.Quadratic.Out,
            Cubic: t.Easing.Cubic.Out,
            Quart: t.Easing.Quartic.Out,
            Quint: t.Easing.Quintic.Out,
            Sine: t.Easing.Sinusoidal.Out,
            Expo: t.Easing.Exponential.Out,
            Circ: t.Easing.Circular.Out,
            Elastic: t.Easing.Elastic.Out,
            Back: t.Easing.Back.Out,
            Bounce: t.Easing.Bounce.Out,
            "Quad.easeIn": t.Easing.Quadratic.In,
            "Cubic.easeIn": t.Easing.Cubic.In,
            "Quart.easeIn": t.Easing.Quartic.In,
            "Quint.easeIn": t.Easing.Quintic.In,
            "Sine.easeIn": t.Easing.Sinusoidal.In,
            "Expo.easeIn": t.Easing.Exponential.In,
            "Circ.easeIn": t.Easing.Circular.In,
            "Elastic.easeIn": t.Easing.Elastic.In,
            "Back.easeIn": t.Easing.Back.In,
            "Bounce.easeIn": t.Easing.Bounce.In,
            "Quad.easeOut": t.Easing.Quadratic.Out,
            "Cubic.easeOut": t.Easing.Cubic.Out,
            "Quart.easeOut": t.Easing.Quartic.Out,
            "Quint.easeOut": t.Easing.Quintic.Out,
            "Sine.easeOut": t.Easing.Sinusoidal.Out,
            "Expo.easeOut": t.Easing.Exponential.Out,
            "Circ.easeOut": t.Easing.Circular.Out,
            "Elastic.easeOut": t.Easing.Elastic.Out,
            "Back.easeOut": t.Easing.Back.Out,
            "Bounce.easeOut": t.Easing.Bounce.Out,
            "Quad.easeInOut": t.Easing.Quadratic.InOut,
            "Cubic.easeInOut": t.Easing.Cubic.InOut,
            "Quart.easeInOut": t.Easing.Quartic.InOut,
            "Quint.easeInOut": t.Easing.Quintic.InOut,
            "Sine.easeInOut": t.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": t.Easing.Exponential.InOut,
            "Circ.easeInOut": t.Easing.Circular.InOut,
            "Elastic.easeInOut": t.Easing.Elastic.InOut,
            "Back.easeInOut": t.Easing.Back.InOut,
            "Bounce.easeInOut": t.Easing.Bounce.InOut
        },
        this.game.onPause.add(this._pauseAll, this),
        this.game.onResume.add(this._resumeAll, this)
    },
    t.TweenManager.prototype = {
        getAll: function() {
            return this._tweens
        },
        removeAll: function() {
            for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
            this._add = []
        },
        removeFrom: function(e, i) {
            if (void 0 === i && (i = !0), Array.isArray(e)) for (s = 0, n = e.length; s < n; s++) this.removeFrom(e[s]);
            else if (e.type === t.GROUP && i) for (var s = 0,
            n = e.children.length; s < n; s++) this.removeFrom(e.children[s]);
            else {
                for (s = 0, n = this._tweens.length; s < n; s++) e === this._tweens[s].target && this.remove(this._tweens[s]);
                for (s = 0, n = this._add.length; s < n; s++) e === this._add[s].target && this.remove(this._add[s])
            }
        },
        add: function(t) {
            t._manager = this,
            this._add.push(t)
        },
        create: function(e) {
            return new t.Tween(e, this.game, this)
        },
        remove: function(t) {
            var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
        },
        update: function() {
            var t = this._add.length,
            e = this._tweens.length;
            if (0 === e && 0 === t) return ! 1;
            for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++:(this._tweens.splice(i, 1), e--);
            return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0),
            !0
        },
        isTweening: function(t, e) {
            return e || (e = !1),
            this._tweens.some(function(i) {
                return i.target === t && (!e || i.isRunning && !i.pendingDelete)
            })
        },
        _pauseAll: function() {
            for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
        },
        _resumeAll: function() {
            for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
        },
        pauseAll: function() {
            for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
        },
        resumeAll: function() {
            for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
        },
        destroy: function() {
            this.game.onPause.remove(this._pauseAll, this),
            this.game.onResume.remove(this._resumeAll, this),
            this.game = null,
            this._add = null,
            this._tweens = null
        }
    },
    t.TweenManager.prototype.constructor = t.TweenManager,
    t.Tween = function(e, i, s) {
        this.game = i,
        this.target = e,
        this.manager = s,
        this.timeline = [],
        this.reverse = !1,
        this.timeScale = 1,
        this.repeatCounter = 0,
        this.pendingDelete = !1,
        this.onStart = new t.Signal,
        this.onLoop = new t.Signal,
        this.onRepeat = new t.Signal,
        this.onChildComplete = new t.Signal,
        this.onComplete = new t.Signal,
        this.isRunning = !1,
        this.current = 0,
        this.properties = {},
        this.chainedTween = null,
        this.isPaused = !1,
        this.frameBased = s.frameBased,
        this._onUpdateCallback = null,
        this._onUpdateCallbackContext = null,
        this._pausedTime = 0,
        this._codePaused = !1,
        this._hasStarted = !1
    },
    t.Tween.updateColor = function(e) {
        t.Color.updateColor(e.target)
    },
    t.Tween.prototype = {
        to: function(e, i, s, n, r, o, a) {
            return (void 0 === i || i <= 0) && (i = 1e3),
            null != s || (s = t.Easing.Default),
            void 0 === n && (n = !1),
            void 0 === r && (r = 0),
            void 0 === o && (o = 0),
            void 0 === a && (a = !1),
            "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]),
            this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new t.TweenData(this).to(e, i, s, r, o, a)), n && this.start(), this)
        },
        from: function(e, i, s, n, r, o, a) {
            return void 0 === i && (i = 1e3),
            null != s || (s = t.Easing.Default),
            void 0 === n && (n = !1),
            void 0 === r && (r = 0),
            void 0 === o && (o = 0),
            void 0 === a && (a = !1),
            "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]),
            this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new t.TweenData(this).from(e, i, s, r, o, a)), n && this.start(), this)
        },
        start: function(t) {
            if (void 0 === t && (t = 0), this.pendingDelete) return console.warn("Phaser.Tween.start cannot be called after Tween.stop"),
            this;
            if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
            for (i = 0; i < this.timeline.length; i++) for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0,
            Array.isArray(this.properties[e]) || (this.properties[e] *= 1);
            for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
            return this.manager.add(this),
            this.isRunning = !0,
            (t < 0 || t > this.timeline.length - 1) && (t = 0),
            this.current = t,
            this.timeline[this.current].start(),
            this
        },
        stop: function(t) {
            return void 0 === t && (t = !1),
            this.isRunning = !1,
            this._onUpdateCallback = null,
            this._onUpdateCallbackContext = null,
            t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()),
            this.manager.remove(this),
            this
        },
        updateTweenData: function(t, e, i) {
            if (0 === this.timeline.length) return this;
            if (void 0 === i && (i = 0), -1 === i) for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
            else this.timeline[i][t] = e;
            return this
        },
        delay: function(t, e) {
            return this.updateTweenData("delay", t, e)
        },
        repeat: function(t, e, i) {
            return void 0 === e && (e = 0),
            this.updateTweenData("repeatCounter", t, i),
            this.updateTweenData("repeatTotal", t, i),
            this.updateTweenData("repeatDelay", e, i)
        },
        repeatDelay: function(t, e) {
            return this.updateTweenData("repeatDelay", t, e)
        },
        yoyo: function(t, e, i) {
            return void 0 === e && (e = 0),
            this.updateTweenData("yoyo", t, i),
            this.updateTweenData("yoyoDelay", e, i)
        },
        yoyoDelay: function(t, e) {
            return this.updateTweenData("yoyoDelay", t, e)
        },
        easing: function(t, e) {
            return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]),
            this.updateTweenData("easingFunction", t, e)
        },
        interpolation: function(e, i, s) {
            return void 0 === i && (i = t.Math),
            this.updateTweenData("interpolationFunction", e, s),
            this.updateTweenData("interpolationContext", i, s)
        },
        repeatAll: function(t) {
            return void 0 === t && (t = 0),
            this.repeatCounter = t,
            this
        },
        chain: function() {
            for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
            return this
        },
        loop: function(t) {
            return void 0 === t && (t = !0),
            this.repeatCounter = t ? -1 : 0,
            this
        },
        onUpdateCallback: function(t, e) {
            return this._onUpdateCallback = t,
            this._onUpdateCallbackContext = e,
            this
        },
        pause: function() {
            this.isPaused = !0,
            this._codePaused = !0,
            this._pausedTime = this.game.time.time
        },
        _pause: function() {
            this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
        },
        resume: function() {
            if (this.isPaused) {
                this.isPaused = !1,
                this._codePaused = !1;
                for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
            }
        },
        _resume: function() {
            this._codePaused || this.resume()
        },
        update: function(e) {
            if (this.pendingDelete || !this.target) return ! 1;
            if (this.isPaused) return ! 0;
            var i = this.timeline[this.current].update(e);
            if (i === t.TweenData.PENDING) return ! 0;
            if (i === t.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0),
            null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]),
            this.isRunning;
            if (i === t.TweenData.LOOPED) return - 1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this),
            !0;
            if (i === t.TweenData.COMPLETE) {
                var s = !1;
                return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, s = !0) : ++this.current === this.timeline.length && (this.current = 0, s = !0),
                s ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
            }
        },
        generateData: function(t, e) {
            if (null === this.game || null === this.target) return null;
            for (void 0 === t && (t = 60), void 0 === e && (e = []), s = 0; s < this.timeline.length; s++) for (var i in this.timeline[s].vEnd) this.properties[i] = this.target[i] || 0,
            Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
            for (s = 0; s < this.timeline.length; s++) this.timeline[s].loadValues();
            for (var s = 0; s < this.timeline.length; s++) e = e.concat(this.timeline[s].generateData(t));
            return e
        }
    },
    Object.defineProperty(t.Tween.prototype, "totalDuration", {
        get: function() {
            for (var t = 0,
            e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
            return t
        }
    }),
    t.Tween.prototype.constructor = t.Tween,
    t.TweenData = function(e) {
        this.parent = e,
        this.game = e.game,
        this.vStart = {},
        this.vStartCache = {},
        this.vEnd = {},
        this.vEndCache = {},
        this.duration = 1e3,
        this.percent = 0,
        this.value = 0,
        this.repeatCounter = 0,
        this.repeatDelay = 0,
        this.repeatTotal = 0,
        this.interpolate = !1,
        this.yoyo = !1,
        this.yoyoDelay = 0,
        this.inReverse = !1,
        this.delay = 0,
        this.dt = 0,
        this.startTime = null,
        this.easingFunction = t.Easing.Default,
        this.interpolationFunction = t.Math.linearInterpolation,
        this.interpolationContext = t.Math,
        this.isRunning = !1,
        this.isFrom = !1
    },
    t.TweenData.PENDING = 0,
    t.TweenData.RUNNING = 1,
    t.TweenData.LOOPED = 2,
    t.TweenData.COMPLETE = 3,
    t.TweenData.prototype = {
        to: function(t, e, i, s, n, r) {
            return this.vEnd = t,
            this.duration = e,
            this.easingFunction = i,
            this.delay = s,
            this.repeatTotal = n,
            this.yoyo = r,
            this.isFrom = !1,
            this
        },
        from: function(t, e, i, s, n, r) {
            return this.vEnd = t,
            this.duration = e,
            this.easingFunction = i,
            this.delay = s,
            this.repeatTotal = n,
            this.yoyo = r,
            this.isFrom = !0,
            this
        },
        start: function() {
            if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration: this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom) for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t],
            this.vEnd[t] = this.vStartCache[t],
            this.parent.target[t] = this.vStart[t];
            return this.value = 0,
            this.repeatCounter = this.repeatTotal,
            this
        },
        loadValues: function() {
            for (var t in this.parent.properties) {
                if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                    if (0 === this.vEnd[t].length) continue;
                    0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                }
                void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t],
                this.vStartCache[t] = this.vStart[t],
                this.vEndCache[t] = this.vEnd[t]
            }
            return this
        },
        update: function(e) {
            if (this.isRunning) {
                if (e < this.startTime) return t.TweenData.RUNNING
            } else {
                if (! (e >= this.startTime)) return t.TweenData.PENDING;
                this.isRunning = !0
            }
            var i = this.parent.frameBased ? this.game.time.physicsElapsedMS: this.game.time.elapsedMS;
            for (var s in this.parent.reverse ? (this.dt -= i * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += i * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                var n = this.vStart[s],
                r = this.vEnd[s];
                Array.isArray(r) ? this.parent.target[s] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[s] = n + (r - n) * this.value
            }
            return ! this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : t.TweenData.RUNNING
        },
        generateData: function(t) {
            this.parent.reverse ? this.dt = this.duration: this.dt = 0;
            var e = [],
            i = !1,
            s = 1 / t * 1e3;
            do {
                this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                var n = {};
                for (var r in this.vEnd) {
                    var o = this.vStart[r],
                    a = this.vEnd[r];
                    Array.isArray(a) ? n[r] = this.interpolationFunction.call(this.interpolationContext, a, this.value) : n[r] = o + (a - o) * this.value
                }
                e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
            } while (! i );
            if (this.yoyo) {
                var h = e.slice();
                h.reverse(),
                e = e.concat(h)
            }
            return e
        },
        repeat: function() {
            if (this.yoyo) {
                if (this.inReverse && 0 === this.repeatCounter) {
                    for (var e in this.vStartCache) this.vStart[e] = this.vStartCache[e],
                    this.vEnd[e] = this.vEndCache[e];
                    return this.inReverse = !1,
                    t.TweenData.COMPLETE
                }
                this.inReverse = !this.inReverse
            } else if (0 === this.repeatCounter) return t.TweenData.COMPLETE;
            if (this.inReverse) for (var e in this.vStartCache) this.vStart[e] = this.vEndCache[e],
            this.vEnd[e] = this.vStartCache[e];
            else {
                for (var e in this.vStartCache) this.vStart[e] = this.vStartCache[e],
                this.vEnd[e] = this.vEndCache[e];
                this.repeatCounter > 0 && this.repeatCounter--
            }
            return this.startTime = this.game.time.time,
            this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay: this.inReverse || (this.startTime += this.repeatDelay),
            this.parent.reverse ? this.dt = this.duration: this.dt = 0,
            t.TweenData.LOOPED
        }
    },
    t.TweenData.prototype.constructor = t.TweenData,
    t.Easing = {
        Linear: {
            None: function(t) {
                return t
            }
        },
        Quadratic: {
            In: function(t) {
                return t * t
            },
            Out: function(t) {
                return t * (2 - t)
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t: -.5 * (--t * (t - 2) - 1)
            }
        },
        Cubic: {
            In: function(t) {
                return t * t * t
            },
            Out: function(t) {
                return--t * t * t + 1
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t: .5 * ((t -= 2) * t * t + 2)
            }
        },
        Quartic: {
            In: function(t) {
                return t * t * t * t
            },
            Out: function(t) {
                return 1 - --t * t * t * t
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t: -.5 * ((t -= 2) * t * t * t - 2)
            }
        },
        Quintic: {
            In: function(t) {
                return t * t * t * t * t
            },
            Out: function(t) {
                return--t * t * t * t * t + 1
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t: .5 * ((t -= 2) * t * t * t * t + 2)
            }
        },
        Sinusoidal: {
            In: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
            },
            Out: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
            }
        },
        Exponential: {
            In: function(t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            },
            Out: function(t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            }
        },
        Circular: {
            In: function(t) {
                return 1 - Math.sqrt(1 - t * t)
            },
            Out: function(t) {
                return Math.sqrt(1 - --t * t)
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }
        },
        Elastic: {
            In: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
            },
            Out: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
            },
            InOut: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
            }
        },
        Back: {
            In: function(t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e)
            },
            Out: function(t) {
                var e = 1.70158;
                return--t * t * ((e + 1) * t + e) + 1
            },
            InOut: function(t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            }
        },
        Bounce: {
            In: function(e) {
                return 1 - t.Easing.Bounce.Out(1 - e)
            },
            Out: function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t: t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            },
            InOut: function(e) {
                return e < .5 ? .5 * t.Easing.Bounce.In(2 * e) : .5 * t.Easing.Bounce.Out(2 * e - 1) + .5
            }
        }
    },
    t.Easing.Default = t.Easing.Linear.None,
    t.Easing.Power0 = t.Easing.Linear.None,
    t.Easing.Power1 = t.Easing.Quadratic.Out,
    t.Easing.Power2 = t.Easing.Cubic.Out,
    t.Easing.Power3 = t.Easing.Quartic.Out,
    t.Easing.Power4 = t.Easing.Quintic.Out,
    t.Time = function(e) {
        this.game = e,
        this.time = 0,
        this.prevTime = 0,
        this.now = 0,
        this.elapsed = 0,
        this.elapsedMS = 0,
        this.physicsElapsed = 1 / 60,
        this.physicsElapsedMS = 1 / 60 * 1e3,
        this.desiredFpsMult = 1 / 60,
        this._desiredFps = 60,
        this.suggestedFps = this.desiredFps,
        this.slowMotion = 1,
        this.advancedTiming = !1,
        this.frames = 0,
        this.updates = 0,
        this.renders = 0,
        this.fps = 0,
        this.ups = 0,
        this.rps = 0,
        this.fpsMin = 1e3,
        this.fpsMax = 0,
        this.msMin = 1e3,
        this.msMax = 0,
        this.pauseDuration = 0,
        this.timeToCall = 0,
        this.timeExpected = 0,
        this.events = new t.Timer(this.game, !1),
        this._frameCount = 0,
        this._elapsedAccumulator = 0,
        this._started = 0,
        this._timeLastSecond = 0,
        this._pauseStarted = 0,
        this._justResumed = !1,
        this._timers = []
    },
    t.Time.prototype = {
        boot: function() {
            this._started = Date.now(),
            this.time = Date.now(),
            this.events.start(),
            this.timeExpected = this.time
        },
        add: function(t) {
            return this._timers.push(t),
            t
        },
        create: function(e) {
            void 0 === e && (e = !0);
            var i = new t.Timer(this.game, e);
            return this._timers.push(i),
            i
        },
        removeAll: function() {
            for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
            this._timers = [],
            this.events.removeAll()
        },
        refresh: function() {
            var t = this.time;
            this.time = Date.now(),
            this.elapsedMS = this.time - t
        },
        update: function(t) {
            var e = this.time;
            this.time = Date.now(),
            this.elapsedMS = this.time - e,
            this.prevTime = this.now,
            this.now = t,
            this.elapsed = this.now - this.prevTime,
            this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall),
            this.advancedTiming && this.updateAdvancedTiming(),
            this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
        },
        updateTimers: function() {
            for (var t = 0,
            e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++:(this._timers.splice(t, 1), e--)
        },
        updateAdvancedTiming: function() {
            if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3) {
                var t = this.now - this._timeLastSecond;
                this.fps = Math.round(1e3 * this.frames / t),
                this.ups = Math.round(1e3 * this.updates / t),
                this.rps = Math.round(1e3 * this.renders / t),
                this.fpsMin = Math.min(this.fpsMin, this.fps),
                this.fpsMax = Math.max(this.fpsMax, this.fps),
                this._timeLastSecond = this.now,
                this.frames = 0,
                this.updates = 0,
                this.renders = 0
            }
        },
        countUpdate: function() {
            this.advancedTiming && this.updates++
        },
        countRender: function() {
            this.advancedTiming && this.renders++
        },
        gamePaused: function() {
            this._pauseStarted = Date.now(),
            this.events.pause();
            for (var t = this._timers.length; t--;) this._timers[t]._pause()
        },
        gameResumed: function() {
            this.time = Date.now(),
            this.pauseDuration = this.time - this._pauseStarted,
            this.events.resume();
            for (var t = this._timers.length; t--;) this._timers[t]._resume()
        },
        totalElapsedSeconds: function() {
            return.001 * (this.time - this._started)
        },
        elapsedSince: function(t) {
            return this.time - t
        },
        elapsedSecondsSince: function(t) {
            return.001 * (this.time - t)
        },
        reset: function() {
            this._started = this.time,
            this.removeAll()
        }
    },
    Object.defineProperty(t.Time.prototype, "desiredFps", {
        get: function() {
            return this._desiredFps
        },
        set: function(t) {
            this._desiredFps = t,
            this.physicsElapsed = 1 / t,
            this.physicsElapsedMS = 1e3 * this.physicsElapsed,
            this.desiredFpsMult = 1 / t
        }
    }),
    t.Time.prototype.constructor = t.Time,
    t.Timer = function(e, i) {
        void 0 === i && (i = !0),
        this.game = e,
        this.running = !1,
        this.autoDestroy = i,
        this.expired = !1,
        this.elapsed = 0,
        this.events = [],
        this.onComplete = new t.Signal,
        this.nextTick = 0,
        this.timeCap = 1e3,
        this.paused = !1,
        this._codePaused = !1,
        this._started = 0,
        this._pauseStarted = 0,
        this._pauseTotal = 0,
        this._now = Date.now(),
        this._len = 0,
        this._marked = 0,
        this._i = 0,
        this._diff = 0,
        this._newTick = 0
    },
    t.Timer.MINUTE = 6e4,
    t.Timer.SECOND = 1e3,
    t.Timer.HALF = 500,
    t.Timer.QUARTER = 250,
    t.Timer.prototype = {
        create: function(e, i, s, n, r, o) {
            var a = e = Math.round(e);
            0 === this._now ? a += this.game.time.time: a += this._now;
            var h = new t.TimerEvent(this, e, a, s, i, n, r, o);
            return this.events.push(h),
            this.order(),
            this.expired = !1,
            h
        },
        add: function(t, e, i) {
            return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
        },
        repeat: function(t, e, i, s) {
            return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
        },
        loop: function(t, e, i) {
            return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
        },
        start: function(t) {
            if (!this.running) {
                this._started = this.game.time.time + (t || 0),
                this.running = !0;
                for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
            }
        },
        stop: function(t) {
            this.running = !1,
            void 0 === t && (t = !0),
            t && (this.events.length = 0)
        },
        remove: function(t) {
            for (var e = 0; e < this.events.length; e++) if (this.events[e] === t) return this.events[e].pendingDelete = !0,
            !0;
            return ! 1
        },
        order: function() {
            this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
        },
        sortHandler: function(t, e) {
            return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
        },
        clearPendingEvents: function() {
            for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length,
            this._i = 0
        },
        update: function(t) {
            if (this.paused) return ! 0;
            if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                for (; this._i < this._len && this.running;) {
                    var e = this.events[this._i];
                    if (! (this._now >= e.tick) || e.pendingDelete) break;
                    this._newTick = this._now + e.delay - (this._now - e.tick),
                    this._newTick < 0 && (this._newTick = this._now + e.delay),
                    !0 === e.loop ? (e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : e.repeatCount > 0 ? (e.repeatCount--, e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : (this._marked++, e.pendingDelete = !0, e.callback.apply(e.callbackContext, e.args)),
                    this._i++
                }
                this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
            }
            return ! this.expired || !this.autoDestroy
        },
        pause: function() {
            this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
        },
        _pause: function() { ! this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
        },
        adjustEvents: function(t) {
            for (var e = 0; e < this.events.length; e++) if (!this.events[e].pendingDelete) {
                var i = this.events[e].tick - t;
                i < 0 && (i = 0),
                this.events[e].tick = this._now + i
            }
            var s = this.nextTick - t;
            this.nextTick = s < 0 ? this._now: this._now + s
        },
        resume: function() {
            if (this.paused) {
                var t = this.game.time.time;
                this._pauseTotal += t - this._now,
                this._now = t,
                this.adjustEvents(this._pauseStarted),
                this.paused = !1,
                this._codePaused = !1
            }
        },
        _resume: function() {
            this._codePaused || this.resume()
        },
        removeAll: function() {
            this.onComplete.removeAll(),
            this.events.length = 0,
            this._len = 0,
            this._i = 0
        },
        destroy: function() {
            this.onComplete.removeAll(),
            this.running = !1,
            this.expired = !0,
            this.events = [],
            this._len = 0,
            this._i = 0
        }
    },
    Object.defineProperty(t.Timer.prototype, "next", {
        get: function() {
            return this.nextTick
        }
    }),
    Object.defineProperty(t.Timer.prototype, "duration", {
        get: function() {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now: 0
        }
    }),
    Object.defineProperty(t.Timer.prototype, "length", {
        get: function() {
            return this.events.length
        }
    }),
    Object.defineProperty(t.Timer.prototype, "ms", {
        get: function() {
            return this.running ? this._now - this._started - this._pauseTotal: 0
        }
    }),
    Object.defineProperty(t.Timer.prototype, "seconds", {
        get: function() {
            return this.running ? .001 * this.ms: 0
        }
    }),
    t.Timer.prototype.constructor = t.Timer,
    t.TimerEvent = function(t, e, i, s, n, r, o, a) {
        this.timer = t,
        this.delay = e,
        this.tick = i,
        this.repeatCount = s - 1,
        this.loop = n,
        this.callback = r,
        this.callbackContext = o,
        this.args = a,
        this.pendingDelete = !1
    },
    t.TimerEvent.prototype.constructor = t.TimerEvent,
    t.AnimationManager = function(t) {
        this.sprite = t,
        this.game = t.game,
        this.currentFrame = null,
        this.currentAnim = null,
        this.updateIfVisible = !0,
        this.isLoaded = !1,
        this._frameData = null,
        this._anims = {},
        this._outputFrames = []
    },
    t.AnimationManager.prototype = {
        loadFrameData: function(t, e) {
            if (void 0 === t) return ! 1;
            if (this.isLoaded) for (var i in this._anims) this._anims[i].updateFrameData(t);
            return this._frameData = t,
            null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e: this.frame = e,
            this.isLoaded = !0,
            !0
        },
        copyFrameData: function(t, e) {
            if (this._frameData = t.clone(), this.isLoaded) for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
            return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e: this.frame = e,
            this.isLoaded = !0,
            !0
        },
        add: function(e, i, s, n, r) {
            return i = i || [],
            s = s || 60,
            void 0 === n && (n = !1),
            void 0 === r && (r = !(!i || "number" != typeof i[0])),
            this._outputFrames = [],
            this._frameData.getFrameIndexes(i, r, this._outputFrames),
            this._anims[e] = new t.Animation(this.game, this.sprite, e, this._frameData, this._outputFrames, s, n),
            this.currentAnim = this._anims[e],
            this.sprite.tilingTexture && (this.sprite.refreshTexture = !0),
            this._anims[e]
        },
        validateFrames: function(t, e) {
            void 0 === e && (e = !0);
            for (var i = 0; i < t.length; i++) if (!0 === e) {
                if (t[i] > this._frameData.total) return ! 1
            } else if (!1 === this._frameData.checkFrameName(t[i])) return ! 1;
            return ! 0
        },
        play: function(t, e, i, s) {
            if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim: (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
        },
        stop: function(t, e) {
            void 0 === e && (e = !1),
            !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
        },
        update: function() {
            return ! (this.updateIfVisible && !this.sprite.visible || !this.currentAnim || !this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))
        },
        next: function(t) {
            this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
        },
        previous: function(t) {
            this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
        },
        getAnimation: function(t) {
            return "string" == typeof t && this._anims[t] ? this._anims[t] : null
        },
        refreshFrame: function() {},
        destroy: function() {
            for (var t in t = null,
            this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
            this._anims = {},
            this._outputFrames = [],
            this._frameData = null,
            this.currentAnim = null,
            this.currentFrame = null,
            this.sprite = null,
            this.game = null
        }
    },
    t.AnimationManager.prototype.constructor = t.AnimationManager,
    Object.defineProperty(t.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData
        }
    }),
    Object.defineProperty(t.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total
        }
    }),
    Object.defineProperty(t.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused
        },
        set: function(t) {
            this.currentAnim.paused = t
        }
    }),
    Object.defineProperty(t.AnimationManager.prototype, "name", {
        get: function() {
            if (this.currentAnim) return this.currentAnim.name
        }
    }),
    Object.defineProperty(t.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) return this.currentFrame.index
        },
        set: function(t) {
            var e;
            "number" == typeof t && this._frameData && (e = this._frameData.getFrame(t)) && (this.currentFrame = e, this.sprite.setFrame(this.currentFrame))
        }
    }),
    Object.defineProperty(t.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) return this.currentFrame.name
        },
        set: function(t) {
            var e;
            "string" == typeof t && this._frameData && (e = this._frameData.getFrameByName(t)) ? (this.currentFrame = e, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + t)
        }
    }),
    t.Animation = function(e, i, s, n, r, o, a) {
        void 0 === a && (a = !1),
        this.game = e,
        this._parent = i,
        this._frameData = n,
        this.name = s,
        this._frames = [],
        this._frames = this._frames.concat(r),
        this.delay = 1e3 / o,
        this.loop = a,
        this.loopCount = 0,
        this.killOnComplete = !1,
        this.isFinished = !1,
        this.isPlaying = !1,
        this.isPaused = !1,
        this._pauseStartTime = 0,
        this._frameIndex = 0,
        this._frameDiff = 0,
        this._frameSkip = 1,
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
        this.onStart = new t.Signal,
        this.onUpdate = null,
        this.onComplete = new t.Signal,
        this.onLoop = new t.Signal,
        this.isReversed = !1,
        this.game.onPause.add(this.onPause, this),
        this.game.onResume.add(this.onResume, this)
    },
    t.Animation.prototype = {
        play: function(t, e, i) {
            return "number" == typeof t && (this.delay = 1e3 / t),
            "boolean" == typeof e && (this.loop = e),
            void 0 !== i && (this.killOnComplete = i),
            this.isPlaying = !0,
            this.isFinished = !1,
            this.paused = !1,
            this.loopCount = 0,
            this._timeLastFrame = this.game.time.time,
            this._timeNextFrame = this.game.time.time + this.delay,
            this._frameIndex = this.isReversed ? this._frames.length - 1 : 0,
            this.updateCurrentFrame(!1, !0),
            this._parent.events.onAnimationStart$dispatch(this._parent, this),
            this.onStart.dispatch(this._parent, this),
            this._parent.animations.currentAnim = this,
            this._parent.animations.currentFrame = this.currentFrame,
            this
        },
        restart: function() {
            this.isPlaying = !0,
            this.isFinished = !1,
            this.paused = !1,
            this.loopCount = 0,
            this._timeLastFrame = this.game.time.time,
            this._timeNextFrame = this.game.time.time + this.delay,
            this._frameIndex = 0,
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this._parent.setFrame(this.currentFrame),
            this._parent.animations.currentAnim = this,
            this._parent.animations.currentFrame = this.currentFrame,
            this.onStart.dispatch(this._parent, this)
        },
        reverse: function() {
            return this.reversed = !this.reversed,
            this
        },
        reverseOnce: function() {
            return this.onComplete.addOnce(this.reverse, this),
            this.reverse()
        },
        setFrame: function(t, e) {
            var i;
            if (void 0 === e && (e = !1), "string" == typeof t) for (s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
            else if ("number" == typeof t) if (e) i = t;
            else for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
            if (i) {
                var n = this.isReversed ? -1 : 1;
                this._frameIndex = i - n,
                this._timeNextFrame = this.game.time.time,
                this.update()
            }
        },
        stop: function(t, e) {
            void 0 === t && (t = !1),
            void 0 === e && (e = !1),
            this.isPlaying = !1,
            this.isFinished = !0,
            this.paused = !1,
            t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)),
            e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
        },
        onPause: function() {
            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
        },
        onResume: function() {
            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
        },
        update: function() {
            return ! this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay ? (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay) : this._frameDiff = 0, this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip: this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
        },
        updateCurrentFrame: function(t, e) {
            if (void 0 === e && (e = !1), !this._frameData) return ! 1;
            var i = this.currentFrame.index;
            return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame),
            !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
        },
        next: function(t) {
            void 0 === t && (t = 1);
            var e = this._frameIndex + t;
            e >= this._frames.length && (this.loop ? e %= this._frames.length: e = this._frames.length - 1),
            e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
        },
        previous: function(t) {
            void 0 === t && (t = 1);
            var e = this._frameIndex - t;
            e < 0 && (this.loop ? e = this._frames.length + e: e++),
            e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
        },
        updateFrameData: function(t) {
            this._frameData = t,
            this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
        },
        destroy: function() {
            this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
        },
        complete: function() {
            this._frameIndex = this._frames.length - 1,
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.updateCurrentFrame(!1),
            this.isPlaying = !1,
            this.isFinished = !0,
            this.paused = !1,
            this._parent.events.onAnimationComplete$dispatch(this._parent, this),
            this.onComplete.dispatch(this._parent, this),
            this.killOnComplete && this._parent.kill()
        }
    },
    t.Animation.prototype.constructor = t.Animation,
    Object.defineProperty(t.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused
        },
        set: function(t) {
            this.isPaused = t,
            t ? this._pauseStartTime = this.game.time.time: this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
        }
    }),
    Object.defineProperty(t.Animation.prototype, "reversed", {
        get: function() {
            return this.isReversed
        },
        set: function(t) {
            this.isReversed = t
        }
    }),
    Object.defineProperty(t.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length
        }
    }),
    Object.defineProperty(t.Animation.prototype, "frame", {
        get: function() {
            return null !== this.currentFrame ? this.currentFrame.index: this._frameIndex
        },
        set: function(t) {
            this.currentFrame = this._frameData.getFrame(this._frames[t]),
            null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
        }
    }),
    Object.defineProperty(t.Animation.prototype, "speed", {
        get: function() {
            return 1e3 / this.delay
        },
        set: function(t) {
            t > 0 && (this.delay = 1e3 / t)
        }
    }),
    Object.defineProperty(t.Animation.prototype, "enableUpdate", {
        get: function() {
            return null !== this.onUpdate
        },
        set: function(e) {
            e && null === this.onUpdate ? this.onUpdate = new t.Signal: e || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
        }
    }),
    t.Animation.generateFrameNames = function(e, i, s, n, r) {
        void 0 === n && (n = "");
        var o = [],
        a = "";
        if (i < s) for (h = i; h <= s; h++) a = e + (a = "number" == typeof r ? t.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n,
        o.push(a);
        else for (var h = i; h >= s; h--) a = e + (a = "number" == typeof r ? t.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n,
        o.push(a);
        return o
    },
    t.Frame = function(e, i, s, n, r, o) {
        this.index = e,
        this.x = i,
        this.y = s,
        this.width = n,
        this.height = r,
        0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'),
        this.name = o,
        this.centerX = Math.floor(n / 2),
        this.centerY = Math.floor(r / 2),
        this.distance = t.Math.distance(0, 0, n, r),
        this.rotated = !1,
        this.trimmed = !1,
        this.sourceSizeW = n,
        this.sourceSizeH = r,
        this.spriteSourceSizeX = 0,
        this.spriteSourceSizeY = 0,
        this.spriteSourceSizeW = 0,
        this.spriteSourceSizeH = 0,
        this.right = this.x + this.width,
        this.bottom = this.y + this.height
    },
    t.Frame.prototype = {
        resize: function(e, i) {
            this.width = e,
            this.height = i,
            this.centerX = Math.floor(e / 2),
            this.centerY = Math.floor(i / 2),
            this.distance = t.Math.distance(0, 0, e, i),
            this.sourceSizeW = e,
            this.sourceSizeH = i,
            this.right = this.x + e,
            this.bottom = this.y + i
        },
        setTrim: function(t, e, i, s, n, r, o) {
            this.trimmed = t,
            t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
        },
        clone: function() {
            var e = new t.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
            for (var i in this) this.hasOwnProperty(i) && (e[i] = this[i]);
            return e
        },
        getRect: function(e) {
            return void 0 === e ? e = new t.Rectangle(this.x, this.y, this.width, this.height) : e.setTo(this.x, this.y, this.width, this.height),
            e
        }
    },
    t.Frame.prototype.constructor = t.Frame,
    t.FrameData = function() {
        this._frames = [],
        this._frameNames = []
    },
    t.FrameData.prototype = {
        addFrame: function(t) {
            return t.index = this._frames.length,
            this._frames.push(t),
            "" !== t.name && (this._frameNames[t.name] = t.index),
            t
        },
        getFrame: function(t) {
            return t >= this._frames.length && (t = 0),
            this._frames[t]
        },
        getFrameByName: function(t) {
            return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
        },
        checkFrameName: function(t) {
            return null != this._frameNames[t]
        },
        clone: function() {
            for (var e = new t.FrameData,
            i = 0; i < this._frames.length; i++) e._frames.push(this._frames[i].clone());
            for (var s in this._frameNames) this._frameNames.hasOwnProperty(s) && e._frameNames.push(this._frameNames[s]);
            return e
        },
        getFrameRange: function(t, e, i) {
            void 0 === i && (i = []);
            for (var s = t; s <= e; s++) i.push(this._frames[s]);
            return i
        },
        getFrames: function(t, e, i) {
            if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length) for (s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
            else for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
            return i
        },
        getFrameIndexes: function(t, e, i) {
            if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length) for (s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
            else for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
            return i
        },
        destroy: function() {
            this._frames = null,
            this._frameNames = null
        }
    },
    t.FrameData.prototype.constructor = t.FrameData,
    Object.defineProperty(t.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length
        }
    }),
    t.AnimationParser = {
        spriteSheet: function(e, i, s, n, r, o, a, h) {
            void 0 === r && (r = -1),
            void 0 === o && (o = 0),
            void 0 === a && (a = 0),
            void 0 === h && (h = 0);
            var l = i;
            if ("string" == typeof i ? l = e.cache.getImage(i) : i = l.name, null === l) return null;
            if (s <= 0 || n <= 0) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' frameWidth (%s) or frameHeight (%s) must be positive", i, s, n),
            null;
            var c = l.width,
            u = l.height;
            if (0 === c || 0 === u) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is zero", i, c, u),
            null;
            if (c < s || u < n) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is less than the given frameWidth (%s) or frameHeight (%s)", i, c, u, s, n),
            null;
            var d = Math.floor((c - o) / (s + a)),
            p = Math.floor((u - o) / (n + a)),
            f = d * p,
            g = f,
            m = f - 1,
            y = 0,
            v = m;
            if (h > f || h < -f) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' skipFrames = %s is larger than the frame total %s", i, h, f),
            null;
            if (r > -1 && (v = (f = r) - 1), d < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has width %d, but it should be at least %d (frameWidth=%s, margin=%s, spacing=%s)", i, c, s + o + a, s, o, a), p < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has height %d, but it should be at least %d (frameHeight=%s, margin=%s, spacing=%s)", i, u, n + o + a, n, o, a), 0 === g) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' zero frames were produced", i),
            null;
            if (h > 0 ? v = (y = h) + (f = Math.min(f, g - h)) - 1 : h < 0 && (y = (v = m + h) - (f = Math.min(f, g + h)) + 1), y < 0) return console.warn("First frame index %s is outside of range [0, %d]", y, m),
            null;
            if (v > m) return console.warn("Last frame index %s is outside of range [0, %d]", v, m),
            null;
            for (var x = new t.FrameData,
            b = o,
            _ = o,
            w = 0,
            T = 0; T < g && !(T > v); T++) T >= y && x.addFrame(new t.Frame(w++, b, _, s, n, "")),
            (b += s + a) + s > c && (b = o, _ += n + a);
            return x
        },
        JSONData: function(e, i) {
            if (!i.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"),
            void console.log(i);
            for (var s, n = new t.FrameData,
            r = i.frames,
            o = 0; o < r.length; o++) s = n.addFrame(new t.Frame(o, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, r[o].filename)),
            r[o].trimmed && s.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h),
            r[o].rotated && (s.rotated = !0);
            return n
        },
        JSONDataPyxel: function(e, i) {
            if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                if (!i[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'),
                void console.log(i)
            }), 1 !== i.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."),
            void console.log(i);
            for (var s = new t.FrameData,
            n = i.tileheight,
            r = i.tilewidth,
            o = i.layers[0].tiles, a = 0; a < o.length; a++) s.addFrame(new t.Frame(a, o[a].x, o[a].y, r, n, "frame_" + a)).setTrim(!1);
            return s
        },
        JSONDataHash: function(e, i) {
            if (!i.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"),
            void console.log(i);
            var s, n = new t.FrameData,
            r = i.frames,
            o = 0;
            for (var a in r) s = n.addFrame(new t.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)),
            r[a].trimmed && s.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h),
            r[a].rotated && (s.rotated = !0),
            o++;
            return n
        },
        XMLData: function(e, i) {
            if (i.getElementsByTagName("TextureAtlas")) {
                for (var s, n, r, o, a, h, l, c, u, d, p, f = new t.FrameData,
                g = i.getElementsByTagName("SubTexture"), m = 0; m < g.length; m++) n = (r = g[m].attributes).name.value,
                o = parseInt(r.x.value, 10),
                a = parseInt(r.y.value, 10),
                h = parseInt(r.width.value, 10),
                l = parseInt(r.height.value, 10),
                c = null,
                u = null,
                r.frameX && (c = Math.abs(parseInt(r.frameX.value, 10)), u = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)),
                s = f.addFrame(new t.Frame(m, o, a, h, l, n)),
                null === c && null === u || s.setTrim(!0, h, l, c, u, d, p);
                return f
            }
            console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
        }
    },
    t.Cache = function(e) {
        this.game = e,
        this.autoResolveURL = !1,
        this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {},
            compressedTexture: {}
        },
        this._urlMap = {},
        this._urlResolver = new Image,
        this._urlTemp = null,
        this.onSoundUnlock = new t.Signal,
        this._cacheMap = [],
        this._cacheMap[t.Cache.CANVAS] = this._cache.canvas,
        this._cacheMap[t.Cache.IMAGE] = this._cache.image,
        this._cacheMap[t.Cache.TEXTURE] = this._cache.texture,
        this._cacheMap[t.Cache.SOUND] = this._cache.sound,
        this._cacheMap[t.Cache.TEXT] = this._cache.text,
        this._cacheMap[t.Cache.PHYSICS] = this._cache.physics,
        this._cacheMap[t.Cache.TILEMAP] = this._cache.tilemap,
        this._cacheMap[t.Cache.BINARY] = this._cache.binary,
        this._cacheMap[t.Cache.BITMAPDATA] = this._cache.bitmapData,
        this._cacheMap[t.Cache.BITMAPFONT] = this._cache.bitmapFont,
        this._cacheMap[t.Cache.JSON] = this._cache.json,
        this._cacheMap[t.Cache.XML] = this._cache.xml,
        this._cacheMap[t.Cache.VIDEO] = this._cache.video,
        this._cacheMap[t.Cache.SHADER] = this._cache.shader,
        this._cacheMap[t.Cache.RENDER_TEXTURE] = this._cache.renderTexture,
        this._pendingCount = 0,
        this.onReady = new t.Signal,
        this._addImages()
    },
    t.Cache.CANVAS = 1,
    t.Cache.IMAGE = 2,
    t.Cache.TEXTURE = 3,
    t.Cache.SOUND = 4,
    t.Cache.TEXT = 5,
    t.Cache.PHYSICS = 6,
    t.Cache.TILEMAP = 7,
    t.Cache.BINARY = 8,
    t.Cache.BITMAPDATA = 9,
    t.Cache.BITMAPFONT = 10,
    t.Cache.JSON = 11,
    t.Cache.XML = 12,
    t.Cache.VIDEO = 13,
    t.Cache.SHADER = 14,
    t.Cache.RENDER_TEXTURE = 15,
    t.Cache.DEFAULT = null,
    t.Cache.DEFAULT_KEY = "__default",
    t.Cache.DEFAULT_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==",
    t.Cache.MISSING = null,
    t.Cache.MISSING_KEY = "__missing",
    t.Cache.MISSING_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==",
    t.Cache.READY_TIMEOUT = 1e3,
    t.Cache.prototype = {
        addCompressedTextureMetaData: function(e, i, s, n) {
            this.checkImageKey(e) && this.removeImage(e);
            var r = s in t.LoaderParser ? t.LoaderParser[s](n) : n,
            o = {
                key: e,
                url: i,
                data: r,
                base: new PIXI.BaseTexture(r, null, this.game.resolution),
                frame: new t.Frame(0, 0, 0, r.width, r.height, e),
                frameData: new t.FrameData,
                fileFormat: s
            };
            return o.frameData.addFrame(new t.Frame(0, 0, 0, r.width, r.height, i)),
            this._cache.image[e] = o,
            this._resolveURL(i, o),
            o
        },
        addCanvas: function(t, e, i) {
            void 0 === i && (i = e.getContext("2d")),
            this._cache.canvas[t] = {
                canvas: e,
                context: i
            }
        },
        addImage: function(e, i, s) {
            this.checkImageKey(e) && this.removeImage(e),
            !1 === s.complete && console.warn('Phaser.Cache.addImage: Image "%s" is not complete', e);
            var n = {
                key: e,
                url: i,
                data: s,
                base: new PIXI.BaseTexture(s, null, this.game.resolution),
                frame: new t.Frame(0, 0, 0, s.width, s.height, e),
                frameData: new t.FrameData
            };
            return n.frameData.addFrame(new t.Frame(0, 0, 0, s.width, s.height, i)),
            this._cache.image[e] = n,
            this._resolveURL(i, n),
            "__default" === e ? t.Cache.DEFAULT = new PIXI.Texture(n.base) : "__missing" === e && (t.Cache.MISSING = new PIXI.Texture(n.base)),
            n
        },
        addImageAsync: function(t, e, i) {
            var s = this,
            n = new Image;
            n.onload = function() {
                i.call(this, s.addImage(t, null, n)),
                s._removePending(),
                n.onload = null
            },
            this._addPending(),
            n.src = e
        },
        addDefaultImage: function() {
            this.addImageAsync(t.Cache.DEFAULT_KEY, t.Cache.DEFAULT_SRC,
            function(e) {
                e.base.skipRender = !0,
                t.Cache.DEFAULT = new PIXI.Texture(e.base)
            })
        },
        addMissingImage: function() {
            this.addImageAsync(t.Cache.MISSING_KEY, t.Cache.MISSING_SRC,
            function(e) {
                t.Cache.MISSING = new PIXI.Texture(e.base)
            })
        },
        addSound: function(t, e, i, s, n) {
            void 0 === s && (s = !0, n = !1),
            void 0 === n && (s = !1, n = !0);
            var r = !1;
            n && (r = !0),
            this._cache.sound[t] = {
                url: e,
                data: i,
                isDecoding: !1,
                decoded: r,
                webAudio: s,
                audioTag: n,
                locked: this.game.sound.touchLocked
            },
            this._resolveURL(e, this._cache.sound[t])
        },
        addText: function(t, e, i) {
            this._cache.text[t] = {
                url: e,
                data: i
            },
            this._resolveURL(e, this._cache.text[t])
        },
        addPhysicsData: function(t, e, i, s) {
            this._cache.physics[t] = {
                url: e,
                data: i,
                format: s
            },
            this._resolveURL(e, this._cache.physics[t])
        },
        addTilemap: function(t, e, i, s) {
            this._cache.tilemap[t] = {
                url: e,
                data: i,
                format: s
            },
            this._resolveURL(e, this._cache.tilemap[t])
        },
        addBinary: function(t, e) {
            this._cache.binary[t] = e
        },
        addBitmapData: function(e, i, s) {
            return i.key = e,
            void 0 === s && (s = new t.FrameData).addFrame(i.textureFrame),
            this._cache.bitmapData[e] = {
                data: i,
                frameData: s
            },
            i
        },
        addBitmapFont: function(e, i, s, n, r, o, a) {
            var h = {
                url: i,
                data: s,
                font: null,
                base: new PIXI.BaseTexture(s, null, this.game.resolution)
            };
            void 0 === o && (o = 0),
            void 0 === a && (a = 0),
            h.font = "json" === r ? t.LoaderParser.jsonBitmapFont(n, h.base, o, a, !1, this.game.resolution) : t.LoaderParser.xmlBitmapFont(n, h.base, o, a, !1, this.game.resolution),
            this._cache.bitmapFont[e] = h,
            this._resolveURL(i, h)
        },
        addBitmapFontFromAtlas: function(e, i, s, n, r, o, a) {
            var h = this.getFrameByName(i, s);
            if (h) {
                var l, c = {
                    font: null,
                    base: this.getBaseTexture(i),
                    frame: h
                };
                void 0 === o && (o = 0),
                void 0 === a && (a = 0),
                "json" === r ? (l = this.getJSON(n), c.font = t.LoaderParser.jsonBitmapFont(l, c.base, o, a, h, this.game.resolution)) : (l = this.getXML(n), c.font = t.LoaderParser.xmlBitmapFont(l, c.base, o, a, h, this.game.resolution)),
                this._cache.bitmapFont[e] = c
            }
        },
        addJSON: function(t, e, i) {
            this._cache.json[t] = {
                url: e,
                data: i
            },
            this._resolveURL(e, this._cache.json[t])
        },
        addXML: function(t, e, i) {
            this._cache.xml[t] = {
                url: e,
                data: i
            },
            this._resolveURL(e, this._cache.xml[t])
        },
        addVideo: function(t, e, i, s) {
            this._cache.video[t] = {
                url: e,
                data: i,
                isBlob: s,
                locked: !0
            },
            this._resolveURL(e, this._cache.video[t])
        },
        addShader: function(t, e, i) {
            this._cache.shader[t] = {
                url: e,
                data: i
            },
            this._resolveURL(e, this._cache.shader[t])
        },
        addRenderTexture: function(e, i) {
            this._cache.renderTexture[e] = {
                texture: i,
                frame: new t.Frame(0, 0, 0, i.width, i.height, "", "")
            }
        },
        addSpriteSheet: function(e, i, s, n, r, o, a, h, l) {
            void 0 === o && (o = -1),
            void 0 === a && (a = 0),
            void 0 === h && (h = 0);
            var c = {
                key: e,
                url: i,
                data: s,
                frameWidth: n,
                frameHeight: r,
                margin: a,
                spacing: h,
                base: new PIXI.BaseTexture(s, null, this.game.resolution),
                frameData: t.AnimationParser.spriteSheet(this.game, s, n, r, o, a, h, l)
            };
            this._cache.image[e] = c,
            this._resolveURL(i, c)
        },
        addTextureAtlas: function(e, i, s, n, r) {
            var o = {
                key: e,
                url: i,
                data: s,
                base: new PIXI.BaseTexture(s, null, this.game.resolution)
            };
            r === t.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = t.AnimationParser.XMLData(this.game, n, e) : r === t.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = t.AnimationParser.JSONDataPyxel(this.game, n, e) : Array.isArray(n.frames) ? o.frameData = t.AnimationParser.JSONData(this.game, n, e) : o.frameData = t.AnimationParser.JSONDataHash(this.game, n, e),
            this._cache.image[e] = o,
            this._resolveURL(i, o)
        },
        reloadSound: function(t) {
            var e = this,
            i = this.getSound(t);
            i && (i.data.src = i.url, i.data.addEventListener("canplaythrough",
            function() {
                return e.reloadSoundComplete(t)
            },
            !1), i.data.load())
        },
        reloadSoundComplete: function(t) {
            var e = this.getSound(t);
            e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
        },
        updateSound: function(t, e, i) {
            var s = this.getSound(t);
            s && (s[e] = i)
        },
        decodedSound: function(t, e) {
            var i = this.getSound(t);
            i.data = e,
            i.decoded = !0,
            i.isDecoding = !1
        },
        isSoundDecoded: function(e) {
            var i = this.getItem(e, t.Cache.SOUND, "isSoundDecoded");
            if (i) return i.decoded
        },
        isSoundReady: function(e) {
            var i = this.getItem(e, t.Cache.SOUND, "isSoundDecoded");
            if (i) return i.decoded && !this.game.sound.touchLocked
        },
        checkKey: function(t, e) {
            return !! this._cacheMap[t][e]
        },
        checkURL: function(t) {
            return !! this._urlMap[this._resolveURL(t)]
        },
        checkCanvasKey: function(e) {
            return this.checkKey(t.Cache.CANVAS, e)
        },
        checkImageKey: function(e) {
            return this.checkKey(t.Cache.IMAGE, e)
        },
        checkTextureKey: function(e) {
            return this.checkKey(t.Cache.TEXTURE, e)
        },
        checkSoundKey: function(e) {
            return this.checkKey(t.Cache.SOUND, e)
        },
        checkTextKey: function(e) {
            return this.checkKey(t.Cache.TEXT, e)
        },
        checkPhysicsKey: function(e) {
            return this.checkKey(t.Cache.PHYSICS, e)
        },
        checkTilemapKey: function(e) {
            return this.checkKey(t.Cache.TILEMAP, e)
        },
        checkBinaryKey: function(e) {
            return this.checkKey(t.Cache.BINARY, e)
        },
        checkBitmapDataKey: function(e) {
            return this.checkKey(t.Cache.BITMAPDATA, e)
        },
        checkBitmapFontKey: function(e) {
            return this.checkKey(t.Cache.BITMAPFONT, e)
        },
        checkJSONKey: function(e) {
            return this.checkKey(t.Cache.JSON, e)
        },
        checkXMLKey: function(e) {
            return this.checkKey(t.Cache.XML, e)
        },
        checkVideoKey: function(e) {
            return this.checkKey(t.Cache.VIDEO, e)
        },
        checkShaderKey: function(e) {
            return this.checkKey(t.Cache.SHADER, e)
        },
        checkRenderTextureKey: function(e) {
            return this.checkKey(t.Cache.RENDER_TEXTURE, e)
        },
        getItem: function(t, e, i, s) {
            return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
        },
        getCanvas: function(e) {
            return this.getItem(e, t.Cache.CANVAS, "getCanvas", "canvas")
        },
        getImage: function(e, i) {
            null != e || (e = "__default"),
            void 0 === i && (i = !1);
            var s = this.getItem(e, t.Cache.IMAGE, "getImage");
            return null === s && (s = this.getItem("__missing", t.Cache.IMAGE, "getImage")),
            i ? s: s.data
        },
        getTextureFrame: function(e) {
            return this.getItem(e, t.Cache.TEXTURE, "getTextureFrame", "frame")
        },
        getSound: function(e) {
            return this.getItem(e, t.Cache.SOUND, "getSound")
        },
        getSoundData: function(e) {
            return this.getItem(e, t.Cache.SOUND, "getSoundData", "data")
        },
        getText: function(e) {
            return this.getItem(e, t.Cache.TEXT, "getText", "data")
        },
        getPhysicsData: function(e, i, s) {
            var n = this.getItem(e, t.Cache.PHYSICS, "getPhysicsData", "data");
            if (null === n || null == i) return n;
            if (n[i]) {
                var r = n[i];
                if (!r || !s) return r;
                for (var o in r) if ((o = r[o]).fixtureKey === s) return o;
                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + s + " in " + e + '"')
            } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + e + " / " + i + '"');
            return null
        },
        getTilemapData: function(e) {
            return this.getItem(e, t.Cache.TILEMAP, "getTilemapData")
        },
        getBinary: function(e) {
            return this.getItem(e, t.Cache.BINARY, "getBinary")
        },
        getBitmapData: function(e) {
            return this.getItem(e, t.Cache.BITMAPDATA, "getBitmapData", "data")
        },
        getBitmapFont: function(e) {
            return this.getItem(e, t.Cache.BITMAPFONT, "getBitmapFont")
        },
        getJSON: function(e, i) {
            var s = this.getItem(e, t.Cache.JSON, "getJSON", "data");
            return s ? i ? t.Utils.extend(!0, Array.isArray(s) ? [] : {},
            s) : s: null
        },
        getXML: function(e) {
            return this.getItem(e, t.Cache.XML, "getXML", "data")
        },
        getVideo: function(e) {
            return this.getItem(e, t.Cache.VIDEO, "getVideo")
        },
        getShader: function(e) {
            return this.getItem(e, t.Cache.SHADER, "getShader", "data")
        },
        getRenderTexture: function(e) {
            return this.getItem(e, t.Cache.RENDER_TEXTURE, "getRenderTexture")
        },
        getBaseTexture: function(e, i) {
            return void 0 === i && (i = t.Cache.IMAGE),
            this.getItem(e, i, "getBaseTexture", "base")
        },
        getFrame: function(e, i) {
            return void 0 === i && (i = t.Cache.IMAGE),
            this.getItem(e, i, "getFrame", "frame")
        },
        getFrameCount: function(t, e) {
            var i = this.getFrameData(t, e);
            return i ? i.total: 0
        },
        getFrameData: function(e, i) {
            return void 0 === i && (i = t.Cache.IMAGE),
            this.getItem(e, i, "getFrameData", "frameData")
        },
        hasFrameData: function(e, i) {
            return void 0 === i && (i = t.Cache.IMAGE),
            null !== this.getItem(e, i, "", "frameData")
        },
        updateFrameData: function(e, i, s) {
            void 0 === s && (s = t.Cache.IMAGE),
            this._cacheMap[s][e] && (this._cacheMap[s][e].frameData = i)
        },
        getFrameByIndex: function(t, e, i) {
            var s = this.getFrameData(t, i);
            return s ? s.getFrame(e) : null
        },
        getFrameByName: function(t, e, i) {
            var s = this.getFrameData(t, i);
            return s ? s.getFrameByName(e) : null
        },
        getURL: function(t) {
            return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
        },
        getKeys: function(e) {
            void 0 === e && (e = t.Cache.IMAGE);
            var i = [];
            if (this._cacheMap[e]) for (var s in this._cacheMap[e])"__default" !== s && "__missing" !== s && i.push(s);
            return i
        },
        removeCanvas: function(t) {
            delete this._cache.canvas[t]
        },
        removeImage: function(t, e) {
            void 0 === e && (e = !0);
            var i = this.getImage(t, !0);
            e && i.base && i.base.destroy(),
            delete this._cache.image[t]
        },
        removeSound: function(t) {
            delete this._cache.sound[t]
        },
        removeText: function(t) {
            delete this._cache.text[t]
        },
        removePhysics: function(t) {
            delete this._cache.physics[t]
        },
        removeTilemap: function(t) {
            delete this._cache.tilemap[t]
        },
        removeBinary: function(t) {
            delete this._cache.binary[t]
        },
        removeBitmapData: function(t) {
            delete this._cache.bitmapData[t]
        },
        removeBitmapFont: function(t) {
            delete this._cache.bitmapFont[t]
        },
        removeJSON: function(t) {
            delete this._cache.json[t]
        },
        removeXML: function(t) {
            delete this._cache.xml[t]
        },
        removeVideo: function(t) {
            delete this._cache.video[t]
        },
        removeShader: function(t) {
            delete this._cache.shader[t]
        },
        removeRenderTexture: function(t) {
            delete this._cache.renderTexture[t]
        },
        removeSpriteSheet: function(t) {
            delete this._cache.spriteSheet[t]
        },
        removeTextureAtlas: function(t) {
            delete this._cache.image[t]
        },
        clearGLTextures: function() {
            for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
        },
        _resolveURL: function(t, e) {
            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
        },
        destroy: function() {
            for (var t = 0; t < this._cacheMap.length; t++) {
                var e = this._cacheMap[t];
                for (var i in e)"__default" !== i && "__missing" !== i && (this.destroyItem(e[i]), delete e[i])
            }
            this._urlMap = null,
            this._urlResolver = null,
            this._urlTemp = null
        },
        destroyItem: function(t) {
            t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(), t.data && t.data.destroy && t.data.destroy(), t.frameData && t.frameData.destroy && t.frameData.destroy(), t.texture && t.texture.destroy && t.texture.destroy(!0))
        },
        _addImages: function() {
            this._pendingCount = 0,
            this.addDefaultImage(),
            this.addMissingImage();
            var e = this,
            i = t.Cache.READY_TIMEOUT;
            t.Cache.READY_TIMEOUT > 0 ? setTimeout(function() {
                e.isReady || (console.warn("Phaser.Cache: Still waiting for images after %s ms.", i), e._ready())
            },
            t.Cache.READY_TIMEOUT) : this._ready()
        },
        _addPending: function() {
            this._pendingCount += 1
        },
        _removePending: function() {
            this._pendingCount -= 1,
            this._checkReady()
        },
        _checkReady: function() {
            this.isReady && this._ready()
        },
        _ready: function() {
            this._pendingCount = 0,
            this.onReady.dispatch(this)
        }
    },
    t.Cache.prototype.constructor = t.Cache,
    Object.defineProperty(t.Cache.prototype, "isReady", {
        get: function() {
            return this._pendingCount <= 0
        }
    }),
    t.Loader = function(e) {
        this.game = e,
        this.cache = e.cache,
        this.resetLocked = !1,
        this.isLoading = !1,
        this.hasLoaded = !1,
        this.preloadSprite = null,
        this.crossOrigin = !1,
        this.baseURL = "",
        this.path = "",
        this.headers = {
            requestedWith: !1,
            json: "application/json",
            xml: "application/xml"
        },
        this.onLoadStart = new t.Signal,
        this.onBeforeLoadComplete = new t.Signal,
        this.onLoadComplete = new t.Signal,
        this.onPackComplete = new t.Signal,
        this.onFileStart = new t.Signal,
        this.onFileComplete = new t.Signal,
        this.onFileError = new t.Signal,
        this.enableParallel = !0,
        this.maxParallelDownloads = 4,
        this._withSyncPointDepth = 0,
        this._fileList = [],
        this._flightQueue = [],
        this._processingHead = 0,
        this._fileLoadStarted = !1,
        this._totalPackCount = 0,
        this._totalFileCount = 0,
        this._loadedPackCount = 0,
        this._loadedFileCount = 0
    },
    t.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0,
    t.Loader.TEXTURE_ATLAS_JSON_HASH = 1,
    t.Loader.TEXTURE_ATLAS_XML_STARLING = 2,
    t.Loader.PHYSICS_LIME_CORONA_JSON = 3,
    t.Loader.PHYSICS_PHASER_JSON = 4,
    t.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5,
    t.Loader.prototype = {
        setPreloadSprite: function(e, i) {
            i = i || 0,
            this.preloadSprite = {
                sprite: e,
                direction: i,
                width: e.width,
                height: e.height,
                rect: null
            },
            this.preloadSprite.rect = 0 === i ? new t.Rectangle(0, 0, 1, e.height) : new t.Rectangle(0, 0, e.width, 1),
            e.crop(this.preloadSprite.rect),
            e.visible = !0
        },
        resize: function() {
            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
        },
        checkKeyExists: function(t, e) {
            return this.getAssetIndex(t, e) > -1
        },
        getAssetIndex: function(t, e) {
            for (var i = -1,
            s = 0; s < this._fileList.length; s++) {
                var n = this._fileList[s];
                if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
            }
            return i
        },
        getAsset: function(t, e) {
            var i = this.getAssetIndex(t, e);
            return i > -1 && {
                index: i,
                file: this._fileList[i]
            }
        },
        reset: function(t, e) {
            void 0 === e && (e = !1),
            this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
        },
        addToFileList: function(t, e, i, s, n, r) {
            if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t),
            this;
            if (null == i) {
                if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e),
                this;
                i = e + r
            }
            var o = {
                type: t,
                key: e,
                path: this.path,
                url: i,
                syncPoint: this._withSyncPointDepth > 0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (s) for (var a in s) o[a] = s[a];
            var h = this.getAssetIndex(t, e);
            if (n && h > -1) {
                var l = this._fileList[h];
                l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
            } else - 1 === h && (this._fileList.push(o), this._totalFileCount++);
            return this
        },
        replaceInFileList: function(t, e, i, s) {
            return this.addToFileList(t, e, i, s, !0)
        },
        pack: function(t, e, i, s) {
            if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."),
            this;
            var n = {
                type: "packfile",
                key: t,
                url: e,
                path: this.path,
                syncPoint: !0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1,
                callbackContext: s
            };
            i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {},
            n.loaded = !0);
            for (var r = 0; r < this._fileList.length + 1; r++) {
                var o = this._fileList[r];
                if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                    this._fileList.splice(r, 0, n),
                    this._totalPackCount++;
                    break
                }
            }
            return this
        },
        image: function(t, e, i) {
            return "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
        },
        imageFromBitmapData: function(t, e, i) {
            return this.image(t, e.canvas.toDataURL("image/png"), i)
        },
        imageFromGrid: function(t, e, i, s, n, r) {
            return this.imageFromBitmapData(t, this.game.create.grid(t, e, i, s, n, r, !1))
        },
        imageFromTexture: function(t, e, i, s, n) {
            return this.imageFromBitmapData(t, this.game.create.texture(t, e, i, s, n, !1))
        },
        texture: function(e, i, s) {
            if (this.game.renderType === t.WEBGL) {
                var n, r = this.game.renderer.extensions.compression;
                for (n in i) if (n.toUpperCase() in r) return this.addToFileList("texture", e, i[n], void 0, s, ".pvr")
            }
            return i.truecolor && this.addToFileList("image", e, i.truecolor, void 0, s, ".png"),
            this
        },
        images: function(t, e) {
            if (Array.isArray(e)) for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
            else for (var i = 0; i < t.length; i++) this.image(t[i]);
            return this
        },
        text: function(t, e, i) {
            return this.addToFileList("text", t, e, void 0, i, ".txt")
        },
        json: function(t, e, i) {
            return this.addToFileList("json", t, e, void 0, i, ".json")
        },
        shader: function(t, e, i) {
            return this.addToFileList("shader", t, e, void 0, i, ".frag")
        },
        xml: function(t, e, i) {
            return this.addToFileList("xml", t, e, void 0, i, ".xml")
        },
        script: function(t, e, i, s) {
            return void 0 === i && (i = !1),
            !1 !== i && void 0 === s && (s = this),
            this.addToFileList("script", t, e, {
                syncPoint: !0,
                callback: i,
                callbackContext: s
            },
            !1, ".js")
        },
        binary: function(t, e, i, s) {
            return void 0 === i && (i = !1),
            !1 !== i && void 0 === s && (s = i),
            this.addToFileList("binary", t, e, {
                callback: i,
                callbackContext: s
            },
            !1, ".bin")
        },
        spritesheet: function(t, e, i, s, n, r, o, a) {
            return void 0 === n && (n = -1),
            void 0 === r && (r = 0),
            void 0 === o && (o = 0),
            void 0 === a && (a = 0),
            this.addToFileList("spritesheet", t, e, {
                frameWidth: i,
                frameHeight: s,
                frameMax: n,
                margin: r,
                spacing: o,
                skipFrames: a
            },
            !1, ".png")
        },
        audio: function(t, e, i) {
            return this.game.sound.noAudio ? this: (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                buffer: null,
                autoDecode: i
            }))
        },
        audioSprite: function(t, e, i, s, n) {
            return this.game.sound.noAudio ? this: (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
        },
        audiosprite: function(t, e, i, s, n) {
            return this.audioSprite(t, e, i, s, n)
        },
        video: function(t, e, i, s) {
            return void 0 === i && (i = this.game.device.firefox ? "loadeddata": "canplaythrough"),
            void 0 === s && (s = !1),
            "string" == typeof e && (e = [e]),
            this.addToFileList("video", t, e, {
                buffer: null,
                asBlob: s,
                loadEvent: i
            })
        },
        tilemap: function(e, i, s, n) {
            if (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = t.Tilemap.CSV), i || s || (i = n === t.Tilemap.CSV ? e + ".csv": e + ".json"), s) {
                switch (n) {
                case t.Tilemap.CSV:
                    break;
                case t.Tilemap.TILED_JSON:
                    "string" == typeof s && (s = JSON.parse(s))
                }
                this.cache.addTilemap(e, null, s, n)
            } else this.addToFileList("tilemap", e, i, {
                format: n
            });
            return this
        },
        physics: function(e, i, s, n) {
            return void 0 === i && (i = null),
            void 0 === s && (s = null),
            void 0 === n && (n = t.Physics.LIME_CORONA_JSON),
            i || s || (i = e + ".json"),
            s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addPhysicsData(e, null, s, n)) : this.addToFileList("physics", e, i, {
                format: n
            }),
            this
        },
        bitmapFont: function(t, e, i, s, n, r) {
            if (null != e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                atlasURL: i,
                xSpacing: n,
                ySpacing: r
            });
            else if ("string" == typeof s) {
                var o, a;
                try {
                    o = JSON.parse(s)
                } catch(t) {
                    a = this.parseXml(s)
                }
                if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                this.addToFileList("bitmapfont", t, e, {
                    atlasURL: null,
                    atlasData: o || a,
                    atlasType: o ? "json": "xml",
                    xSpacing: n,
                    ySpacing: r
                })
            }
            return this
        },
        atlasJSONArray: function(e, i, s, n) {
            return this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        },
        atlasJSONHash: function(e, i, s, n) {
            return this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_JSON_HASH)
        },
        atlasXML: function(e, i, s, n) {
            return void 0 === s && (s = null),
            void 0 === n && (n = null),
            s || n || (s = e + ".xml"),
            this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_XML_STARLING)
        },
        atlas: function(e, i, s, n, r) {
            if (null != i || (i = e + ".png"), void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = t.Loader.TEXTURE_ATLAS_JSON_ARRAY), s || n || (s = r === t.Loader.TEXTURE_ATLAS_XML_STARLING ? e + ".xml": e + ".json"), s) this.addToFileList("textureatlas", e, i, {
                atlasURL: s,
                format: r
            });
            else {
                switch (r) {
                case t.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    "string" == typeof n && (n = JSON.parse(n));
                    break;
                case t.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if ("string" == typeof n) {
                        var o = this.parseXml(n);
                        if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        n = o
                    }
                }
                this.addToFileList("textureatlas", e, i, {
                    atlasURL: null,
                    atlasData: n,
                    format: r
                })
            }
            return this
        },
        withSyncPoint: function(t, e) {
            this._withSyncPointDepth++;
            try {
                t.call(e || this, this)
            } finally {
                this._withSyncPointDepth--
            }
            return this
        },
        addSyncPoint: function(t, e) {
            var i = this.getAsset(t, e);
            return i && (i.file.syncPoint = !0),
            this
        },
        removeFile: function(t, e) {
            var i = this.getAsset(t, e);
            i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
        },
        removeAll: function() {
            this._fileList.length = 0,
            this._flightQueue.length = 0
        },
        start: function() {
            this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
        },
        processLoadQueue: function() {
            if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"),
            void this.finishedLoading(!0);
            for (i = 0; i < this._flightQueue.length; i++)((s = this._flightQueue[i]).loaded || s.error) && (this._flightQueue.splice(i, 1), i--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)));
            for (var t = !1,
            e = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1, i = this._processingHead; i < this._fileList.length; i++) {
                var s = this._fileList[i];
                if ("packfile" === s.type && !s.error && s.loaded && i === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? i === this._processingHead && (this._processingHead = i + 1) : !s.loading && this._flightQueue.length < e && ("packfile" !== s.type || s.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break
            }
            if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
            else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var n = this;
                setTimeout(function() {
                    n.finishedLoading(!0)
                },
                2e3)
            }
        },
        finishedLoading: function(t) {
            this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.game.state.loadUpdate(), this.onBeforeLoadComplete.dispatch(), this.reset(), this.onLoadComplete.dispatch(), this.game.state && this.game.state.loadComplete())
        },
        asyncComplete: function(t, e) {
            void 0 === e && (e = ""),
            t.loaded = !0,
            t.error = !!e,
            e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)),
            this.processLoadQueue()
        },
        processPack: function(e) {
            var i = e.data[e.key];
            if (i) for (var s = 0; s < i.length; s++) {
                var n = i[s];
                switch (n.type) {
                case "image":
                    this.image(n.key, n.url, n.overwrite);
                    break;
                case "text":
                    this.text(n.key, n.url, n.overwrite);
                    break;
                case "json":
                    this.json(n.key, n.url, n.overwrite);
                    break;
                case "xml":
                    this.xml(n.key, n.url, n.overwrite);
                    break;
                case "script":
                    this.script(n.key, n.url, n.callback, e.callbackContext || this);
                    break;
                case "binary":
                    this.binary(n.key, n.url, n.callback, e.callbackContext || this);
                    break;
                case "spritesheet":
                    this.spritesheet(n.key, n.url, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing, n.skipFrames);
                    break;
                case "video":
                    this.video(n.key, n.urls);
                    break;
                case "audio":
                    this.audio(n.key, n.urls, n.autoDecode);
                    break;
                case "audiosprite":
                    this.audiosprite(n.key, n.urls, n.jsonURL, n.jsonData, n.autoDecode);
                    break;
                case "tilemap":
                    this.tilemap(n.key, n.url, n.data, t.Tilemap[n.format]);
                    break;
                case "physics":
                    this.physics(n.key, n.url, n.data, t.Loader[n.format]);
                    break;
                case "bitmapFont":
                    this.bitmapFont(n.key, n.textureURL, n.atlasURL, n.atlasData, n.xSpacing, n.ySpacing);
                    break;
                case "atlasJSONArray":
                    this.atlasJSONArray(n.key, n.textureURL, n.atlasURL, n.atlasData);
                    break;
                case "atlasJSONHash":
                    this.atlasJSONHash(n.key, n.textureURL, n.atlasURL, n.atlasData);
                    break;
                case "atlasXML":
                    this.atlasXML(n.key, n.textureURL, n.atlasURL, n.atlasData);
                    break;
                case "atlas":
                    this.atlas(n.key, n.textureURL, n.atlasURL, n.atlasData, t.Loader[n.format]);
                    break;
                case "shader":
                    this.shader(n.key, n.url, n.overwrite)
                }
            } else console.warn("Phaser.Loader - " + e.key + ": pack has data, but not for pack key")
        },
        transformUrl: function(t, e) {
            return !! t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t: this.baseURL + e.path + t)
        },
        loadFile: function(e) {
            switch (e.type) {
            case "packfile":
                this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.fileComplete);
                break;
            case "image":
            case "spritesheet":
            case "textureatlas":
            case "bitmapfont":
                this.loadImageTag(e);
                break;
            case "audio":
                e.url = this.getAudioURL(e.url),
                e.url ? this.game.sound.usingWebAudio ? this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(e) : this.fileError(e, null, "No supported audio URL specified or device does not have audio playback support");
                break;
            case "video":
                e.url = this.getVideoURL(e.url),
                e.url ? e.asBlob ? this.xhrLoad(e, this.transformUrl(e.url, e), "blob", this.fileComplete) : this.loadVideoTag(e) : this.fileError(e, null, "No supported video URL specified or device does not have video playback support");
                break;
            case "json":
                this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.jsonLoadComplete);
                break;
            case "xml":
                this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.xmlLoadComplete);
                break;
            case "tilemap":
                e.format === t.Tilemap.TILED_JSON ? this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.jsonLoadComplete) : e.format === t.Tilemap.CSV ? this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.csvLoadComplete) : this.asyncComplete(e, "invalid Tilemap format: " + e.format);
                break;
            case "text":
            case "script":
            case "shader":
            case "physics":
                this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.fileComplete);
                break;
            case "texture":
                "truecolor" === e.key.split("_").pop() ? this.loadImageTag(e) : this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete);
                break;
            case "binary":
                this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete)
            }
        },
        loadImageTag: function(t) {
            var e = this;
            t.data = new Image,
            t.data.name = t.key,
            this.crossOrigin && (t.data.crossOrigin = this.crossOrigin),
            t.data.onload = function() {
                t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
            },
            t.data.onerror = function() {
                t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
            },
            t.data.src = this.transformUrl(t.url, t),
            !this.game.device.firefox && t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
        },
        loadVideoTag: function(e) {
            var i = this;
            e.data = document.createElement("video"),
            e.data.name = e.key,
            e.data.controls = !1,
            e.data.autoplay = !1;
            var s = function() {
                e.data.removeEventListener(e.loadEvent, s, !1),
                e.data.onerror = null,
                e.data.canplay = !0,
                t.GAMES[i.game.id].load.fileComplete(e)
            };
            e.data.onerror = function() {
                e.data.removeEventListener(e.loadEvent, s, !1),
                e.data.onerror = null,
                e.data.canplay = !1,
                i.fileError(e)
            },
            e.data.addEventListener(e.loadEvent, s, !1),
            e.data.src = this.transformUrl(e.url, e),
            e.data.load()
        },
        loadAudioTag: function(t) {
            var e = this;
            if (this.game.sound.touchLocked) t.data = new Audio,
            t.data.name = t.key,
            t.data.preload = "auto",
            t.data.src = this.transformUrl(t.url, t),
            this.fileComplete(t);
            else {
                t.data = new Audio,
                t.data.name = t.key;
                var i = function() {
                    t.data.removeEventListener("canplaythrough", i, !1),
                    t.data.onerror = null,
                    e.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener("canplaythrough", i, !1),
                    t.data.onerror = null,
                    e.fileError(t)
                },
                t.data.preload = "auto",
                t.data.src = this.transformUrl(t.url, t),
                t.data.addEventListener("canplaythrough", i, !1),
                t.data.load()
            }
        },
        xhrLoad: function(t, e, i, s, n) {
            var r = new XMLHttpRequest;
            r.open("GET", e, !0),
            r.responseType = i,
            !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith),
            this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]),
            n = n || this.fileError;
            var o = this;
            r.onload = function() {
                try {
                    return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? n.call(o, t, r) : s.call(o, t, r)
                } catch(e) {
                    o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                }
            },
            r.onerror = function() {
                try {
                    return n.call(o, t, r)
                } catch(e) {
                    o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                }
            },
            t.requestObject = r,
            t.requestUrl = e,
            r.send()
        },
        getVideoURL: function(t) {
            for (var e = 0; e < t.length; e++) {
                var i, s = t[e];
                if (s.uri) {
                    if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                } else {
                    if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                    if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                }
            }
            return null
        },
        getAudioURL: function(t) {
            if (this.game.sound.noAudio) return null;
            for (var e = 0; e < t.length; e++) {
                var i, s = t[e];
                if (s.uri) {
                    if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                } else {
                    if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                    if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                }
            }
            return null
        },
        fileError: function(t, e, i) {
            var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t)); ! i && e && (i = e.status),
            i && (s = s + " (" + i + ")"),
            this.asyncComplete(t, s)
        },
        fileComplete: function(e, i) {
            var s = !0;
            switch (e.type) {
            case "packfile":
                r = JSON.parse(i.responseText),
                e.data = r || {};
                break;
            case "texture":
                var n = /\.([^.]+)$/.exec(e.url.split("?", 1)[0])[1].toLowerCase();
                null !== e.data ? this.cache.addCompressedTextureMetaData(e.key, e.url, n, e.data) : this.cache.addCompressedTextureMetaData(e.key, e.url, n, i.response);
                break;
            case "image":
                this.cache.addImage(e.key, e.url, e.data);
                break;
            case "spritesheet":
                this.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing, e.skipFrames);
                break;
            case "textureatlas":
                if (null == e.atlasURL) this.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format);
                else if (s = !1, e.format === t.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format === t.Loader.TEXTURE_ATLAS_JSON_HASH || e.format === t.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.jsonLoadComplete);
                else {
                    if (e.format !== t.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                    this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.xmlLoadComplete)
                }
                break;
            case "bitmapfont":
                e.atlasURL ? (s = !1, this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text",
                function(t, e) {
                    var i;
                    try {
                        i = JSON.parse(e.responseText)
                    } catch(t) {}
                    i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                })) : this.cache.addBitmapFont(e.key, e.url, e.data, e.atlasData, e.atlasType, e.xSpacing, e.ySpacing);
                break;
            case "video":
                if (e.asBlob) try {
                    e.data = i.response
                } catch(t) {
                    throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + e.key)
                }
                this.cache.addVideo(e.key, e.url, e.data, e.asBlob);
                break;
            case "audio":
                this.game.sound.usingWebAudio ? (e.data = i.response, this.cache.addSound(e.key, e.url, e.data, !0, !1), e.autoDecode && this.game.sound.decode(e.key)) : this.cache.addSound(e.key, e.url, e.data, !1, !0);
                break;
            case "text":
                e.data = i.responseText,
                this.cache.addText(e.key, e.url, e.data);
                break;
            case "shader":
                e.data = i.responseText,
                this.cache.addShader(e.key, e.url, e.data);
                break;
            case "physics":
                var r = JSON.parse(i.responseText);
                this.cache.addPhysicsData(e.key, e.url, r, e.format);
                break;
            case "script":
                e.data = document.createElement("script"),
                e.data.language = "javascript",
                e.data.type = "text/javascript",
                e.data.defer = !1,
                e.data.text = i.responseText,
                document.head.appendChild(e.data),
                e.callback && (e.data = e.callback.call(e.callbackContext, e.key, i.responseText));
                break;
            case "binary":
                e.callback ? e.data = e.callback.call(e.callbackContext, e.key, i.response) : e.data = i.response,
                this.cache.addBinary(e.key, e.data)
            }
            s && this.asyncComplete(e)
        },
        jsonLoadComplete: function(t, e) {
            var i = JSON.parse(e.responseText);
            "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format),
            this.asyncComplete(t)
        },
        csvLoadComplete: function(t, e) {
            var i = e.responseText;
            this.cache.addTilemap(t.key, t.url, i, t.format),
            this.asyncComplete(t)
        },
        xmlLoadComplete: function(t, e) {
            var i = e.responseText,
            s = this.parseXml(i);
            if (!s) {
                var n = e.responseType || e.contentType;
                return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"),
                void this.asyncComplete(t, "invalid XML")
            }
            "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s),
            this.asyncComplete(t)
        },
        parseXml: function(t) {
            var e;
            try {
                if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml");
                else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false",
                e.loadXML(t)
            } catch(t) {
                e = null
            }
            return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e: null
        },
        updateProgress: function() {
            this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
        },
        totalLoadedFiles: function() {
            return this._loadedFileCount
        },
        totalQueuedFiles: function() {
            return this._totalFileCount - this._loadedFileCount
        },
        totalLoadedPacks: function() {
            return this._totalPackCount
        },
        totalQueuedPacks: function() {
            return this._totalPackCount - this._loadedPackCount
        }
    },
    Object.defineProperty(t.Loader.prototype, "progressFloat", {
        get: function() {
            var e = this._loadedFileCount / this._totalFileCount * 100;
            return t.Math.clamp(e || 0, 0, 100)
        }
    }),
    Object.defineProperty(t.Loader.prototype, "progress", {
        get: function() {
            return Math.round(this.progressFloat)
        }
    }),
    t.Loader.prototype.constructor = t.Loader,
    t.LoaderParser = {
        bitmapFont: function(t, e, i, s, n, r) {
            return this.xmlBitmapFont(t, e, i, s, n, r)
        },
        xmlBitmapFont: function(t, e, i, s, n, r) {
            null == r && (r = 1);
            var o = {},
            a = t.getElementsByTagName("info")[0],
            h = t.getElementsByTagName("common")[0];
            o.font = a.getAttribute("face"),
            o.size = parseInt(a.getAttribute("size"), 10),
            o.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s,
            o.chars = {};
            for (var l = t.getElementsByTagName("char"), c = n ? n.x: 0, u = n ? n.y: 0, d = 0; d < l.length; d++) {
                var p = parseInt(l[d].getAttribute("id"), 10),
                f = o.chars[p] = {
                    x: parseInt(l[d].getAttribute("x"), 10),
                    y: parseInt(l[d].getAttribute("y"), 10),
                    width: parseInt(l[d].getAttribute("width"), 10),
                    height: parseInt(l[d].getAttribute("height"), 10),
                    xOffset: parseInt(l[d].getAttribute("xoffset"), 10) / r,
                    yOffset: parseInt(l[d].getAttribute("yoffset"), 10) / r,
                    xAdvance: (parseInt(l[d].getAttribute("xadvance"), 10) + i) / r,
                    kerning: {}
                };
                if (n && n.trimmed && (f.x + f.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (f.width -= f.x + f.width - n.spriteSourceSizeX - n.spriteSourceSizeW), f.y + f.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (f.height -= f.y + f.height - n.spriteSourceSizeY - n.spriteSourceSizeH), f.x < n.spriteSourceSizeX && (g = n.spriteSourceSizeX - f.x, f.x = 0, f.width -= g, f.xOffset += g), f.y < n.spriteSourceSizeY)) {
                    var g = n.spriteSourceSizeY - f.y;
                    f.y = 0,
                    f.height -= g,
                    f.yOffset += g
                }
                f.x += c,
                f.y += u
            }
            var m = t.getElementsByTagName("kerning");
            for (d = 0; d < m.length; d++) {
                var y = parseInt(m[d].getAttribute("first"), 10),
                v = parseInt(m[d].getAttribute("second"), 10),
                x = parseInt(m[d].getAttribute("amount"), 10) / r;
                o.chars[v] && (o.chars[v].kerning[y] = x)
            }
            return this.finalizeBitmapFont(e, o)
        },
        jsonBitmapFont: function(t, e, i, s, n, r) {
            null == r && (r = 1);
            var o = {
                font: t.font.info._face,
                size: parseInt(t.font.info._size, 10),
                lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                chars: {}
            },
            a = n ? n.x: 0,
            h = n ? n.y: 0;
            return t.font.chars.char.forEach(function(t) {
                var e = parseInt(t._id, 10),
                s = o.chars[e] = {
                    x: parseInt(t._x, 10),
                    y: parseInt(t._y, 10),
                    width: parseInt(t._width, 10),
                    height: parseInt(t._height, 10),
                    xOffset: parseInt(t._xoffset, 10) / r,
                    yOffset: parseInt(t._yoffset, 10) / r,
                    xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                    kerning: {}
                };
                if (n && n.trimmed && (s.x + s.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (s.width -= s.x + s.width - n.spriteSourceSizeX - n.spriteSourceSizeW), s.y + s.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (s.height -= s.y + s.height - n.spriteSourceSizeY - n.spriteSourceSizeH), s.x < n.spriteSourceSizeX && (l = n.spriteSourceSizeX - s.x, s.x = 0, s.width -= l, s.xOffset += l), s.y < n.spriteSourceSizeY)) {
                    var l = n.spriteSourceSizeY - s.y;
                    s.y = 0,
                    s.height -= l,
                    s.yOffset += l
                }
                s.x += a,
                s.y += h
            }),
            t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                o.chars[t._second] && (o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r)
            }),
            this.finalizeBitmapFont(e, o)
        },
        finalizeBitmapFont: function(e, i) {
            return Object.keys(i.chars).forEach(function(s) {
                var n = i.chars[s];
                n.texture = new PIXI.Texture(e, new t.Rectangle(n.x, n.y, n.width, n.height))
            }),
            i
        },
        pvr: function(t) {
            var e, i = new Uint32Array(t.slice(0, 52)),
            s = new Uint8Array(t),
            n = null,
            r = i[3] << 32 | i[2],
            o = 0;
            if (55727696 === i[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r) >= 0) {
                switch (r >= 0 && r <= 3 ? e = "PVRTC": r >= 7 && r <= 11 ? e = "S3TC": 6 === r && (e = "ETC1"), r) {
                case 0:
                    o = 35841;
                    break;
                case 1:
                    o = 35843;
                    break;
                case 2:
                    o = 35840;
                    break;
                case 3:
                    o = 35842;
                    break;
                case 6:
                    o = 36196;
                    break;
                case 7:
                    o = 33777;
                    break;
                case 9:
                    o = 33778;
                    break;
                case 11:
                    o = 33779;
                    break;
                default:
                    o = -1
                }
                n = {
                    complete: !0,
                    fileFormat: "PVR",
                    compressionAlgorithm: e,
                    flags: i[1],
                    pixelFormat: r,
                    colorSpace: i[4],
                    channelType: i[5],
                    height: i[6],
                    width: i[7],
                    depth: i[8],
                    numberOfSurfaces: i[9],
                    numberOfFaces: i[10],
                    numberOfMipmaps: i[11],
                    metaDataSize: i[12],
                    textureData: s.subarray(52 + i[12], s.byteLength),
                    glExtensionFormat: o
                }
            }
            return n
        },
        dds: function(t) {
            var e = new Uint8Array(t),
            i = new Uint32Array(t),
            s = null;
            return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && ("DX10" === (s = {
                complete: !0,
                fileFormat: "DDS",
                compressionAlgorithm: "S3TC",
                size: i[1],
                flags: i[2],
                height: i[3],
                width: i[4],
                pitch: i[5],
                depth: i[6],
                mipmapCount: i[7],
                formatSize: i[19],
                formatFlag: i[19],
                formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                formatBitCount: i[21],
                formatRBitMask: i[22],
                formatGBitMask: i[23],
                formatBBitMask: i[24],
                formatABitMask: i[25],
                caps1: i[26],
                caps2: i[27],
                caps3: i[28],
                caps4: i[29],
                reserved2: i[30],
                DXGIFormat: null,
                resourceDimension: null,
                miscFlag: null,
                arraySize: null,
                textureData: e.subarray(i[1] + 4, e.byteLength)
            }).formatFourCC ? (s.DXGIFormat = i[31], s.resourceDimension = i[32], s.miscFlag = i[33], s.arraySize = i[34], s.miscFlag = i[35]) : "DXT5" === s.formatFourCC ? s.glExtensionFormat = 33779 : "DXT3" === s.formatFourCC && (s.glExtensionFormat = 33778)),
            s
        },
        ktx: function(t) {
            var e = new Uint8Array(t),
            i = new Uint32Array(t),
            s = null,
            n = 16 + i[15] / 4 | 0,
            r = i[n],
            o = i[7],
            a = 0;
            if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(o) >= 0) {
                switch (o) {
                case 36196:
                    a = "ETC1";
                    break;
                case 35840:
                case 35841:
                case 35842:
                case 35843:
                    a = "PVRTC";
                    break;
                case 33776:
                case 33777:
                case 33778:
                case 33779:
                    a = "S3TC"
                }
                s = {
                    complete: !0,
                    fileFormat: "KTX",
                    compressionAlgorithm: a,
                    endianness: i[3],
                    glType: i[4],
                    glTypeSize: i[5],
                    glFormat: i[6],
                    glInternalFormat: i[7],
                    glBaseInternalFormat: i[8],
                    width: i[9],
                    height: i[10],
                    pixelDepth: i[11],
                    numberOfArrayElements: i[12],
                    numberOfFaces: i[13],
                    numberOfMipmapLevels: i[14],
                    bytesOfKeyValueData: i[15],
                    keyAndValueByteSize: i[16],
                    imageSize: r,
                    textureData: e.subarray(4 * (n + 1), r + 100)
                }
            }
            return s
        },
        pkm: function(t) {
            var e = new Uint8Array(t),
            i = null;
            return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                complete: !0,
                fileFormat: "PKM",
                compressionAlgorithm: "ETC1",
                format: 65535 & (e[6] << 8 | e[7]),
                width: 65535 & (e[8] << 8 | e[9]),
                height: 65535 & (e[10] << 8 | e[11]),
                originalWidth: 65535 & (e[12] << 8 | e[13]),
                originalHeight: 65535 & (e[14] << 8 | e[15]),
                textureData: e.subarray(16, e.length)
            }),
            i
        }
    },
    t.AudioSprite = function(t, e) {
        for (var i in this.game = t,
        this.key = e,
        this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {},
        this.config.spritemap) {
            var s = this.config.spritemap[i],
            n = this.game.add.sound(this.key);
            n.addMarker(i, s.start, s.end - s.start, null, s.loop),
            this.sounds[i] = n
        }
        this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
    },
    t.AudioSprite.prototype = {
        play: function(t, e) {
            return void 0 === e && (e = 1),
            this.sounds[t].play(t, null, e)
        },
        stop: function(t) {
            if (t) this.sounds[t].stop();
            else for (var e in this.sounds) this.sounds[e].stop()
        },
        get: function(t) {
            return this.sounds[t]
        }
    },
    t.AudioSprite.prototype.constructor = t.AudioSprite,
    t.Sound = function(e, i, s, n, r) {
        void 0 === s && (s = 1),
        void 0 === n && (n = !1),
        void 0 === r && (r = e.sound.connectToMaster),
        this.game = e,
        this.name = i,
        this.key = i,
        this.loop = n,
        this.markers = {},
        this.context = null,
        this.autoplay = !1,
        this.totalDuration = 0,
        this.startTime = 0,
        this.currentTime = 0,
        this.duration = 0,
        this.durationMS = 0,
        this.position = 0,
        this.stopTime = 0,
        this.paused = !1,
        this.pausedPosition = 0,
        this.pausedTime = 0,
        this.isPlaying = !1,
        this.currentMarker = "",
        this.fadeTween = null,
        this.pendingPlayback = !1,
        this.override = !1,
        this.allowMultiple = !1,
        this.playOnce = !1,
        this.usingWebAudio = this.game.sound.usingWebAudio,
        this.usingAudioTag = this.game.sound.usingAudioTag,
        this.externalNode = null,
        this.masterGainNode = null,
        this.gainNode = null,
        this._sound = null,
        this._globalVolume = 1,
        this._markedToDelete = !1,
        this._removeFromSoundManager = !1,
        this._sourceId = 0,
        this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = s, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(i) && this.game.cache.isSoundReady(i) ? (this._sound = this.game.cache.getSoundData(i), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)),
        this.onDecoded = new t.Signal,
        this.onPlay = new t.Signal,
        this.onPause = new t.Signal,
        this.onResume = new t.Signal,
        this.onLoop = new t.Signal,
        this.onStop = new t.Signal,
        this.onMute = new t.Signal,
        this.onMarkerComplete = new t.Signal,
        this.onFadeComplete = new t.Signal,
        this._volume = s,
        this._buffer = null,
        this._muted = !1,
        this._tempMarker = 0,
        this._tempPosition = 0,
        this._tempVolume = 0,
        this._tempPause = 0,
        this._muteVolume = 0,
        this._tempLoop = 0,
        this._paused = !1,
        this._onDecodedEventDispatched = !1
    },
    t.Sound.prototype = {
        soundHasUnlocked: function(t) {
            t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
        },
        addMarker: function(t, e, i, s, n) {
            null != i || (i = 1),
            null != s || (s = 1),
            void 0 === n && (n = !1),
            this.markers[t] = {
                name: t,
                start: e,
                stop: e + i,
                volume: s,
                duration: i,
                durationMS: 1e3 * i,
                loop: n
            }
        },
        removeMarker: function(t) {
            delete this.markers[t]
        },
        onEndedHandler: function() {
            this._removeOnEndedHandler(),
            this.isPlaying = !1,
            this.currentTime = this.durationMS,
            this.stop(),
            this.playOnce && (this._markedToDelete = !0, this._removeFromSoundManager = !0),
            this._markedToDelete && (this._disconnectSource(), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {},
            this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()))
        },
        update: function() {
            this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
        },
        loopFull: function(t) {
            return this.play(null, 0, t, !0)
        },
        play: function(t, e, i, s, n) {
            if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n) && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0), this.isPlaying = !1), "" === t && Object.keys(this.markers).length > 0) return this;
            if ("" !== t) {
                if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"),
                this;
                this.currentMarker = t,
                this.position = this.markers[t].start,
                this.volume = this.markers[t].volume,
                this.loop = this.markers[t].loop,
                this.duration = this.markers[t].duration,
                this.durationMS = this.markers[t].durationMS,
                void 0 !== i && (this.volume = i),
                void 0 !== s && (this.loop = s),
                this._tempMarker = t,
                this._tempPosition = this.position,
                this._tempVolume = this.volume,
                this._tempLoop = this.loop
            } else e = e || 0,
            void 0 === i && (i = this._volume),
            void 0 === s && (s = this.loop),
            this.position = Math.max(0, e),
            this.volume = i,
            this.loop = s,
            this.duration = 0,
            this.durationMS = 0,
            this._tempMarker = t,
            this._tempPosition = e,
            this._tempVolume = i,
            this._tempLoop = s;
            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._createSourceAndConnect(), this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || this._addOnEndedHandler(), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), this.loop && "" === t ? this._startSource(0, 0) : this._startSource(0, this.position, this.duration), this.isPlaying = !0, this.paused = !1, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this._sound.loop = this.loop, this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._globalVolume = this.game.sound.volume, this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume * this._globalVolume, this.isPlaying = !0, this.paused = !1, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0,
            this.playOnce && (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = !0, this._removeFromSoundManager = !0),
            this
        },
        restart: function(t, e, i, s) {
            t = t || "",
            e = e || 0,
            i = i || 1,
            void 0 === s && (s = !1),
            this.play(t, e, i, s, !0)
        },
        pause: function() {
            this.isPlaying && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
        },
        resume: function() {
            if (this.paused) {
                if (this.usingWebAudio) {
                    var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                    this._createSourceAndConnect(),
                    "" === this.currentMarker && (this.loop ? this._sound.loop = !0 : this._addOnEndedHandler());
                    var e = this.duration - this.pausedPosition / 1e3;
                    this.loop && "" === this.currentMarker ? this._startSource(0, t) : this._startSource(0, t, e)
                } else this._sound.currentTime = this._tempPause,
                this._sound.play();
                this.isPlaying = !0,
                this.paused = !1,
                this.startTime += this.game.time.time - this.pausedTime,
                this.onResume.dispatch(this)
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0)), this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                var t = this.currentMarker;
                "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this),
                this.currentMarker = "",
                null !== this.fadeTween && this.fadeTween.stop(),
                this.onStop.dispatch(this, t)
            }
        },
        fadeIn: function(t, e, i) {
            void 0 === e && (e = !1),
            void 0 === i && (i = this.currentMarker),
            this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
        },
        fadeOut: function(t) {
            this.fadeTo(t, 0)
        },
        fadeTo: function(e, i) {
            this.isPlaying && !this.paused && i !== this.volume && (void 0 === e && (e = 1e3), void 0 !== i ? (this.fadeTween = this.game.add.tween(this).to({
                volume: i
            },
            e, t.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
        },
        fadeComplete: function() {
            this.onFadeComplete.dispatch(this, this.volume),
            0 === this.volume && this.stop()
        },
        updateGlobalVolume: function(t) {
            this.usingAudioTag && this._sound && (this._globalVolume = t, this._sound.volume = this._globalVolume * this._volume)
        },
        destroy: function(t) {
            void 0 === t && (t = !0),
            this._markedToDelete = !0,
            this._removeFromSoundManager = t,
            this.stop(),
            t ? this.game.sound.remove(this) : (this.markers = {},
            this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
        },
        _createSourceAndConnect: function() {
            this._sound = this.context.createBufferSource(),
            this._sound.connect(this.externalNode || this.gainNode),
            this._buffer = this.game.cache.getSoundData(this.key),
            this._sound.buffer = this._buffer,
            this._sourceId++
        },
        _disconnectSource: function() {
            this._sound.disconnect(this.externalNode || this.gainNode)
        },
        _startSource: function(t, e, i) {
            this._sound.start(t || 0, e || 0, i)
        },
        _stopSourceAndDisconnect: function() {
            this._removeOnEndedHandler();
            try {
                this._sound.stop(0)
            } catch(t) {}
            this._disconnectSource(),
            this._sound = null
        },
        _addOnEndedHandler: function() {
            this._sound.onended = this.onEndedHandler.bind(this)
        },
        _removeOnEndedHandler: function() {
            this._sound.onended = null
        }
    },
    t.Sound.prototype.constructor = t.Sound,
    Object.defineProperty(t.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding
        }
    }),
    Object.defineProperty(t.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key)
        }
    }),
    Object.defineProperty(t.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute
        },
        set: function(t) { (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume: this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
        }
    }),
    Object.defineProperty(t.Sound.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(t) {
            this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)),
            this._muted ? this._muteVolume = t: (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t: this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * t))
        }
    }),
    Object.defineProperty(t.Sound.prototype, "sourceId", {
        get: function() {
            return this._sound ? this._sourceId: null
        }
    }),
    t.SoundManager = function(e) {
        this.game = e,
        this.onSoundDecode = new t.Signal,
        this.onVolumeChange = new t.Signal,
        this.onMute = new t.Signal,
        this.onUnMute = new t.Signal,
        this.onTouchUnlock = new t.Signal,
        this.context = null,
        this.baseLatency = null,
        this.usingWebAudio = !1,
        this.usingAudioTag = !1,
        this.noAudio = !1,
        this.connectToMaster = !0,
        this.touchLocked = !1,
        this.channels = 32,
        this.muteOnPause = !0,
        this._codeMuted = !1,
        this._muted = !1,
        this._unlockSource = null,
        this._volume = 1,
        this._sounds = [],
        this._watchList = new t.ArraySet,
        this._watching = !1,
        this._watchCallback = null,
        this._watchContext = null,
        this._resumeWebAudioOnClick = this._resumeWebAudioOnClick.bind(this)
    },
    t.SoundManager.prototype = {
        boot: function() {
            var t = this.game.device,
            e = window.PhaserGlobal;
            if (t.iOS && !1 === t.webAudio && (this.channels = 1), e) {
                if (!0 === e.disableAudio) return this.noAudio = !0,
                void(this.touchLocked = !1);
                if (!0 === e.disableWebAudio) return this.usingAudioTag = !0,
                void(this.touchLocked = !1)
            }
            if (e && e.audioContext) this.context = e.audioContext;
            else {
                var i = window.AudioContext || window.webkitAudioContext;
                if (i) try {
                    this.context = new i
                } catch(t) {
                    this.context = null,
                    this.usingWebAudio = !1,
                    this.touchLocked = !1,
                    console.warn(t)
                }
            }
            if (null === this.context) {
                if (void 0 === window.Audio) return void(this.noAudio = !0);
                this.usingAudioTag = !0
            } else this.usingWebAudio = !0,
            this.baseLatency = this.context.baseLatency || 256 / (this.context.sampleRate || 44100),
            void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(),
            this.masterGain.gain.value = 1,
            this.masterGain.connect(this.context.destination),
            "suspended" === this.context.state && this.game.canvas.addEventListener("click", this._resumeWebAudioOnClick);
            this.noAudio || t.needsTouchUnlock() && this.setTouchLock(),
            this.usingWebAudio && t.chrome && t.chromeVersion <= 65 && console.log('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>')
        },
        setTouchLock: function() {
            this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0)
        },
        setTouchUnlock: function() {
            this.touchLocked = !1,
            this._unlockSource = null,
            this.onTouchUnlock.dispatch()
        },
        resumeWebAudio: function() {
            if (this.usingWebAudio && "suspended" === this.context.state) return this.context.resume()
        },
        unlock: function() {
            if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return ! 0;
            if (this.usingAudioTag) this.setTouchUnlock();
            else if (this.usingWebAudio) {
                var t = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource(),
                this._unlockSource.buffer = t,
                this._unlockSource.connect(this.context.destination);
                var e = this;
                this._unlockSource.onended = function() {
                    e.setTouchUnlock(),
                    e.resumeWebAudio()
                },
                void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0),
                this.resumeWebAudio()
            }
            return ! 0
        },
        stopAll: function() {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
        },
        pauseAll: function() {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
        },
        resumeAll: function() {
            if (!this.noAudio) for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
        },
        decode: function(t, e) {
            e = e || null;
            var i = this.game.cache.getSoundData(t);
            if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                this.game.cache.updateSound(t, "isDecoding", !0);
                var s = this;
                try {
                    this.context.decodeAudioData(i,
                    function(i) {
                        i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                    })
                } catch(t) {}
            }
        },
        setDecodedCallback: function(e, i, s) {
            "string" == typeof e && (e = [e]),
            this._watchList.reset();
            for (var n = 0; n < e.length; n++) e[n] instanceof t.Sound ? this.game.cache.isSoundDecoded(e[n].key) || this._watchList.add(e[n].key) : this.game.cache.isSoundDecoded(e[n]) || this._watchList.add(e[n]);
            0 === this._watchList.total ? (this._watching = !1, i.call(s)) : (this._watching = !0, this._watchCallback = i, this._watchContext = s)
        },
        update: function() {
            if (!this.noAudio) {
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                if (this._watching) {
                    for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e),
                    e = this._watchList.next;
                    0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                }
            }
        },
        add: function(e, i, s, n) {
            void 0 === i && (i = 1),
            void 0 === s && (s = !1),
            void 0 === n && (n = this.connectToMaster);
            var r = new t.Sound(this.game, e, i, s, n);
            return this._sounds.push(r),
            r
        },
        addSprite: function(e) {
            return new t.AudioSprite(this.game, e)
        },
        remove: function(t) {
            for (var e = this._sounds.length; e--;) if (this._sounds[e] === t) return this._sounds[e].destroy(!1),
            this._sounds.splice(e, 1),
            !0;
            return ! 1
        },
        removeAll: function() {
            this.stopAll();
            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
            this._sounds.length = 0
        },
        removeByKey: function(t) {
            for (var e = this._sounds.length,
            i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
            return i
        },
        play: function(t, e, i) {
            if (!this.noAudio) {
                var s = this.add(t, e, i);
                return s.play(),
                s
            }
        },
        setMute: function() {
            if (!this._muted) {
                this._muted = !0,
                this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                this.onMute.dispatch()
            }
        },
        unsetMute: function() {
            if (this._muted && !this._codeMuted) {
                this._muted = !1,
                this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                this.onUnMute.dispatch()
            }
        },
        destroy: function() {
            this.removeAll(),
            this.onSoundDecode.dispose(),
            this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick),
            this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context: this.context.close && this.context.close())
        },
        _resumeWebAudioOnClick: function() {
            this.resumeWebAudio(),
            this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick)
        }
    },
    t.SoundManager.prototype.constructor = t.SoundManager,
    Object.defineProperty(t.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(t) {
            if (t = t || !1) {
                if (this._muted) return;
                this._codeMuted = !0,
                this.setMute()
            } else {
                if (!this._muted) return;
                this._codeMuted = !1,
                this.unsetMute()
            }
        }
    }),
    Object.defineProperty(t.SoundManager.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(t) {
            if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                else for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                this.onVolumeChange.dispatch(t)
            }
        }
    }),
    t.ScaleManager = function(e, i, s) {
        this.game = e,
        this.dom = t.DOM,
        this.grid = null,
        this.width = 0,
        this.height = 0,
        this.minWidth = null,
        this.maxWidth = null,
        this.minHeight = null,
        this.maxHeight = null,
        this.offset = new t.Point,
        this.forceLandscape = !1,
        this.forcePortrait = !1,
        this.incorrectOrientation = !1,
        this._pageAlignHorizontally = !1,
        this._pageAlignVertically = !1,
        this.onOrientationChange = new t.Signal,
        this.enterIncorrectOrientation = new t.Signal,
        this.leaveIncorrectOrientation = new t.Signal,
        this.hasPhaserSetFullScreen = !1,
        this.fullScreenTarget = null,
        this._createdFullScreenTarget = null,
        this.onFullScreenInit = new t.Signal,
        this.onFullScreenChange = new t.Signal,
        this.onFullScreenError = new t.Signal,
        this.screenOrientation = this.dom.getScreenOrientation(),
        this.scaleFactor = new t.Point(1, 1),
        this.scaleFactorInversed = new t.Point(1, 1),
        this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        },
        this.bounds = new t.Rectangle,
        this.aspectRatio = 0,
        this.sourceAspectRatio = 0,
        this.event = null,
        this.windowConstraints = {
            right: "layout",
            bottom: ""
        },
        this.compatibility = {
            supportsFullScreen: !1,
            orientationFallback: null,
            noMargins: !1,
            scrollTo: null,
            forceMinimumDocumentHeight: !1,
            canExpandParent: !0,
            clickTrampoline: ""
        },
        this._scaleMode = t.ScaleManager.NO_SCALE,
        this._fullScreenScaleMode = t.ScaleManager.NO_SCALE,
        this.parentIsWindow = !1,
        this.parentNode = null,
        this.parentScaleFactor = new t.Point(1, 1),
        this.trackParentInterval = 2e3,
        this.onSizeChange = new t.Signal,
        this.onResize = null,
        this.onResizeContext = null,
        this._pendingScaleMode = null,
        this._fullScreenRestore = null,
        this._gameSize = new t.Rectangle,
        this._userScaleFactor = new t.Point(1, 1),
        this._userScaleTrim = new t.Point(0, 0),
        this._lastUpdate = 0,
        this._updateThrottle = 0,
        this._updateThrottleReset = 100,
        this._parentBounds = new t.Rectangle,
        this._tempBounds = new t.Rectangle,
        this._lastReportedCanvasSize = new t.Rectangle,
        this._lastReportedGameSize = new t.Rectangle,
        this._booted = !1,
        e.config && this.parseConfig(e.config),
        this.setupScale(i, s)
    },
    t.ScaleManager.EXACT_FIT = 0,
    t.ScaleManager.NO_SCALE = 1,
    t.ScaleManager.SHOW_ALL = 2,
    t.ScaleManager.RESIZE = 3,
    t.ScaleManager.USER_SCALE = 4,
    t.ScaleManager.MODES = ["EXACT_FIT", "NO_SCALE", "SHOW_ALL", "RESIZE", "USER_SCALE"],
    t.ScaleManager.prototype = {
        boot: function() {
            var e = this.compatibility;
            e.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS,
            this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? e.scrollTo = new t.Point(0, 1) : e.scrollTo = new t.Point(0, 0)),
            this.game.device.desktop ? (e.orientationFallback = "screen", e.clickTrampoline = "when-not-mouse") : (e.orientationFallback = "", e.clickTrampoline = "");
            var i = this;
            this._orientationChange = function(t) {
                return i.orientationChange(t)
            },
            this._windowResize = function(t) {
                return i.windowResize(t)
            },
            window.addEventListener("orientationchange", this._orientationChange, !1),
            window.addEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                return i.fullScreenChange(t)
            },
            this._fullScreenError = function(t) {
                return i.fullScreenError(t)
            },
            document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)),
            this.game.onResume.add(this._gameResumed, this),
            this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.setGameSize(this.game.width, this.game.height),
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
            t.FlexGrid && (this.grid = new t.FlexGrid(this, this.width, this.height)),
            this._booted = !0,
            null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
        },
        parseConfig: function(t) {
            void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode: this._pendingScaleMode = t.scaleMode),
            void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode),
            t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget),
            this.pageAlignHorizontally = t.alignH || !1,
            this.pageAlignVertically = t.alignV || !1,
            t.scaleH && t.scaleV && this.setUserScale(t.scaleH, t.scaleV, t.trimH, t.trimV)
        },
        setupScale: function(e, i) {
            var s, n = new t.Rectangle;
            "" !== this.game.parent && ("string" == typeof this.game.parent ? s = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (s = this.game.parent)),
            s ? (this.parentNode = s, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds, this.parentNode), n.width = this._parentBounds.width, n.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, n.width = this.dom.visualBounds.width, n.height = this.dom.visualBounds.height, this.offset.set(0, 0));
            var r = 0,
            o = 0;
            "number" == typeof e ? r = e: (this.parentScaleFactor.x = parseInt(e, 10) / 100, r = n.width * this.parentScaleFactor.x),
            "number" == typeof i ? o = i: (this.parentScaleFactor.y = parseInt(i, 10) / 100, o = n.height * this.parentScaleFactor.y),
            r = Math.floor(r),
            o = Math.floor(o),
            this._gameSize.setTo(0, 0, r, o),
            this.updateDimensions(r, o, !1)
        },
        _gameResumed: function() {
            this.queueUpdate(!0)
        },
        setGameSize: function(e, i) {
            this._gameSize.setTo(0, 0, e, i),
            this.currentScaleMode !== t.ScaleManager.RESIZE && this.updateDimensions(e, i, !0),
            this.queueUpdate(!0)
        },
        setUserScale: function(t, e, i, s, n, r) {
            this._userScaleFactor.setTo(t, e),
            this._userScaleTrim.setTo(0 | i, 0 | s),
            void 0 === n && (n = !0),
            void 0 === r && (r = !0),
            n && this.queueUpdate(r)
        },
        setResizeCallback: function(t, e) {
            this.onResize = t,
            this.onResizeContext = e
        },
        signalSizeChange: function() {
            if (!t.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !t.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var e = this.width,
                i = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, e, i),
                this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height),
                this.grid && this.grid.onResize(e, i),
                this.onSizeChange.dispatch(this, e, i),
                this.currentScaleMode === t.ScaleManager.RESIZE && (this.game.state.resize(e, i), this.game.load.resize(e, i))
            }
        },
        setMinMax: function(t, e, i, s) {
            this.minWidth = t,
            this.minHeight = e,
            void 0 !== i && (this.maxWidth = i),
            void 0 !== s && (this.maxHeight = s)
        },
        preUpdate: function() {
            if (! (this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                var e = this._updateThrottle;
                this._updateThrottleReset = e >= 400 ? 0 : 100,
                this.dom.getOffset(this.game.canvas, this.offset);
                var i = this._parentBounds.width,
                s = this._parentBounds.height,
                n = this.getParentBounds(this._parentBounds),
                r = n.width !== i || n.height !== s,
                o = this.updateOrientationState(); (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, n), this.updateLayout(), this.signalSizeChange());
                var a = 2 * this._updateThrottle;
                this._updateThrottle < e && (a = Math.min(e, this._updateThrottleReset)),
                this._updateThrottle = t.Math.clamp(a, 25, this.trackParentInterval),
                this._lastUpdate = this.game.time.time
            }
        },
        pauseUpdate: function() {
            this.preUpdate(),
            this._updateThrottle = this.trackParentInterval
        },
        updateDimensions: function(t, e, i) {
            this.width = t * this.parentScaleFactor.x,
            this.height = e * this.parentScaleFactor.y,
            this.game.width = this.width,
            this.game.height = this.height,
            this.sourceAspectRatio = this.width / this.height,
            this.updateScalingAndBounds(),
            i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
        },
        updateScalingAndBounds: function() {
            this.scaleFactor.x = this.game.width / this.width,
            this.scaleFactor.y = this.game.height / this.height,
            this.scaleFactorInversed.x = this.width / this.game.width,
            this.scaleFactorInversed.y = this.height / this.game.height,
            this.aspectRatio = this.width / this.height,
            this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
        },
        forceOrientation: function(t, e) {
            void 0 === e && (e = !1),
            !0 !== t || !0 !== e ? (this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)) : console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.")
        },
        classifyOrientation: function(t) {
            return "portrait-primary" === t || "portrait-secondary" === t ? "portrait": "landscape-primary" === t || "landscape-secondary" === t ? "landscape": null
        },
        updateOrientationState: function() {
            var t = this.screenOrientation,
            e = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
            this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var i = t !== this.screenOrientation,
            s = e !== this.incorrectOrientation;
            return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()),
            (i || s) && this.onOrientationChange.dispatch(this, t, e),
            i || s
        },
        orientationChange: function(t) {
            this.event = t,
            this.queueUpdate(!0)
        },
        windowResize: function(t) {
            this.event = t,
            this.queueUpdate(!0)
        },
        scrollTop: function() {
            var t = this.compatibility.scrollTo;
            t && window.scrollTo(t.x, t.y)
        },
        refresh: function() {
            this.scrollTop(),
            this.queueUpdate(!0)
        },
        updateLayout: function() {
            var e = this.currentScaleMode;
            if (e !== t.ScaleManager.RESIZE) {
                if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : e === t.ScaleManager.EXACT_FIT ? this.setExactFit() : e === t.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : e === t.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : e === t.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (e === t.ScaleManager.SHOW_ALL || e === t.ScaleManager.USER_SCALE)) {
                    var i = this.getParentBounds(this._tempBounds);
                    this.width = Math.min(this.width, i.width),
                    this.height = Math.min(this.height, i.height)
                }
                this.width = 0 | this.width,
                this.height = 0 | this.height,
                this.reflowCanvas()
            } else this.reflowGame()
        },
        getParentBounds: function(e, i) {
            var s = e || new t.Rectangle,
            n = i || this.boundingParent,
            r = this.dom.visualBounds,
            o = this.dom.layoutBounds;
            if (n) {
                var a = n.getBoundingClientRect(),
                h = n.offsetParent ? n.offsetParent.getBoundingClientRect() : n.getBoundingClientRect();
                s.setTo(a.left - h.left, a.top - h.top, a.width, a.height);
                var l = this.windowConstraints;
                if (l.right && (c = "layout" === l.right ? o: r, s.right = Math.min(s.right, c.width)), l.bottom) {
                    var c = "layout" === l.bottom ? o: r;
                    s.bottom = Math.min(s.bottom, c.height)
                }
            } else s.setTo(0, 0, r.width, r.height);
            return s.setTo(Math.round(s.x), Math.round(s.y), Math.round(s.width), Math.round(s.height)),
            s
        },
        align: function(t, e) {
            null != t && (this.pageAlignHorizontally = t),
            null != e && (this.pageAlignVertically = e)
        },
        alignCanvas: function(t, e) {
            var i = this.getParentBounds(this._tempBounds),
            s = this.game.canvas,
            n = this.margin;
            if (t) {
                if (n.left = n.right = 0, h = s.getBoundingClientRect(), this.width < i.width && !this.incorrectOrientation) {
                    var r = h.left - i.x,
                    o = i.width / 2 - this.width / 2,
                    a = (o = Math.max(o, 0)) - r;
                    n.left = Math.round(a)
                }
                s.style.marginLeft = n.left + "px",
                0 !== n.left && (n.right = -(i.width - h.width - n.left), s.style.marginRight = n.right + "px")
            }
            if (e) {
                n.top = n.bottom = 0;
                var h = s.getBoundingClientRect();
                if (this.height < i.height && !this.incorrectOrientation) {
                    r = h.top - i.y,
                    o = i.height / 2 - this.height / 2,
                    a = (o = Math.max(o, 0)) - r;
                    n.top = Math.round(a)
                }
                s.style.marginTop = n.top + "px",
                0 !== n.top && (n.bottom = -(i.height - h.height - n.top), s.style.marginBottom = n.bottom + "px")
            }
            n.x = n.left,
            n.y = n.top
        },
        reflowGame: function() {
            this.resetCanvas("", "");
            var t = this.getParentBounds(this._tempBounds);
            this.updateDimensions(t.width, t.height, !0)
        },
        reflowCanvas: function() {
            this.incorrectOrientation || (this.width = t.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = t.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)),
            this.resetCanvas(),
            this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)),
            this.updateScalingAndBounds()
        },
        resetCanvas: function(t, e) {
            void 0 === t && (t = this.width + "px"),
            void 0 === e && (e = this.height + "px");
            var i = this.game.canvas;
            this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""),
            i.style.width = t,
            i.style.height = e
        },
        queueUpdate: function(t) {
            t && (this._parentBounds.width = 0, this._parentBounds.height = 0),
            this._updateThrottle = this._updateThrottleReset
        },
        reset: function(t) {
            t && this.grid && this.grid.reset()
        },
        setMaximum: function() {
            this.width = this.dom.visualBounds.width,
            this.height = this.dom.visualBounds.height
        },
        setShowAll: function(t) {
            var e, i = this.getParentBounds(this._tempBounds),
            s = i.width,
            n = i.height;
            e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width),
            this.width = Math.round(this.game.width * e),
            this.height = Math.round(this.game.height * e)
        },
        setExactFit: function() {
            var t = this.getParentBounds(this._tempBounds);
            this.width = t.width,
            this.height = t.height,
            this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
        },
        createFullScreenTarget: function() {
            var t = document.createElement("div");
            return t.style.margin = "0",
            t.style.padding = "0",
            t.style.background = "#000",
            t
        },
        startFullScreen: function(e, i) {
            if (this.isFullScreen) return ! 1;
            if (this.compatibility.supportsFullScreen) {
                if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                    var s = this.game.input;
                    if (s.activePointer && s.activePointer !== s.mousePointer && (i || !1 !== i)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [e, !1])
                }
                void 0 !== e && this.game.renderType === t.CANVAS && (this.game.stage.smoothed = e);
                var n = this.fullScreenTarget;
                n || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), n = this._createdFullScreenTarget);
                var r = {
                    targetElement: n
                };
                if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, r), this._createdFullScreenTarget) {
                    var o = this.game.canvas;
                    o.parentNode.insertBefore(n, o),
                    n.appendChild(o)
                }
                return this.game.device.fullscreenKeyboard ? n[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : n[this.game.device.requestFullscreen](),
                !0
            }
            var a = this;
            setTimeout(function() {
                a.fullScreenError()
            },
            10)
        },
        stopFullScreen: function() {
            return ! (!this.isFullScreen || !this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), 0))
        },
        cleanupCreatedTarget: function() {
            var t = this._createdFullScreenTarget;
            if (t && t.parentNode) {
                var e = t.parentNode;
                e.insertBefore(this.game.canvas, t),
                e.removeChild(t)
            }
            this._createdFullScreenTarget = null
        },
        prepScreenMode: function(e) {
            var i = !!this._createdFullScreenTarget,
            s = this._createdFullScreenTarget || this.fullScreenTarget;
            e ? (i || this.fullScreenScaleMode === t.ScaleManager.EXACT_FIT) && s !== this.game.canvas && (this._fullScreenRestore = {
                targetWidth: s.style.width,
                targetHeight: s.style.height
            },
            s.style.width = "100%", s.style.height = "100%") : (this._fullScreenRestore && (s.style.width = this._fullScreenRestore.targetWidth, s.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
        },
        fullScreenChange: function(t) {
            this.event = t,
            this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)),
            this.onFullScreenChange.dispatch(this, this.width, this.height)
        },
        fullScreenError: function(t) {
            this.event = t,
            this.cleanupCreatedTarget(),
            console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"),
            this.onFullScreenError.dispatch(this)
        },
        scaleSprite: function(t, e, i, s) {
            if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
            if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
            var n = e,
            r = t.height * e / t.width,
            o = t.width * i / t.height,
            a = i,
            h = o > e;
            return (h = h ? s: !s) ? (t.width = Math.floor(n), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)),
            t
        },
        destroy: function() {
            this.game.onResume.remove(this._gameResumed, this),
            window.removeEventListener("orientationchange", this._orientationChange, !1),
            window.removeEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
        }
    },
    t.ScaleManager.prototype.constructor = t.ScaleManager,
    Object.defineProperty(t.ScaleManager.prototype, "boundingParent", {
        get: function() {
            return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null: this.game.canvas && this.game.canvas.parentNode || null
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode
        },
        set: function(t) {
            return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t),
            this._scaleMode
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function() {
            return this._fullScreenScaleMode
        },
        set: function(t) {
            return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t),
            this._fullScreenScaleMode
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "currentScaleMode", {
        get: function() {
            return this.isFullScreen ? this._fullScreenScaleMode: this._scaleMode
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function() {
            return this._pageAlignHorizontally
        },
        set: function(t) {
            t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "pageAlignVertically", {
        get: function() {
            return this._pageAlignVertically
        },
        set: function(t) {
            t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return !! (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return "portrait" === this.classifyOrientation(this.screenOrientation)
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return "landscape" === this.classifyOrientation(this.screenOrientation)
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "isGamePortrait", {
        get: function() {
            return this.height > this.width
        }
    }),
    Object.defineProperty(t.ScaleManager.prototype, "isGameLandscape", {
        get: function() {
            return this.width > this.height
        }
    }),
    t.Utils.Debug = function(t) {
        this.game = t,
        this.sprite = null,
        this.bmd = null,
        this.canvas = null,
        this.context = null,
        this.font = "14px monospace",
        this.columnWidth = 100,
        this.lineHeight = 16,
        this.lineWidth = 1,
        this.renderShadow = !0,
        this.currentColor = null,
        this.currentX = 0,
        this.currentY = 0,
        this.currentAlpha = 1,
        this.dirty = !1,
        this.isDisabled = !1,
        this._line = null,
        this._rect = null
    },
    t.Utils.Debug.GEOM_AUTO = 0,
    t.Utils.Debug.GEOM_RECTANGLE = 1,
    t.Utils.Debug.GEOM_CIRCLE = 2,
    t.Utils.Debug.GEOM_POINT = 3,
    t.Utils.Debug.GEOM_LINE = 4,
    t.Utils.Debug.GEOM_ELLIPSE = 5,
    t.Utils.Debug.prototype = {
        boot: function() {
            this.game.renderType === t.CANVAS ? this.context = this.game.context: (this.bmd = new t.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = t.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")),
            this._line = new t.Line,
            this._rect = new t.Rectangle
        },
        resize: function() {
            this.bmd.resize(this.game.width, this.game.height),
            this.canvas.width = this.game.width,
            this.canvas.height = this.game.height
        },
        preUpdate: function() {
            this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
        },
        reset: function() {
            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height),
            this.sprite && this.bmd.clear()
        },
        start: function(t, e, i, s) {
            "number" != typeof t && (t = 0),
            "number" != typeof e && (e = 0),
            i = i || "rgb(255,255,255)",
            void 0 === s && (s = 0),
            this.currentX = t,
            this.currentY = e,
            this.currentColor = i,
            this.columnWidth = s,
            this.dirty = !0,
            this.context.save(),
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.strokeStyle = i,
            this.context.fillStyle = i,
            this.context.font = this.font,
            this.context.globalAlpha = this.currentAlpha
        },
        stop: function() {
            this.context.restore()
        },
        line: function() {
            for (var t = this.currentX,
            e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor),
            this.context.fillText(arguments[e], t, this.currentY),
            t += this.columnWidth;
            this.currentY += this.lineHeight
        },
        sound: function(t, e, i) {
            var s = this.game.sound;
            this.start(t, e, i),
            s.noAudio ? this.line("Audio is disabled") : (this.line("Volume: " + s.volume.toFixed(2) + (s.mute ? " (Mute)": "")), this.line("Mute on pause: " + s.muteOnPause), this.line("Using: " + (s.usingWebAudio ? "Web Audio - " + s.context.state: "Audio Tag")), this.line("Touch locked: " + s.touchLocked), this.line("Sounds: " + s._sounds.length)),
            this.stop()
        },
        soundInfo: function(t, e, i, s) {
            this.start(e, i, s),
            this.line("Sound: " + t.key + "  Touch locked: " + t.game.sound.touchLocked),
            this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + "  Pending Playback: " + t.pendingPlayback),
            this.line("Decoded: " + t.isDecoded + "  Decoding: " + t.isDecoding),
            this.line("Playing: " + t.isPlaying + "  Loop: " + t.loop),
            this.line("Time: " + (t.currentTime / 1e3).toFixed(3) + "s  Total: " + t.totalDuration.toFixed(3) + "s"),
            this.line("Volume: " + t.volume.toFixed(2) + (t.mute ? " (Mute)": "")),
            this.line("Using: " + (t.usingWebAudio ? "Web Audio": "Audio Tag") + "  " + (t.usingWebAudio ? "Source: " + (t.sourceId || "none") : "")),
            "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + "  Duration: " + t.duration.toFixed(3) + "s (" + t.durationMS + "ms)"), this.line("Start: " + t.markers[t.currentMarker].start + "  Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)),
            this.stop()
        },
        camera: function(t, e, i) {
            var s = t.deadzone,
            n = t.target,
            r = t.view;
            s && (this._rect.setTo(r.x + s.x, r.y + s.y, s.width, s.height), this.rectangle(this._rect, e, i)),
            n && (this._line.setTo(r.centerX, r.centerY, n.x, n.y), this.geom(this._line, e, i), this.geom(n, e, !1, 3))
        },
        cameraInfo: function(t, e, i, s) {
            var n = t.bounds,
            r = t.deadzone,
            o = t.target,
            a = t.view;
            this.start(e, i, s),
            this.line("Camera (" + t.width + " x " + t.height + ")"),
            this.line("x: " + t.x + " y: " + t.y),
            this.line("Bounds: " + (n ? "x: " + n.x + " y: " + n.y + " w: " + n.width + " h: " + n.height: "none")),
            this.line("View: x: " + a.x + " y: " + a.y + " w: " + a.width + " h: " + a.height),
            this.line("Center: x: " + t.centerX + " y: " + t.centerY),
            this.line("Deadzone: " + (r ? "x: " + r.x + " y: " + r.y + " w: " + r.width + " h: " + r.height: r)),
            this.line("Total in view: " + t.totalInView),
            this.line("At limit: x: " + t.atLimit.x + " y: " + t.atLimit.y),
            this.line("Target: " + (o ? o.name || o: "none")),
            this.stop()
        },
        timer: function(t, e, i, s) {
            this.start(e, i, s),
            this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"),
            this.line("Next Tick: " + t.next + " Duration: " + t.duration),
            this.line("Paused: " + t.paused + " Length: " + t.length),
            this.stop()
        },
        pointer: function(t, e, i, s, n, r) {
            if (null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,255,0,0.5)", r = r || "rgba(255,0,0,0.5)", !0 !== e || !0 !== t.isUp)) {
                this.start(t.x, t.y - 150, n),
                this.context.beginPath(),
                this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI),
                t.active ? this.context.fillStyle = t.isDown ? i: s: this.context.fillStyle = r,
                this.context.fill(),
                this.context.closePath(),
                this.context.beginPath(),
                this.context.moveTo(t.positionDown.x, t.positionDown.y),
                this.context.lineTo(t.position.x, t.position.y),
                this.context.lineWidth = 2,
                this.context.stroke(),
                this.context.closePath();
                var o = t.movementX,
                a = t.movementY; (o || a) && (this.context.beginPath(), this.context.moveTo(o + t.position.x, a + t.position.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath()),
                this.line("ID: " + t.id + " Active: " + t.active),
                this.line("World X: " + t.worldX.toFixed(1) + " World Y: " + t.worldY.toFixed(1)),
                this.line("Screen X: " + t.x.toFixed(1) + " Screen Y: " + t.y.toFixed(1) + " In: " + t.withinGame),
                this.line("Movement: X: " + o + " Y: " + a),
                this.line("Duration: " + t.duration + " ms"),
                this.line("is Down: " + t.isDown + " is Up: " + t.isUp),
                t.isMouse && this.line("Buttons: " + this._pointerButtonIcon(t.leftButton) + " " + this._pointerButtonIcon(t.middleButton) + " " + this._pointerButtonIcon(t.rightButton)),
                this.stop()
            }
        },
        _pointerButtonIcon: function(t) {
            return t.isDown ? "x": t.isUp ? "o": "-"
        },
        spriteInputInfo: function(t, e, i, s) {
            this.start(e, i, s),
            this.line("Sprite Input: (" + t.width + " x " + t.height + ")"),
            this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)),
            this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)),
            this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)),
            this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()),
            this.stop()
        },
        key: function(t, e, i, s) {
            this.start(e, i, s, 150),
            this.line("Key:", t.keyCode, "isDown:", t.isDown),
            this.line("justDown:", t.justDown, "justUp:", t.justUp),
            this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)),
            this.stop()
        },
        inputInfo: function(e, i, s, n) {
            var r = this.game.input;
            if (void 0 === n && (n = !0), this.start(e, i, s), this.line("Input"), this.line("X: " + r.x + " Y: " + r.y), this.line("World X: " + r.worldX + " World Y: " + r.worldY), this.line("Scale X: " + r.scale.x.toFixed(2) + " Scale Y: " + r.scale.x.toFixed(2)), this.line("Screen X: " + r.activePointer.screenX.toFixed(1) + " Screen Y: " + r.activePointer.screenY.toFixed(1)), n) {
                this.line("Sources:"),
                this.line("  " + this._inputHandler(r.mouse, "mouse")),
                this.line("  " + this._inputHandler(r.mspointer, "mspointer")),
                this.line("  " + this._inputHandler(r.touch, "touch"));
                var o = r.pointers,
                a = r.mousePointer,
                h = t.PointerModes;
                this.line("Pointers: (Max: " + r.maxPointers + ")"),
                this.line("  " + (a.isDown ? "x": "o") + " " + h[a.pointerMode]);
                for (var l = 0; l < o.length; l++) {
                    var c = o[l];
                    this.line("  " + (c.active ? "+": "-") + " " + h[c.pointerMode])
                }
                this.stop()
            } else this.stop()
        },
        _inputHandler: function(t, e) {
            return this._inputHandlerStatusIcon(t) + " " + e + " " + this._inputHandlerCaptureIcon(t)
        },
        _inputHandlerStatusIcon: function(t) {
            return t.active ? t.enabled ? "+": "-": " "
        },
        _inputHandlerCaptureIcon: function(t) {
            return t.active && (t.capture || t.preventDefault) ? "*": " "
        },
        spriteBounds: function(t, e, i) {
            var s = t.getBounds();
            s.x += this.game.camera.x,
            s.y += this.game.camera.y,
            this.rectangle(s, e, i)
        },
        ropeSegments: function(t, e, i) {
            var s = this;
            t.segments.forEach(function(t) {
                s.rectangle(t, e, i)
            },
            this)
        },
        spriteInfo: function(t, e, i, s) {
            this.start(e, i, s),
            this.line("Sprite: " + (t.name || "") + " (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y),
            this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)),
            this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)),
            this.line("visible: " + t.visible + " in camera: " + t.inCamera),
            this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)),
            this.line("parent: " + (t.parent ? t.parent.name || "(DisplayObject)": "(none)")),
            this.stop()
        },
        spriteCoords: function(t, e, i, s) {
            this.start(e, i, s, 100),
            t.name && this.line(t.name),
            this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)),
            this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)),
            this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)),
            this.stop()
        },
        lineInfo: function(t, e, i, s) {
            this.start(e, i, s, 80),
            this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)),
            this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)),
            this.line("length:", t.length.toFixed(2), "angle:", t.angle),
            this.stop()
        },
        pixel: function(t, e, i, s) {
            s = s || 2,
            this.start(),
            this.context.fillStyle = i,
            this.context.fillRect(t, e, s, s),
            this.stop()
        },
        geom: function(e, i, s, n) {
            void 0 === s && (s = !0),
            void 0 === n && (n = 0),
            i = i || "rgba(0,255,0,0.4)",
            this.start(),
            this.context.fillStyle = i,
            this.context.strokeStyle = i,
            this.context.lineWidth = this.lineWidth;
            var r = t.Utils.Debug;
            n === r.GEOM_RECTANGLE || e instanceof t.Rectangle ? s ? this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height) : this.context.strokeRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height) : n === r.GEOM_CIRCLE || e instanceof t.Circle ? (this.context.beginPath(), this.context.arc(e.x - this.game.camera.x, e.y - this.game.camera.y, e.radius, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()) : n === r.GEOM_POINT || e instanceof t.Point ? this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, 4, 4) : n === r.GEOM_LINE || e instanceof t.Line ? (this.context.beginPath(), this.context.moveTo(e.start.x + .5 - this.game.camera.x, e.start.y + .5 - this.game.camera.y), this.context.lineTo(e.end.x + .5 - this.game.camera.x, e.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()) : (n === r.GEOM_ELLIPSE || e instanceof t.Ellipse) && (this.context.beginPath(), this.context.ellipse(e.centerX - this.game.camera.x, e.centerY - this.game.camera.y, e.width / 2, e.height / 2, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()),
            this.stop()
        },
        rectangle: function(t, e, i) {
            void 0 === i && (i = !0),
            e = e || "rgba(0, 255, 0, 0.4)",
            this.start(),
            i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)),
            this.stop()
        },
        text: function(t, e, i, s, n) {
            s = s || "rgb(255,255,255)",
            n = n || this.font,
            this.start(),
            this.context.font = n,
            this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)),
            this.context.fillStyle = s,
            this.context.fillText(t, e, i),
            this.stop()
        },
        quadTree: function(t, e) {
            e = e || "rgba(255,0,0,0.3)",
            this.start();
            var i = t.bounds;
            if (0 === t.nodes.length) for (this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)", s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height);
            else for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
            this.stop()
        },
        body: function(e, i, s) {
            e.body && (this.start(), e.body.type === t.Physics.ARCADE ? t.Physics.Arcade.Body.render(this.context, e.body, i, s, this.lineWidth) : e.body.type === t.Physics.NINJA ? t.Physics.Ninja.Body.render(this.context, e.body, i, s) : e.body.type === t.Physics.BOX2D && t.Physics.Box2D.renderBody(this.context, e.body, i), this.stop())
        },
        bodyInfo: function(e, i, s, n) {
            e.body && (this.start(i, s, n, 210), e.body.type === t.Physics.ARCADE ? t.Physics.Arcade.Body.renderBodyInfo(this, e.body) : e.body.type === t.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, e.body), this.stop())
        },
        box2dWorld: function() {
            this.start(),
            this.context.translate( - this.game.camera.view.x, -this.game.camera.view.y, 0),
            this.game.physics.box2d.renderDebugDraw(this.context),
            this.stop()
        },
        box2dBody: function(e, i) {
            this.start(),
            t.Physics.Box2D.renderBody(this.context, e, i),
            this.stop()
        },
        displayList: function(t) {
            if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0) for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
        },
        renderer: function(t, e, i) {
            var s = this.game.renderer,
            n = s.renderSession;
            if (this.start(t, e, i), this.line((s.gl ? "WebGL": "Canvas") + " Renderer (" + s.width + " x " + s.height + ")"), this.line("autoResize: " + s.autoResize), this.line("clearBeforeRender: " + s.clearBeforeRender), this.line("resolution: " + s.resolution), this.line("transparent: " + s.transparent), this.line("renderSession:"), s.gl) {
                this.line("  currentBatchedTextures: (" + s.currentBatchedTextures.length + ")");
                for (var r = 0; r < s.currentBatchedTextures.length; r++) this.line("    " + s.currentBatchedTextures[r]);
                this.line("  drawCount: " + n.drawCount),
                this.line("  maxTextures: " + s.maxTextures),
                this.line("  maxTextureSize: " + s.maxTextureSize),
                this.line("  maxTextureAvailableSpace: " + n.maxTextureAvailableSpace),
                this.line("  roundPixels: " + n.roundPixels)
            } else this.line("  roundPixels: " + n.roundPixels),
            this.line("  scaleMode: " + (0 === n.scaleMode ? "LINEAR": 1 === n.scaleMode ? "NEAREST": n.scaleMode));
            this.stop()
        },
        canvasPool: function(e, i, s, n) {
            var r = t.CanvasPool;
            this.start(e, i, s, n || 100),
            this.line("Canvas Pool"),
            this.line("Used:", r.getTotal()),
            this.line("Free:", r.getFree()),
            this.line("Total:", r.length),
            this.stop()
        },
        physicsGroup: function(t, e, i, s) {
            t.forEach(this.body, this, s, e, i)
        },
        phaser: function(e, i, s) {
            this.text("Phaser v" + t.VERSION + " " + (this.game.renderType === t.WEBGL ? "WebGL": "Canvas") + " " + (this.game.device.webAudio ? "WebAudio": "HTML Audio"), e, i, s, this.font)
        },
        scale: function(e, i, s) {
            this.start(e, i, s);
            var n = this.game.scale,
            r = n.scaleFactorInversed,
            o = n._parentBounds;
            e = " x ";
            this.line("Game: " + this.game.width + e + this.game.height),
            this.line("Canvas: " + n.width + e + n.height + " (" + r.x.toFixed(2) + e + r.y.toFixed(2) + ") [" + n.aspectRatio.toFixed(2) + "]"),
            this.line("Mode: " + t.ScaleManager.MODES[n.currentScaleMode] + (n.currentScaleMode === t.ScaleManager.USER_SCALE ? " (" + n._userScaleFactor.x + e + n._userScaleFactor.y + ")": "")),
            this.line("Parent: " + (n.parentIsWindow ? "window": n.parentNode) + (o.empty ? "": " (" + o.width + e + o.height + ")")),
            this.line("Screen: " + n.classifyOrientation(n.screenOrientation) + (n.incorrectOrientation ? " (incorrect)": "")),
            this.stop()
        },
        loader: function(e, i, s, n) {
            var r = t.Utils.pad;
            this.start(i, s, n),
            e.hasLoaded ? this.line("Complete" + (e.resetLocked ? " [locked]": "")) : e.isLoading ? this.line("Loading") : this.line("Not started"),
            e.hasLoaded && !e.resetLocked || (this.line("Progress: " + r(e.progress, 3) + "%"), this.line("Files: " + e._loadedFileCount + " of " + e._totalFileCount), this.line("Packs: " + e._loadedPackCount + " of " + e._loadedPackCount)),
            this.stop()
        },
        device: function(t, e, i) {
            var s = this.game.device;
            this.start(t, e, i),
            this.line("Device"),
            this.line("Pointer Events: " + s.mspointer),
            this.line("Touch: " + s.touch),
            this.line("Web Audio: " + s.webAudio),
            this.line("WebGL: " + s.webGL),
            this.stop()
        },
        destroy: function() {
            t.CanvasPool.remove(this)
        }
    },
    t.Utils.Debug.prototype.constructor = t.Utils.Debug,
    t.DOM = {
        getOffset: function(e, i) {
            i = i || new t.Point;
            var s = e.getBoundingClientRect(),
            n = t.DOM.scrollY,
            r = t.DOM.scrollX,
            o = document.documentElement.clientTop,
            a = document.documentElement.clientLeft;
            return i.x = s.left + r - a,
            i.y = s.top + n - o,
            i
        },
        getBounds: function(t, e) {
            return void 0 === e && (e = 0),
            !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
        },
        calibrate: function(t, e) {
            e = +e || 0;
            var i = {
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            return i.width = (i.right = t.right + e) - (i.left = t.left - e),
            i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e),
            i
        },
        getAspectRatio: function(t) {
            var e = (t = null == t ? this.visualBounds: 1 === t.nodeType ? this.getBounds(t) : t).width,
            i = t.height;
            return "function" == typeof e && (e = e.call(t)),
            "function" == typeof i && (i = i.call(t)),
            e / i
        },
        inLayoutViewport: function(t, e) {
            var i = this.getBounds(t, e);
            return !! i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
        },
        getScreenOrientation: function(t) {
            var e = window.screen,
            i = e.orientation || e.mozOrientation || e.msOrientation;
            if (i && "string" == typeof i.type) return i.type;
            if ("string" == typeof i) return i;
            var s = "portrait-primary",
            n = "landscape-primary";
            if ("screen" === t) return e.height > e.width ? s: n;
            if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s: n;
            if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s: n;
            if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches) return s;
                if (window.matchMedia("(orientation: landscape)").matches) return n
            }
            return this.visualBounds.height > this.visualBounds.width ? s: n
        },
        visualBounds: new t.Rectangle,
        layoutBounds: new t.Rectangle,
        documentBounds: new t.Rectangle
    },
    t.Device.whenReady(function(e) {
        var i = window && "pageXOffset" in window ?
        function() {
            return window.pageXOffset
        }: function() {
            return document.documentElement.scrollLeft
        },
        s = window && "pageYOffset" in window ?
        function() {
            return window.pageYOffset
        }: function() {
            return document.documentElement.scrollTop
        };
        if (Object.defineProperty(t.DOM, "scrollX", {
            get: i
        }), Object.defineProperty(t.DOM, "scrollY", {
            get: s
        }), Object.defineProperty(t.DOM.visualBounds, "x", {
            get: i
        }), Object.defineProperty(t.DOM.visualBounds, "y", {
            get: s
        }), Object.defineProperty(t.DOM.layoutBounds, "x", {
            value: 0
        }), Object.defineProperty(t.DOM.layoutBounds, "y", {
            value: 0
        }), e.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
            var n = function() {
                return Math.max(window.innerWidth, document.documentElement.clientWidth)
            },
            r = function() {
                return Math.max(window.innerHeight, document.documentElement.clientHeight)
            };
            Object.defineProperty(t.DOM.visualBounds, "width", {
                get: n
            }),
            Object.defineProperty(t.DOM.visualBounds, "height", {
                get: r
            }),
            Object.defineProperty(t.DOM.layoutBounds, "width", {
                get: n
            }),
            Object.defineProperty(t.DOM.layoutBounds, "height", {
                get: r
            })
        } else Object.defineProperty(t.DOM.visualBounds, "width", {
            get: function() {
                return window.innerWidth
            }
        }),
        Object.defineProperty(t.DOM.visualBounds, "height", {
            get: function() {
                return window.innerHeight
            }
        }),
        Object.defineProperty(t.DOM.layoutBounds, "width", {
            get: function() {
                var t = document.documentElement.clientWidth,
                e = window.innerWidth;
                return t < e ? e: t
            }
        }),
        Object.defineProperty(t.DOM.layoutBounds, "height", {
            get: function() {
                var t = document.documentElement.clientHeight,
                e = window.innerHeight;
                return t < e ? e: t
            }
        });
        Object.defineProperty(t.DOM.documentBounds, "x", {
            value: 0
        }),
        Object.defineProperty(t.DOM.documentBounds, "y", {
            value: 0
        }),
        Object.defineProperty(t.DOM.documentBounds, "width", {
            get: function() {
                var t = document.documentElement;
                return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
            }
        }),
        Object.defineProperty(t.DOM.documentBounds, "height", {
            get: function() {
                var t = document.documentElement;
                return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
            }
        })
    },
    null, !0),
    t.ArraySet = function(t) {
        this.position = 0,
        this.list = t || []
    },
    t.ArraySet.prototype = {
        add: function(t) {
            return this.exists(t) || this.list.push(t),
            t
        },
        getIndex: function(t) {
            return this.list.indexOf(t)
        },
        getByKey: function(t, e) {
            for (var i = this.list.length; i--;) if (this.list[i][t] === e) return this.list[i];
            return null
        },
        exists: function(t) {
            return this.list.indexOf(t) > -1
        },
        reset: function() {
            this.list.length = 0
        },
        remove: function(t) {
            var e = this.list.indexOf(t);
            if (e > -1) return this.list.splice(e, 1),
            t
        },
        setAll: function(t, e) {
            for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
        },
        callAll: function(t) {
            for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
        },
        removeAll: function(t) {
            void 0 === t && (t = !1);
            for (var e = this.list.length; e--;) if (this.list[e]) {
                var i = this.remove(this.list[e]);
                t && i.destroy()
            }
            this.position = 0,
            this.list = []
        }
    },
    Object.defineProperty(t.ArraySet.prototype, "total", {
        get: function() {
            return this.list.length
        }
    }),
    Object.defineProperty(t.ArraySet.prototype, "first", {
        get: function() {
            return this.position = 0,
            this.list.length > 0 ? this.list[0] : null
        }
    }),
    Object.defineProperty(t.ArraySet.prototype, "next", {
        get: function() {
            return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
        }
    }),
    t.ArraySet.prototype.constructor = t.ArraySet,
    t.ArrayUtils = {
        getRandomItem: function(t, e, i) {
            if (null === t) return null;
            void 0 === e && (e = 0),
            void 0 === i && (i = t.length);
            var s = e + Math.floor(Math.random() * i);
            return void 0 === t[s] ? null: t[s]
        },
        removeRandomItem: function(t, e, i) {
            if (null == t) return null;
            void 0 === e && (e = 0),
            void 0 === i && (i = t.length);
            var s = e + Math.floor(Math.random() * i);
            if (s < t.length) {
                var n = t.splice(s, 1);
                return void 0 === n[0] ? null: n[0]
            }
            return null
        },
        remove: function(t, e, i) {
            var s = t.length;
            if (! (e >= s || 0 === i)) {
                null == i && (i = 1);
                for (var n = s - i,
                r = e; r < n; ++r) t[r] = t[r + i];
                t.length = n
            }
        },
        shuffle: function(t) {
            for (var e = t.length - 1; e > 0; e--) {
                var i = Math.floor(Math.random() * (e + 1)),
                s = t[e];
                t[e] = t[i],
                t[i] = s
            }
            return t
        },
        transposeMatrix: function(t) {
            for (var e = t.length,
            i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                s[n] = new Array(e);
                for (var r = e - 1; r > -1; r--) s[n][r] = t[r][n]
            }
            return s
        },
        rotateMatrix: function(e, i) {
            if ("string" != typeof i && (i = (i % 360 + 360) % 360), 90 === i || -270 === i || "rotateLeft" === i) e = (e = t.ArrayUtils.transposeMatrix(e)).reverse();
            else if ( - 90 === i || 270 === i || "rotateRight" === i) e = e.reverse(),
            e = t.ArrayUtils.transposeMatrix(e);
            else if (180 === Math.abs(i) || "rotate180" === i) {
                for (var s = 0; s < e.length; s++) e[s].reverse();
                e = e.reverse()
            }
            return e
        },
        findClosest: function(t, e) {
            if (!e.length) return NaN;
            if (1 === e.length || t < e[0]) return e[0];
            for (var i = 1; e[i] < t;) i++;
            var s = e[i - 1],
            n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
            return n - t <= t - s ? n: s
        },
        rotateRight: function(t) {
            var e = t.pop();
            return t.unshift(e),
            e
        },
        rotateLeft: function(t) {
            var e = t.shift();
            return t.push(e),
            e
        },
        numberArray: function(t, e) {
            null != e || (e = t, t = 0);
            for (var i = [], s = t; s <= e; s++) i.push(s);
            return i
        },
        numberArrayStep: function(e, i, s) {
            null != e || (e = 0),
            null != i || (i = e, e = 0),
            void 0 === s && (s = 1);
            for (var n = [], r = Math.max(t.Math.roundAwayFromZero((i - e) / (s || 1)), 0), o = 0; o < r; o++) n.push(e),
            e += s;
            return n
        }
    },
    t.LinkedList = function() {
        this.next = null,
        this.prev = null,
        this.first = null,
        this.last = null,
        this.total = 0
    },
    t.LinkedList.prototype = {
        add: function(t) {
            return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
        },
        reset: function() {
            this.first = null,
            this.last = null,
            this.next = null,
            this.prev = null,
            this.total = 0
        },
        remove: function(t) {
            if (1 === this.total) return this.reset(),
            void(t.next = t.prev = null);
            t === this.first ? this.first = this.first.next: t === this.last && (this.last = this.last.prev),
            t.prev && (t.prev.next = t.next),
            t.next && (t.next.prev = t.prev),
            t.next = t.prev = null,
            null === this.first && (this.last = null),
            this.total--
        },
        callAll: function(t) {
            if (this.first && this.last) {
                var e = this.first;
                do {
                    e && e[t] && e[t].call(e), e = e.next
                } while ( e !== this . last . next )
            }
        }
    },
    t.LinkedList.prototype.constructor = t.LinkedList,
    t.Create = function(t) {
        this.game = t,
        this.bmd = null,
        this.canvas = null,
        this.ctx = null,
        this.palettes = [{
            0 : "#000",
            1 : "#9D9D9D",
            2 : "#FFF",
            3 : "#BE2633",
            4 : "#E06F8B",
            5 : "#493C2B",
            6 : "#A46422",
            7 : "#EB8931",
            8 : "#F7E26B",
            9 : "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
        },
        {
            0 : "#000",
            1 : "#191028",
            2 : "#46af45",
            3 : "#a1d685",
            4 : "#453e78",
            5 : "#7664fe",
            6 : "#833129",
            7 : "#9ec2e8",
            8 : "#dc534b",
            9 : "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
        },
        {
            0 : "#000",
            1 : "#2234d1",
            2 : "#0c7e45",
            3 : "#44aacc",
            4 : "#8a3622",
            5 : "#5c2e78",
            6 : "#aa5c3d",
            7 : "#b5b5b5",
            8 : "#5e606e",
            9 : "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
        },
        {
            0 : "#000",
            1 : "#fff",
            2 : "#8b4131",
            3 : "#7bbdc5",
            4 : "#8b41ac",
            5 : "#6aac41",
            6 : "#3931a4",
            7 : "#d5de73",
            8 : "#945a20",
            9 : "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
        },
        {
            0 : "#000",
            1 : "#191028",
            2 : "#46af45",
            3 : "#a1d685",
            4 : "#453e78",
            5 : "#7664fe",
            6 : "#833129",
            7 : "#9ec2e8",
            8 : "#dc534b",
            9 : "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
        }]
    },
    t.Create.PALETTE_ARNE = 0,
    t.Create.PALETTE_JMP = 1,
    t.Create.PALETTE_CGA = 2,
    t.Create.PALETTE_C64 = 3,
    t.Create.PALETTE_JAPANESE_MACHINE = 4,
    t.Create.prototype = {
        texture: function(t, e, i, s, n, r, o, a) {
            void 0 === i && (i = 8),
            void 0 === s && (s = i),
            void 0 === n && (n = 0),
            void 0 === r && (r = !0);
            var h = e[0].length * i,
            l = e.length * s;
            null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context),
            this.bmd.resize(h, l),
            this.bmd.clear();
            for (var c = 0; c < e.length; c++) for (var u = e[c], d = 0; d < u.length; d++) {
                var p = u[d];
                "." !== p && " " !== p && (this.ctx.fillStyle = this.palettes[n][p], this.ctx.fillRect(d * i, c * s, i, s))
            }
            return r ? this.bmd.generateTexture(t, o, a) : this.copy()
        },
        grid: function(t, e, i, s, n, r, o, a, h) {
            void 0 === o && (o = !0),
            null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context),
            this.bmd.resize(e, i),
            this.ctx.fillStyle = r;
            for (var l = 0; l < i; l += n) this.ctx.fillRect(0, l, e, 1);
            for (var c = 0; c < e; c += s) this.ctx.fillRect(c, 0, 1, i);
            return o ? this.bmd.generateTexture(t, a, h) : this.copy()
        },
        copy: function(t, e, i, s, n, r, o) {
            return null == t && (t = this.game.make.bitmapData()),
            t.resize(this.bmd.width, this.bmd.height),
            t.draw(this.bmd, e, i, s, n, r, o)
        }
    },
    t.Create.prototype.constructor = t.Create,
    t.FlexGrid = function(e, i, s) {
        this.game = e.game,
        this.manager = e,
        this.width = i,
        this.height = s,
        this.boundsCustom = new t.Rectangle(0, 0, i, s),
        this.boundsFluid = new t.Rectangle(0, 0, i, s),
        this.boundsFull = new t.Rectangle(0, 0, i, s),
        this.boundsNone = new t.Rectangle(0, 0, i, s),
        this.positionCustom = new t.Point(0, 0),
        this.positionFluid = new t.Point(0, 0),
        this.positionFull = new t.Point(0, 0),
        this.positionNone = new t.Point(0, 0),
        this.scaleCustom = new t.Point(1, 1),
        this.scaleFluid = new t.Point(1, 1),
        this.scaleFluidInversed = new t.Point(1, 1),
        this.scaleFull = new t.Point(1, 1),
        this.scaleNone = new t.Point(1, 1),
        this.customWidth = 0,
        this.customHeight = 0,
        this.customOffsetX = 0,
        this.customOffsetY = 0,
        this.ratioH = i / s,
        this.ratioV = s / i,
        this.multiplier = 0,
        this.layers = []
    },
    t.FlexGrid.prototype = {
        setSize: function(e, i) {
            this.width = e,
            this.height = i,
            this.ratioH = e / i,
            this.ratioV = i / e,
            this.scaleNone = new t.Point(1, 1),
            this.boundsNone.width = this.width,
            this.boundsNone.height = this.height,
            this.refresh()
        },
        createCustomLayer: function(e, i, s, n) {
            void 0 === n && (n = !0),
            this.customWidth = e,
            this.customHeight = i,
            this.boundsCustom.width = e,
            this.boundsCustom.height = i;
            var r = new t.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
            return n && this.game.world.add(r),
            this.layers.push(r),
            s && r.addMultiple(s),
            r
        },
        createFluidLayer: function(e, i) {
            void 0 === i && (i = !0);
            var s = new t.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            return i && this.game.world.add(s),
            this.layers.push(s),
            e && s.addMultiple(e),
            s
        },
        createFullLayer: function(e) {
            var i = new t.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            return this.game.world.add(i),
            this.layers.push(i),
            void 0 !== e && i.addMultiple(e),
            i
        },
        createFixedLayer: function(e) {
            var i = new t.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            return this.game.world.add(i),
            this.layers.push(i),
            void 0 !== e && i.addMultiple(e),
            i
        },
        reset: function() {
            for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
        },
        onResize: function(t, e) {
            this.ratioH = t / e,
            this.ratioV = e / t,
            this.refresh(t, e)
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width),
            this.boundsFluid.width = Math.round(this.width * this.multiplier),
            this.boundsFluid.height = Math.round(this.height * this.multiplier),
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height),
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height),
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height),
            this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x),
            this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y),
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y),
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
        },
        fitSprite: function(t) {
            this.manager.scaleSprite(t),
            t.x = this.manager.bounds.centerX,
            t.y = this.manager.bounds.centerY
        },
        debug: function() {
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16),
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
        }
    },
    t.FlexGrid.prototype.constructor = t.FlexGrid,
    t.FlexLayer = function(e, i, s, n) {
        t.Group.call(this, e.game, null, "__flexLayer" + e.game.rnd.uuid(), !1),
        this.manager = e.manager,
        this.grid = e,
        this.persist = !1,
        this.position = i,
        this.bounds = s,
        this.scale = n,
        this.topLeft = s.topLeft,
        this.topMiddle = new t.Point(s.halfWidth, 0),
        this.topRight = s.topRight,
        this.bottomLeft = s.bottomLeft,
        this.bottomMiddle = new t.Point(s.halfWidth, s.bottom),
        this.bottomRight = s.bottomRight
    },
    t.FlexLayer.prototype = Object.create(t.Group.prototype),
    t.FlexLayer.prototype.constructor = t.FlexLayer,
    t.FlexLayer.prototype.resize = function() {},
    t.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16),
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1),
        this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"),
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"),
        this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
    },
    t.Color = {
        RED: 16711680,
        ORANGE: 16750848,
        YELLOW: 16776960,
        GREEN: 65280,
        AQUA: 65535,
        BLUE: 255,
        VIOLET: 16711935,
        WHITE: 16777215,
        BLACK: 0,
        GRAY: 6710886,
        packPixel: function(e, i, s, n) {
            return t.Device.LITTLE_ENDIAN ? (n << 24 | s << 16 | i << 8 | e) >>> 0 : (e << 24 | i << 16 | s << 8 | n) >>> 0
        },
        unpackPixel: function(e, i, s, n) {
            return null != i || (i = t.Color.createColor()),
            null != s || (s = !1),
            null != n || (n = !1),
            t.Device.LITTLE_ENDIAN ? (i.a = (4278190080 & e) >>> 24, i.b = (16711680 & e) >>> 16, i.g = (65280 & e) >>> 8, i.r = 255 & e) : (i.r = (4278190080 & e) >>> 24, i.g = (16711680 & e) >>> 16, i.b = (65280 & e) >>> 8, i.a = 255 & e),
            i.color = e,
            i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a / 255 + ")",
            s && t.Color.RGBtoHSL(i.r, i.g, i.b, i),
            n && t.Color.RGBtoHSV(i.r, i.g, i.b, i),
            i
        },
        fromRGBA: function(e, i) {
            return i || (i = t.Color.createColor()),
            i.r = (4278190080 & e) >>> 24,
            i.g = (16711680 & e) >>> 16,
            i.b = (65280 & e) >>> 8,
            i.a = 255 & e,
            i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a + ")",
            i
        },
        toRGBA: function(t, e, i, s) {
            return t << 24 | e << 16 | i << 8 | s
        },
        toABGR: function(t, e, i, s) {
            return (s << 24 | i << 16 | e << 8 | t) >>> 0
        },
        hexToRGBArray: function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        },
        RGBArrayToHex: function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        },
        RGBtoHSL: function(e, i, s, n) {
            n || (n = t.Color.createColor(e, i, s, 1)),
            e /= 255,
            i /= 255,
            s /= 255;
            var r = Math.min(e, i, s),
            o = Math.max(e, i, s);
            if (n.h = 0, n.s = 0, n.l = (o + r) / 2, o !== r) {
                var a = o - r;
                n.s = n.l > .5 ? a / (2 - o - r) : a / (o + r),
                o === e ? n.h = (i - s) / a + (i < s ? 6 : 0) : o === i ? n.h = (s - e) / a + 2 : o === s && (n.h = (e - i) / a + 4),
                n.h /= 6
            }
            return n
        },
        HSLtoRGB: function(e, i, s, n) {
            if (n ? (n.r = s, n.g = s, n.b = s) : n = t.Color.createColor(s, s, s), 0 !== i) {
                var r = s < .5 ? s * (1 + i) : s + i - s * i,
                o = 2 * s - r;
                n.r = t.Color.hueToColor(o, r, e + 1 / 3),
                n.g = t.Color.hueToColor(o, r, e),
                n.b = t.Color.hueToColor(o, r, e - 1 / 3)
            }
            return n.r = Math.floor(255 * n.r | 0),
            n.g = Math.floor(255 * n.g | 0),
            n.b = Math.floor(255 * n.b | 0),
            t.Color.updateColor(n),
            n
        },
        RGBtoHSV: function(e, i, s, n) {
            n || (n = t.Color.createColor(e, i, s, 255)),
            e /= 255,
            i /= 255,
            s /= 255;
            var r = Math.min(e, i, s),
            o = Math.max(e, i, s),
            a = o - r;
            return n.h = 0,
            n.s = 0 === o ? 0 : a / o,
            n.v = o,
            o !== r && (o === e ? n.h = (i - s) / a + (i < s ? 6 : 0) : o === i ? n.h = (s - e) / a + 2 : o === s && (n.h = (e - i) / a + 4), n.h /= 6),
            n
        },
        HSVtoRGB: function(e, i, s, n) {
            void 0 === n && (n = t.Color.createColor(0, 0, 0, 1, e, i, 0, s));
            var r, o, a, h = Math.floor(6 * e),
            l = 6 * e - h,
            c = s * (1 - i),
            u = s * (1 - l * i),
            d = s * (1 - (1 - l) * i);
            switch (h % 6) {
            case 0:
                r = s,
                o = d,
                a = c;
                break;
            case 1:
                r = u,
                o = s,
                a = c;
                break;
            case 2:
                r = c,
                o = s,
                a = d;
                break;
            case 3:
                r = c,
                o = u,
                a = s;
                break;
            case 4:
                r = d,
                o = c,
                a = s;
                break;
            case 5:
                r = s,
                o = c,
                a = u
            }
            return n.r = Math.floor(255 * r),
            n.g = Math.floor(255 * o),
            n.b = Math.floor(255 * a),
            t.Color.updateColor(n),
            n
        },
        hueToColor: function(t, e, i) {
            return i < 0 && (i += 1),
            i > 1 && (i -= 1),
            i < 1 / 6 ? t + 6 * (e - t) * i: i < .5 ? e: i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
        },
        createColor: function(e, i, s, n, r, o, a, h) {
            var l = {
                r: e || 0,
                g: i || 0,
                b: s || 0,
                a: n || 1,
                h: r || 0,
                s: o || 0,
                l: a || 0,
                v: h || 0,
                color: 0,
                color32: 0,
                rgba: ""
            };
            return t.Color.updateColor(l)
        },
        updateColor: function(e) {
            return e.rgba = "rgba(" + e.r.toFixed() + "," + e.g.toFixed() + "," + e.b.toFixed() + "," + e.a.toString() + ")",
            e.color = t.Color.getColor(e.r, e.g, e.b),
            e.color32 = t.Color.getColor32(255 * e.a, e.r, e.g, e.b),
            e
        },
        getColor32: function(t, e, i, s) {
            return t << 24 | e << 16 | i << 8 | s
        },
        getColor: function(t, e, i) {
            return t << 16 | e << 8 | i
        },
        RGBtoString: function(e, i, s, n, r) {
            return void 0 === n && (n = 255),
            void 0 === r && (r = "#"),
            "#" === r ? "#" + ((1 << 24) + (e << 16) + (i << 8) + s).toString(16).slice(1) : "0x" + t.Color.componentToHex(n) + t.Color.componentToHex(e) + t.Color.componentToHex(i) + t.Color.componentToHex(s)
        },
        hexToRGB: function(e) {
            var i = t.Color.hexToColor(e);
            if (i) return t.Color.getColor32(i.a, i.r, i.g, i.b)
        },
        hexToColor: function(e, i) {
            e = e.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i,
            function(t, e, i, s) {
                return e + e + i + i + s + s
            });
            var s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
            if (s) {
                var n = parseInt(s[1], 16),
                r = parseInt(s[2], 16),
                o = parseInt(s[3], 16);
                i ? (i.r = n, i.g = r, i.b = o) : i = t.Color.createColor(n, r, o)
            }
            return i
        },
        webToColor: function(e, i) {
            i || (i = t.Color.createColor());
            var s = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(e);
            return s && (i.r = ~~Number(s[1]), i.g = ~~Number(s[2]), i.b = ~~Number(s[3]), i.a = void 0 !== s[4] ? Number(s[4]) : 1, t.Color.updateColor(i)),
            i
        },
        valueToColor: function(e, i) {
            if (i || (i = t.Color.createColor()), "string" == typeof e) return 0 === e.indexOf("rgb") ? t.Color.webToColor(e, i) : (i.a = 1, t.Color.hexToColor(e, i));
            if ("number" == typeof e) {
                var s = t.Color.getRGB(e);
                return i.r = s.r,
                i.g = s.g,
                i.b = s.b,
                i.a = s.a / 255,
                i
            }
            return i
        },
        componentToHex: function(t) {
            var e = t.toString(16);
            return 1 === e.length ? "0" + e: e
        },
        HSVColorWheel: function(e, i) {
            void 0 === e && (e = 1),
            void 0 === i && (i = 1);
            for (var s = [], n = 0; n <= 359; n++) s.push(t.Color.HSVtoRGB(n / 359, e, i));
            return s
        },
        HSLColorWheel: function(e, i) {
            void 0 === e && (e = .5),
            void 0 === i && (i = .5);
            for (var s = [], n = 0; n <= 359; n++) s.push(t.Color.HSLtoRGB(n / 359, e, i));
            return s
        },
        interpolateColor: function(e, i, s, n, r, o) {
            void 0 === r && (r = 255),
            void 0 === o && (o = 0);
            var a = t.Color.getRGB(e),
            h = t.Color.getRGB(i);
            if (0 === o) var l = (h.red - a.red) * n / s + a.red,
            c = (h.green - a.green) * n / s + a.green,
            u = (h.blue - a.blue) * n / s + a.blue;
            if (1 === o) {
                var d, p = t.Color.RGBtoHSV(a.r, a.g, a.b),
                f = t.Color.RGBtoHSV(h.r, h.g, h.b),
                g = f.h - p.h;
                if (p.h > f.h) {
                    var m = f.h;
                    f.h = p.h,
                    p.h = m,
                    g = -g,
                    n = s - n
                }
                g > .5 && (p.h = p.h + 1, d = ((f.h - p.h) * n / s + p.h) % 1),
                g <= .5 && (d = (f.h - p.h) * n / s + p.h);
                var y = (f.s - p.s) * n / s + p.s,
                v = (f.v - p.v) * n / s + p.v,
                x = t.Color.HSVtoRGB(d, y, v, x);
                l = x.r,
                c = x.g,
                u = x.b
            }
            return t.Color.getColor32(r, l, c, u)
        },
        interpolateColorWithRGB: function(e, i, s, n, r, o) {
            var a = t.Color.getRGB(e),
            h = (i - a.red) * o / r + a.red,
            l = (s - a.green) * o / r + a.green,
            c = (n - a.blue) * o / r + a.blue;
            return t.Color.getColor(h, l, c)
        },
        interpolateRGB: function(e, i, s, n, r, o, a, h) {
            var l = (n - e) * h / a + e,
            c = (r - i) * h / a + i,
            u = (o - s) * h / a + s;
            return t.Color.getColor(l, c, u)
        },
        linear: function(t, e, i) {
            return this.interpolateColor(t, e, 1, i)
        },
        linearInterpolation: function(e, i) {
            var s = t.Math.linear(0, e.length - 1, i),
            n = e[Math.floor(s)],
            r = e[Math.ceil(s)];
            return this.linear(n, r, s % 1)
        },
        getRandomColor: function(e, i, s) {
            if (void 0 === e && (e = 0), void 0 === i && (i = 255), void 0 === s && (s = 255), i > 255 || e > i) return t.Color.getColor(255, 255, 255);
            var n = e + Math.round(Math.random() * (i - e)),
            r = e + Math.round(Math.random() * (i - e)),
            o = e + Math.round(Math.random() * (i - e));
            return t.Color.getColor32(s, n, r, o)
        },
        getRGB: function(t) {
            return t > 16777215 ? {
                alpha: t >>> 24,
                red: t >> 16 & 255,
                green: t >> 8 & 255,
                blue: 255 & t,
                a: t >>> 24,
                r: t >> 16 & 255,
                g: t >> 8 & 255,
                b: 255 & t
            }: {
                alpha: 255,
                red: t >> 16 & 255,
                green: t >> 8 & 255,
                blue: 255 & t,
                a: 255,
                r: t >> 16 & 255,
                g: t >> 8 & 255,
                b: 255 & t
            }
        },
        getWebRGB: function(e) {
            if ("object" == typeof e) return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")";
            var i = t.Color.getRGB(e);
            return "rgba(" + i.r.toString() + "," + i.g.toString() + "," + i.b.toString() + "," + (i.a / 255).toString() + ")"
        },
        getAlpha: function(t) {
            return t >>> 24
        },
        getAlphaFloat: function(t) {
            return (t >>> 24) / 255
        },
        getRed: function(t) {
            return t >> 16 & 255
        },
        getGreen: function(t) {
            return t >> 8 & 255
        },
        getBlue: function(t) {
            return 255 & t
        },
        blendNormal: function(t) {
            return t
        },
        blendLighten: function(t, e) {
            return e > t ? e: t
        },
        blendDarken: function(t, e) {
            return e > t ? t: e
        },
        blendMultiply: function(t, e) {
            return t * e / 255
        },
        blendAverage: function(t, e) {
            return (t + e) / 2
        },
        blendAdd: function(t, e) {
            return Math.min(255, t + e)
        },
        blendSubtract: function(t, e) {
            return Math.max(0, t + e - 255)
        },
        blendDifference: function(t, e) {
            return Math.abs(t - e)
        },
        blendNegation: function(t, e) {
            return 255 - Math.abs(255 - t - e)
        },
        blendScreen: function(t, e) {
            return 255 - ((255 - t) * (255 - e) >> 8)
        },
        blendExclusion: function(t, e) {
            return t + e - 2 * t * e / 255
        },
        blendOverlay: function(t, e) {
            return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
        },
        blendSoftLight: function(t, e) {
            return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
        },
        blendHardLight: function(e, i) {
            return t.Color.blendOverlay(i, e)
        },
        blendColorDodge: function(t, e) {
            return 255 === e ? e: Math.min(255, (t << 8) / (255 - e))
        },
        blendColorBurn: function(t, e) {
            return 0 === e ? e: Math.max(0, 255 - (255 - t << 8) / e)
        },
        blendLinearDodge: function(e, i) {
            return t.Color.blendAdd(e, i)
        },
        blendLinearBurn: function(e, i) {
            return t.Color.blendSubtract(e, i)
        },
        blendLinearLight: function(e, i) {
            return i < 128 ? t.Color.blendLinearBurn(e, 2 * i) : t.Color.blendLinearDodge(e, 2 * (i - 128))
        },
        blendVividLight: function(e, i) {
            return i < 128 ? t.Color.blendColorBurn(e, 2 * i) : t.Color.blendColorDodge(e, 2 * (i - 128))
        },
        blendPinLight: function(e, i) {
            return i < 128 ? t.Color.blendDarken(e, 2 * i) : t.Color.blendLighten(e, 2 * (i - 128))
        },
        blendHardMix: function(e, i) {
            return t.Color.blendVividLight(e, i) < 128 ? 0 : 255
        },
        blendReflect: function(t, e) {
            return 255 === e ? e: Math.min(255, t * t / (255 - e))
        },
        blendGlow: function(e, i) {
            return t.Color.blendReflect(i, e)
        },
        blendPhoenix: function(t, e) {
            return Math.min(t, e) - Math.max(t, e) + 255
        }
    },
    t.Physics = function(t, e) {
        e = e || {},
        this.game = t,
        this.config = e,
        this.arcade = null,
        this.p2 = null,
        this.ninja = null,
        this.box2d = null,
        this.chipmunk = null,
        this.matter = null,
        this.parseConfig()
    },
    t.Physics.ARCADE = 0,
    t.Physics.P2JS = 1,
    t.Physics.NINJA = 2,
    t.Physics.BOX2D = 3,
    t.Physics.CHIPMUNK = 4,
    t.Physics.MATTERJS = 5,
    t.Physics.prototype = {
        parseConfig: function() {
            this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !t.Physics.hasOwnProperty("Arcade") || (this.arcade = new t.Physics.Arcade(this.game)),
            this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && t.Physics.hasOwnProperty("Ninja") && (this.ninja = new t.Physics.Ninja(this.game)),
            this.config.hasOwnProperty("p2") && !0 === this.config.p2 && t.Physics.hasOwnProperty("P2") && (this.p2 = new t.Physics.P2(this.game, this.config)),
            this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && t.Physics.hasOwnProperty("BOX2D") && (this.box2d = new t.Physics.Box2D(this.game, this.config)),
            this.config.hasOwnProperty("matter") && !0 === this.config.matter && t.Physics.hasOwnProperty("Matter") && (this.matter = new t.Physics.Matter(this.game, this.config))
        },
        startSystem: function(e) {
            e === t.Physics.ARCADE ? this.arcade = new t.Physics.Arcade(this.game) : e === t.Physics.P2JS ? null === this.p2 ? this.p2 = new t.Physics.P2(this.game, this.config) : this.p2.reset() : e === t.Physics.NINJA ? this.ninja = new t.Physics.Ninja(this.game) : e === t.Physics.BOX2D ? null === this.box2d ? this.box2d = new t.Physics.Box2D(this.game, this.config) : this.box2d.reset() : e === t.Physics.MATTERJS && (null === this.matter ? this.matter = new t.Physics.Matter(this.game, this.config) : this.matter.reset())
        },
        enable: function(e, i, s) {
            void 0 === i && (i = t.Physics.ARCADE),
            void 0 === s && (s = !1),
            i === t.Physics.ARCADE ? this.arcade.enable(e) : i === t.Physics.P2JS && this.p2 ? this.p2.enable(e, s) : i === t.Physics.NINJA && this.ninja ? this.ninja.enableAABB(e) : i === t.Physics.BOX2D && this.box2d ? this.box2d.enable(e) : i === t.Physics.MATTERJS && this.matter ? this.matter.enable(e) : console.warn(e.key + " is attempting to enable a physics body using an unknown physics system.")
        },
        preUpdate: function() {
            this.p2 && this.p2.preUpdate(),
            this.box2d && this.box2d.preUpdate(),
            this.matter && this.matter.preUpdate()
        },
        update: function() {
            this.p2 && this.p2.update(),
            this.box2d && this.box2d.update(),
            this.matter && this.matter.update()
        },
        setBoundsToWorld: function() {
            this.arcade && this.arcade.setBoundsToWorld(),
            this.ninja && this.ninja.setBoundsToWorld(),
            this.p2 && this.p2.setBoundsToWorld(),
            this.box2d && this.box2d.setBoundsToWorld(),
            this.matter && this.matter.setBoundsToWorld()
        },
        clear: function() {
            this.p2 && this.p2.clear(),
            this.box2d && this.box2d.clear(),
            this.matter && this.matter.clear()
        },
        reset: function() {
            this.p2 && this.p2.reset(),
            this.box2d && this.box2d.reset(),
            this.matter && this.matter.reset()
        },
        destroy: function() {
            this.p2 && this.p2.destroy(),
            this.box2d && this.box2d.destroy(),
            this.matter && this.matter.destroy(),
            this.arcade = null,
            this.ninja = null,
            this.p2 = null,
            this.box2d = null,
            this.matter = null
        }
    },
    t.Physics.prototype.constructor = t.Physics,
    t.Physics.Arcade = function(e) {
        this.game = e,
        this.gravity = new t.Point,
        this.bounds = new t.Rectangle(0, 0, e.world.width, e.world.height),
        this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        },
        this.maxObjects = 10,
        this.maxLevels = 4,
        this.OVERLAP_BIAS = 4,
        this.forceX = !1,
        this.sortDirection = t.Physics.Arcade.LEFT_RIGHT,
        this.skipQuadTree = !0,
        this.isPaused = !1,
        this.quadTree = new t.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
        this._total = 0,
        this.setBoundsToWorld()
    },
    t.Physics.Arcade.prototype.constructor = t.Physics.Arcade,
    t.Physics.Arcade.SORT_NONE = 0,
    t.Physics.Arcade.LEFT_RIGHT = 1,
    t.Physics.Arcade.RIGHT_LEFT = 2,
    t.Physics.Arcade.TOP_BOTTOM = 3,
    t.Physics.Arcade.BOTTOM_TOP = 4,
    t.Physics.Arcade.prototype = {
        setBounds: function(t, e, i, s) {
            this.bounds.setTo(t, e, i, s)
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds)
        },
        enable: function(e, i) {
            void 0 === i && (i = !0);
            var s = 1;
            if (Array.isArray(e)) for (s = e.length; s--;) e[s] instanceof t.Group ? this.enable(e[s].children, i) : (this.enableBody(e[s]), i && e[s].hasOwnProperty("children") && e[s].children.length > 0 && this.enable(e[s], !0));
            else e instanceof t.Group ? this.enable(e.children, i) : (this.enableBody(e), i && e.hasOwnProperty("children") && e.children.length > 0 && this.enable(e.children, !0))
        },
        enableBody: function(e) {
            e.hasOwnProperty("body") && null === e.body && (e.body = new t.Physics.Arcade.Body(e), e.parent && e.parent instanceof t.Group && e.parent.addToHash(e))
        },
        updateMotion: function(t) {
            if (t.allowRotation) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e,
                t.rotation += t.angularVelocity * this.game.time.physicsElapsed
            }
            t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x),
            t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
        },
        computeVelocity: function(t, e, i, s, n, r) {
            return void 0 === r && (r = 1e4),
            1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed: 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed),
            s ? i += s * this.game.time.physicsElapsed: n && e.allowDrag && (i - (n *= this.game.time.physicsElapsed) > 0 ? i -= n: i + n < 0 ? i += n: i = 0),
            i > r ? i = r: i < -r && (i = -r),
            i
        },
        overlap: function(t, e, i, s, n) {
            return i = i || null,
            s = s || null,
            n = n || i,
            this._total = 0,
            this.collideObjects(t, e, i, s, n, !0),
            this._total > 0
        },
        collide: function(t, e, i, s, n) {
            return i = i || null,
            s = s || null,
            n = n || i,
            this._total = 0,
            this.collideObjects(t, e, i, s, n, !1),
            this._total > 0
        },
        sortLeftRight: function(t, e) {
            return t.body && e.body ? t.body.x - e.body.x: 0
        },
        sortRightLeft: function(t, e) {
            return t.body && e.body ? e.body.x - t.body.x: 0
        },
        sortTopBottom: function(t, e) {
            return t.body && e.body ? t.body.y - e.body.y: 0
        },
        sortBottomTop: function(t, e) {
            return t.body && e.body ? e.body.y - t.body.y: 0
        },
        sort: function(e, i) {
            null !== e.physicsSortDirection ? i = e.physicsSortDirection: void 0 === i && (i = this.sortDirection),
            i === t.Physics.Arcade.LEFT_RIGHT ? e.hash.sort(this.sortLeftRight) : i === t.Physics.Arcade.RIGHT_LEFT ? e.hash.sort(this.sortRightLeft) : i === t.Physics.Arcade.TOP_BOTTOM ? e.hash.sort(this.sortTopBottom) : i === t.Physics.Arcade.BOTTOM_TOP && e.hash.sort(this.sortBottomTop)
        },
        collideObjects: function(t, e, i, s, n, r) {
            if (!Array.isArray(t) && Array.isArray(e)) for (o = 0; o < e.length; o++) e[o] && this.collideHandler(t, e[o], i, s, n, r);
            else if (Array.isArray(t) && !Array.isArray(e)) for (o = 0; o < t.length; o++) t[o] && this.collideHandler(t[o], e, i, s, n, r);
            else if (Array.isArray(t) && Array.isArray(e)) {
                for (var o = 0; o < t.length; o++) if (t[o]) for (var a = 0; a < e.length; a++) e[a] && this.collideHandler(t[o], e[a], i, s, n, r)
            } else this.collideHandler(t, e, i, s, n, r)
        },
        collideHandler: function(e, i, s, n, r, o) {
            if (void 0 === i && e.physicsType === t.GROUP) return this.sort(e),
            void this.collideGroupVsSelf(e, s, n, r, o);
            e && i && e.exists && i.exists && (this.sortDirection !== t.Physics.Arcade.SORT_NONE && (e.physicsType === t.GROUP && this.sort(e), i.physicsType === t.GROUP && this.sort(i)), e.physicsType === t.SPRITE ? i.physicsType === t.SPRITE ? this.collideSpriteVsSprite(e, i, s, n, r, o) : i.physicsType === t.GROUP ? this.collideSpriteVsGroup(e, i, s, n, r, o) : i.physicsType === t.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(e, i, s, n, r, o) : e.physicsType === t.GROUP ? i.physicsType === t.SPRITE ? this.collideSpriteVsGroup(i, e, s, n, r, o) : i.physicsType === t.GROUP ? this.collideGroupVsGroup(e, i, s, n, r, o) : i.physicsType === t.TILEMAPLAYER && this.collideGroupVsTilemapLayer(e, i, s, n, r, o) : e.physicsType === t.TILEMAPLAYER && (i.physicsType === t.SPRITE ? this.collideSpriteVsTilemapLayer(i, e, s, n, r, o) : i.physicsType === t.GROUP && this.collideGroupVsTilemapLayer(i, e, s, n, r, o)))
        },
        collideSpriteVsSprite: function(t, e, i, s, n, r) {
            return ! (!t.body || !e.body || (this.separate(t.body, e.body, s, n, r) && (i && i.call(n, t, e), this._total++), 0))
        },
        collideSpriteVsGroup: function(e, i, s, n, r, o) {
            if (0 !== i.length && e.body) if (this.skipQuadTree || e.body.skipQuadTree) for (var a = {},
            h = 0; h < i.hash.length; h++) {
                var l = i.hash[h];
                if (l && l.exists && l.body) {
                    if (a = l.body.getBounds(a), this.sortDirection === t.Physics.Arcade.LEFT_RIGHT) {
                        if (e.body.right < a.x) break;
                        if (a.right < e.body.x) continue
                    } else if (this.sortDirection === t.Physics.Arcade.RIGHT_LEFT) {
                        if (e.body.x > a.right) break;
                        if (a.x > e.body.right) continue
                    } else if (this.sortDirection === t.Physics.Arcade.TOP_BOTTOM) {
                        if (e.body.bottom < a.y) break;
                        if (a.bottom < e.body.y) continue
                    } else if (this.sortDirection === t.Physics.Arcade.BOTTOM_TOP) {
                        if (e.body.y > a.bottom) break;
                        if (a.y > e.body.bottom) continue
                    }
                    this.collideSpriteVsSprite(e, l, s, n, r, o)
                }
            } else {
                this.quadTree.clear(),
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
                this.quadTree.populate(i);
                var c = this.quadTree.retrieve(e);
                for (h = 0; h < c.length; h++) this.separate(e.body, c[h], n, r, o) && (s && s.call(r, e, c[h].sprite), this._total++)
            }
        },
        collideGroupVsSelf: function(e, i, s, n, r) {
            if (0 !== e.length) for (var o = 0; o < e.hash.length; o++) {
                var a = {},
                h = e.hash[o];
                if (h && h.exists && h.body) {
                    a = h.body.getBounds(a);
                    for (var l = o + 1; l < e.hash.length; l++) {
                        var c = {},
                        u = e.hash[l];
                        if (u && u.exists && u.body) {
                            if (c = u.body.getBounds(c), this.sortDirection === t.Physics.Arcade.LEFT_RIGHT) {
                                if (a.right < c.x) break;
                                if (c.right < a.x) continue
                            } else if (this.sortDirection === t.Physics.Arcade.RIGHT_LEFT) {
                                if (a.x > c.right) continue;
                                if (c.x > a.right) break
                            } else if (this.sortDirection === t.Physics.Arcade.TOP_BOTTOM) {
                                if (a.bottom < c.y) continue;
                                if (c.bottom < a.y) break
                            } else if (this.sortDirection === t.Physics.Arcade.BOTTOM_TOP) {
                                if (a.y > c.bottom) continue;
                                if (c.y > h.body.bottom) break
                            }
                            this.collideSpriteVsSprite(h, u, i, s, n, r)
                        }
                    }
                }
            }
        },
        collideGroupVsGroup: function(e, i, s, n, r, o) {
            if (0 !== e.length && 0 !== i.length) for (var a = 0; a < e.children.length; a++) e.children[a].exists && (e.children[a].physicsType === t.GROUP ? this.collideGroupVsGroup(e.children[a], i, s, n, r, o) : this.collideSpriteVsGroup(e.children[a], i, s, n, r, o))
        },
        separate: function(t, e, i, s, n) {
            if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return ! 1;
            if (i && !1 === i.call(s, t.sprite, e.sprite)) return ! 1;
            if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n);
            if (t.isCircle !== e.isCircle) {
                var r = t.isCircle ? e: t,
                o = t.isCircle ? t: e,
                a = {
                    x: r.x,
                    y: r.y,
                    right: r.right,
                    bottom: r.bottom
                },
                h = o.center;
                if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, n)
            }
            var l = !1,
            c = !1;
            this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, n), this.intersects(t, e) && (c = this.separateY(t, e, n))) : (c = this.separateY(t, e, n), this.intersects(t, e) && (l = this.separateX(t, e, n)));
            var u = l || c;
            return u && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))),
            u
        },
        intersects: function(e, i) {
            return e !== i && (e.isCircle ? i.isCircle ? t.Math.distance(e.center.x, e.center.y, i.center.x, i.center.y) <= e.halfWidth + i.halfWidth: this.circleBodyIntersects(e, i) : i.isCircle ? this.circleBodyIntersects(i, e) : !(e.right <= i.position.x || e.bottom <= i.position.y || e.position.x >= i.right || e.position.y >= i.bottom))
        },
        circleBodyIntersects: function(e, i) {
            var s = t.Math.clamp(e.center.x, i.left, i.right),
            n = t.Math.clamp(e.center.y, i.top, i.bottom);
            return (e.center.x - s) * (e.center.x - s) + (e.center.y - n) * (e.center.y - n) <= e.halfWidth * e.halfWidth
        },
        separateCircle: function(e, i, s) {
            this.getOverlapX(e, i),
            this.getOverlapY(e, i);
            var n = i.center.x - e.center.x,
            r = i.center.y - e.center.y,
            o = Math.atan2(r, n),
            a = 0;
            if (e.isCircle !== i.isCircle) {
                var h = {
                    x: i.isCircle ? e.position.x: i.position.x,
                    y: i.isCircle ? e.position.y: i.position.y,
                    right: i.isCircle ? e.right: i.right,
                    bottom: i.isCircle ? e.bottom: i.bottom
                },
                l = {
                    x: e.isCircle ? e.center.x: i.center.x,
                    y: e.isCircle ? e.center.y: i.center.y,
                    radius: e.isCircle ? e.halfWidth: i.halfWidth
                };
                l.y < h.y ? l.x < h.x ? a = t.Math.distance(l.x, l.y, h.x, h.y) - l.radius: l.x > h.right && (a = t.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = t.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius: l.x > h.right && (a = t.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)),
                a *= -1
            } else a = e.halfWidth + i.halfWidth - t.Math.distance(e.center.x, e.center.y, i.center.x, i.center.y);
            if (s || 0 === a || e.immovable && i.immovable || e.customSeparateX || i.customSeparateX) return 0 !== a && (e.onOverlap && e.onOverlap.dispatch(e.sprite, i.sprite), i.onOverlap && i.onOverlap.dispatch(i.sprite, e.sprite)),
            0 !== a;
            var c = e.velocity.x * Math.cos(o) + e.velocity.y * Math.sin(o),
            u = -e.velocity.x * Math.sin(o) + e.velocity.y * Math.cos(o),
            d = i.velocity.x * Math.cos(o) + i.velocity.y * Math.sin(o),
            p = -i.velocity.x * Math.sin(o) + i.velocity.y * Math.cos(o),
            f = ((e.mass - i.mass) * c + 2 * i.mass * d) / (e.mass + i.mass),
            g = (2 * e.mass * c + (i.mass - e.mass) * d) / (e.mass + i.mass);
            return e.immovable || (e.velocity.x = (f * Math.cos(o) - u * Math.sin(o)) * e.bounce.x, e.velocity.y = (u * Math.cos(o) + f * Math.sin(o)) * e.bounce.y),
            i.immovable || (i.velocity.x = (g * Math.cos(o) - p * Math.sin(o)) * i.bounce.x, i.velocity.y = (p * Math.cos(o) + g * Math.sin(o)) * i.bounce.y),
            Math.abs(o) < Math.PI / 2 ? e.velocity.x > 0 && !e.immovable && i.velocity.x > e.velocity.x ? e.velocity.x *= -1 : i.velocity.x < 0 && !i.immovable && e.velocity.x < i.velocity.x ? i.velocity.x *= -1 : e.velocity.y > 0 && !e.immovable && i.velocity.y > e.velocity.y ? e.velocity.y *= -1 : i.velocity.y < 0 && !i.immovable && e.velocity.y < i.velocity.y && (i.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (e.velocity.x < 0 && !e.immovable && i.velocity.x < e.velocity.x ? e.velocity.x *= -1 : i.velocity.x > 0 && !i.immovable && e.velocity.x > i.velocity.x ? i.velocity.x *= -1 : e.velocity.y < 0 && !e.immovable && i.velocity.y < e.velocity.y ? e.velocity.y *= -1 : i.velocity.y > 0 && !i.immovable && e.velocity.x > i.velocity.y && (i.velocity.y *= -1)),
            e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed - a * Math.cos(o), e.y += e.velocity.y * this.game.time.physicsElapsed - a * Math.sin(o)),
            i.immovable || (i.x += i.velocity.x * this.game.time.physicsElapsed + a * Math.cos(o), i.y += i.velocity.y * this.game.time.physicsElapsed + a * Math.sin(o)),
            e.onCollide && e.onCollide.dispatch(e.sprite, i.sprite),
            i.onCollide && i.onCollide.dispatch(i.sprite, e.sprite),
            !0
        },
        getOverlapX: function(t, e, i) {
            var s = 0,
            n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
            return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (s = t.right - e.x) > n && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && ( - (s = t.x - e.width - e.x) > n && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)),
            t.overlapX = s,
            e.overlapX = s,
            s
        },
        getOverlapY: function(t, e, i) {
            var s = 0,
            n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
            return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (s = t.bottom - e.y) > n && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && ( - (s = t.y - e.bottom) > n && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)),
            t.overlapY = s,
            e.overlapY = s,
            s
        },
        separateX: function(t, e, i) {
            var s = this.getOverlapX(t, e, i);
            if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
            var n = t.velocity.x,
            r = e.velocity.x;
            if (t.immovable || e.immovable) t.immovable ? (e.x += s, e.velocity.x = n - r * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = r - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
            else {
                s *= .5,
                t.x -= s,
                e.x += s;
                var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                h = .5 * (o + a);
                o -= h,
                a -= h,
                t.velocity.x = h + o * t.bounce.x,
                e.velocity.x = h + a * e.bounce.x
            }
            return ! 0
        },
        separateY: function(t, e, i) {
            var s = this.getOverlapY(t, e, i);
            if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
            var n = t.velocity.y,
            r = e.velocity.y;
            if (t.immovable || e.immovable) t.immovable ? (e.y += s, e.velocity.y = n - r * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = r - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
            else {
                s *= .5,
                t.y -= s,
                e.y += s;
                var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                h = .5 * (o + a);
                o -= h,
                a -= h,
                t.velocity.y = h + o * t.bounce.y,
                e.velocity.y = h + a * e.bounce.y
            }
            return ! 0
        },
        getObjectsUnderPointer: function(t, e, i, s) {
            if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
        },
        getObjectsAtLocation: function(e, i, s, n, r, o) {
            this.quadTree.clear(),
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
            this.quadTree.populate(s);
            for (var a = new t.Rectangle(e, i, 1, 1), h = [], l = this.quadTree.retrieve(a), c = 0; c < l.length; c++) l[c].hitTest(e, i) && (n && n.call(r, o, l[c].sprite), h.push(l[c].sprite));
            return h
        },
        moveToObject: function(e, i, s, n) {
            void 0 === s && (s = 60),
            void 0 === n && (n = 0);
            var r = t.Point.angle(i, e);
            return n > 0 && (s = this.distanceBetween(e, i) / (n / 1e3)),
            e.body.velocity.setToPolar(r, s),
            r
        },
        moveToPointer: function(t, e, i, s) {
            void 0 === e && (e = 60),
            i = i || this.game.input.activePointer,
            void 0 === s && (s = 0);
            var n = this.angleToPointer(t, i);
            return s > 0 && (e = this.distanceToPointer(t, i) / (s / 1e3)),
            t.body.velocity.setToPolar(n, e),
            n
        },
        moveToXY: function(t, e, i, s, n) {
            void 0 === s && (s = 60),
            void 0 === n && (n = 0);
            var r = Math.atan2(i - t.y, e - t.x);
            return n > 0 && (s = this.distanceToXY(t, e, i) / (n / 1e3)),
            t.body.velocity.setToPolar(r, s),
            r
        },
        velocityFromAngle: function(e, i, s) {
            return void 0 === i && (i = 60),
            (s = s || new t.Point).setToPolar(e, i, !0)
        },
        velocityFromRotation: function(e, i, s) {
            return void 0 === i && (i = 60),
            (s = s || new t.Point).setToPolar(e, i)
        },
        accelerationFromRotation: function(e, i, s) {
            return void 0 === i && (i = 60),
            (s = s || new t.Point).setToPolar(e, i)
        },
        accelerateToObject: function(t, e, i, s, n) {
            void 0 === i && (i = 60),
            void 0 === s && (s = 1e3),
            void 0 === n && (n = 1e3);
            var r = this.angleBetween(t, e);
            return t.body.acceleration.setToPolar(r, i),
            t.body.maxVelocity.setTo(s, n),
            r
        },
        accelerateToPointer: function(t, e, i, s, n) {
            void 0 === i && (i = 60),
            void 0 === e && (e = this.game.input.activePointer),
            void 0 === s && (s = 1e3),
            void 0 === n && (n = 1e3);
            var r = this.angleToPointer(t, e);
            return t.body.acceleration.setToPolar(r, i),
            t.body.maxVelocity.setTo(s, n),
            r
        },
        accelerateToXY: function(t, e, i, s, n, r) {
            void 0 === s && (s = 60),
            void 0 === n && (n = 1e3),
            void 0 === r && (r = 1e3);
            var o = this.angleToXY(t, e, i);
            return t.body.acceleration.setTo(o, s),
            t.body.maxVelocity.setTo(n, r),
            o
        },
        distanceBetween: function(t, e, i, s) {
            var n, r;
            return void 0 === i && (i = !1),
            s ? (n = t.centerX - e.centerX, r = t.centerY - e.centerY) : i ? (n = t.world.x - e.world.x, r = t.world.y - e.world.y) : (n = t.x - e.x, r = t.y - e.y),
            Math.sqrt(n * n + r * r)
        },
        distanceToXY: function(t, e, i, s) {
            void 0 === s && (s = !1);
            var n = s ? t.world.x - e: t.x - e,
            r = s ? t.world.y - i: t.y - i;
            return Math.sqrt(n * n + r * r)
        },
        distanceToPointer: function(t, e, i) {
            void 0 === e && (e = this.game.input.activePointer),
            void 0 === i && (i = !1);
            var s = i ? t.world.x - e.worldX: t.x - e.worldX,
            n = i ? t.world.y - e.worldY: t.y - e.worldY;
            return Math.sqrt(s * s + n * n)
        },
        closest: function(t, e, i, s) {
            for (var n = 1 / 0,
            r = null,
            o = 0,
            a = e.length; o < a; o++) {
                var h = e[o],
                l = this.distanceBetween(t, h, i, s);
                l < n && (r = h, n = l)
            }
            return r
        },
        farthest: function(t, e, i, s) {
            for (var n = -1,
            r = null,
            o = 0,
            a = e.length; o < a; o++) {
                var h = e[o],
                l = this.distanceBetween(t, h, i, s);
                l > n && (r = h, n = l)
            }
            return r
        },
        angleBetween: function(e, i, s) {
            return void 0 === s && (s = !1),
            s ? t.Point.angle(i.world, e.world) : t.Point.angle(i, e)
        },
        angleBetweenCenters: function(t, e) {
            var i = e.centerX - t.centerX,
            s = e.centerY - t.centerY;
            return Math.atan2(s, i)
        },
        angleToXY: function(t, e, i, s) {
            return void 0 === s && (s = !1),
            s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
        },
        angleToPointer: function(t, e, i) {
            return void 0 === e && (e = this.game.input.activePointer),
            void 0 === i && (i = !1),
            i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
        },
        worldAngleToPointer: function(t, e) {
            return this.angleToPointer(t, e, !0)
        }
    },
    t.Physics.Arcade.Body = function(e) {
        this.sprite = e,
        this.game = e.game,
        this.type = t.Physics.ARCADE,
        this.enable = !0,
        this.isCircle = !1,
        this.radius = 0,
        this.offset = new t.Point,
        this.position = new t.Point(e.x, e.y),
        this.prev = new t.Point(this.position.x, this.position.y),
        this.allowRotation = !0,
        this.rotation = e.angle,
        this.preRotation = e.angle,
        this.width = e.width,
        this.height = e.height,
        this.sourceWidth = e.width,
        this.sourceHeight = e.height,
        e.texture && (this.sourceWidth = e.texture.frame.width, this.sourceHeight = e.texture.frame.height),
        this.halfWidth = Math.abs(e.width / 2),
        this.halfHeight = Math.abs(e.height / 2),
        this.center = new t.Point(e.x + this.halfWidth, e.y + this.halfHeight),
        this.velocity = new t.Point,
        this.newVelocity = new t.Point,
        this.deltaMax = new t.Point,
        this.acceleration = new t.Point,
        this.allowDrag = !0,
        this.drag = new t.Point,
        this.allowGravity = !0,
        this.gravity = new t.Point,
        this.bounce = new t.Point,
        this.worldBounce = null,
        this.onWorldBounds = null,
        this.onCollide = null,
        this.onOverlap = null,
        this.maxVelocity = new t.Point(1e4, 1e4),
        this.friction = new t.Point(1, 0),
        this.angularVelocity = 0,
        this.angularAcceleration = 0,
        this.angularDrag = 0,
        this.maxAngular = 1e3,
        this.mass = 1,
        this.angle = 0,
        this.speed = 0,
        this.facing = t.NONE,
        this.immovable = !1,
        this.moves = !0,
        this.customSeparateX = !1,
        this.customSeparateY = !1,
        this.overlapX = 0,
        this.overlapY = 0,
        this.overlapR = 0,
        this.embedded = !1,
        this.collideWorldBounds = !1,
        this.checkCollision = {
            none: !1,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        },
        this.touching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.blocked = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.tilePadding = new t.Point,
        this.dirty = !1,
        this.skipQuadTree = !1,
        this.syncBounds = !1,
        this.isMoving = !1,
        this.stopVelocityOnCollide = !0,
        this.moveTimer = 0,
        this.moveDistance = 0,
        this.moveDuration = 0,
        this.moveTarget = null,
        this.moveEnd = null,
        this.onMoveComplete = new t.Signal,
        this.movementCallback = null,
        this.movementCallbackContext = null,
        this._reset = !0,
        this._sx = e.scale.x,
        this._sy = e.scale.y,
        this._dx = 0,
        this._dy = 0
    },
    t.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            if (this.syncBounds) {
                var t = this.sprite.getBounds();
                t.ceilAll(),
                t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
            } else {
                var e = Math.abs(this.sprite.scale.x),
                i = Math.abs(this.sprite.scale.y);
                e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
            }
            this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter())
        },
        updateCenter: function() {
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        preUpdate: function() {
            this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.none = !0, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width: 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height: 0, this.updateCenter(), this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.updateCenter(), this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = this.velocity.atan()), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
        },
        updateMovement: function() {
            var t = 0,
            e = 0 !== this.overlapX || 0 !== this.overlapY;
            if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
            return ! (e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
        },
        stopMovement: function(t) {
            this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
        },
        postUpdate: function() {
            this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = t.LEFT: this.deltaX() > 0 && (this.facing = t.RIGHT), this.deltaY() < 0 ? this.facing = t.UP: this.deltaY() > 0 && (this.facing = t.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x: this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y: this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.updateCenter(), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
        },
        checkWorldBounds: function() {
            var t = this.position,
            e = this.game.physics.arcade.bounds,
            i = this.game.physics.arcade.checkCollision,
            s = this.worldBounce ? -this.worldBounce.x: -this.bounce.x,
            n = this.worldBounce ? -this.worldBounce.y: -this.bounce.y;
            return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= s, this.blocked.left = !0, this.blocked.none = !1) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= s, this.blocked.right = !0, this.blocked.none = !1),
            t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= n, this.blocked.up = !0, this.blocked.none = !1) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= n, this.blocked.down = !0, this.blocked.none = !1),
            !this.blocked.none
        },
        moveFrom: function(t, e, i) {
            return void 0 === e && (e = this.speed),
            0 !== e && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.setToPolar(s, e), this.isMoving = !0, !0);
            var s
        }, moveTo: function(e, i, s) {
            var n, r = i / (e / 1e3);
            return 0 !== r && (void 0 === s ? (n = this.angle, s = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(s), i = Math.abs(i), this.moveDuration = 0, this.moveDistance = i, null === this.moveTarget && (this.moveTarget = new t.Line, this.moveEnd = new t.Point), this.moveTarget.fromAngle(this.x, this.y, n, i), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === s || 180 === s ? this.velocity.set(Math.cos(n) * r, 0) : 90 === s || 270 === s ? this.velocity.set(0, Math.sin(n) * r) : this.velocity.setToPolar(n, r), this.isMoving = !0, !0)
        },
        setSize: function(t, e, i, s) {
            void 0 === i && (i = this.offset.x),
            void 0 === s && (s = this.offset.y),
            this.sourceWidth = t,
            this.sourceHeight = e,
            this.width = this.sourceWidth * this._sx,
            this.height = this.sourceHeight * this._sy,
            this.halfWidth = Math.floor(this.width / 2),
            this.halfHeight = Math.floor(this.height / 2),
            this.offset.setTo(i, s),
            this.updateCenter(),
            this.isCircle = !1,
            this.radius = 0
        },
        setCircle: function(t, e, i) {
            void 0 === e && (e = this.offset.x),
            void 0 === i && (i = this.offset.y),
            t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.updateCenter()) : this.isCircle = !1
        },
        reset: function(t, e) {
            this.stop(),
            this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x,
            this.position.x -= this.sprite.scale.x < 0 ? this.width: 0,
            this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y,
            this.position.y -= this.sprite.scale.y < 0 ? this.height: 0,
            this.prev.x = this.position.x,
            this.prev.y = this.position.y,
            this.rotation = this.sprite.angle,
            this.preRotation = this.rotation,
            this.updateBounds(),
            this.updateCenter()
        },
        stop: function() {
            this.velocity.set(0),
            this.acceleration.set(0),
            this.speed = 0,
            this.angularVelocity = 0,
            this.angularAcceleration = 0
        },
        getBounds: function(t) {
            return t.x = this.x,
            t.y = this.y,
            t.right = this.right,
            t.bottom = this.bottom,
            t
        },
        hitTest: function(e, i) {
            return this.isCircle ? t.Circle.contains(this, e, i) : t.Rectangle.contains(this, e, i)
        },
        onFloor: function() {
            return this.blocked.down
        },
        onCeiling: function() {
            return this.blocked.up
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
        },
        deltaX: function() {
            return this.position.x - this.prev.x
        },
        deltaY: function() {
            return this.position.y - this.prev.y
        },
        deltaZ: function() {
            return this.rotation - this.preRotation
        },
        destroy: function() {
            this.sprite.parent && this.sprite.parent instanceof t.Group && this.sprite.parent.removeFromHash(this.sprite),
            this.sprite.body = null,
            this.sprite = null
        }
    },
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "left", {
        get: function() {
            return this.position.x
        }
    }),
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width
        }
    }),
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "top", {
        get: function() {
            return this.position.y
        }
    }),
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height
        }
    }),
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(t) {
            this.position.x = t
        }
    }),
    Object.defineProperty(t.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(t) {
            this.position.y = t
        }
    }),
    t.Physics.Arcade.Body.render = function(t, e, i, s, n) {
        void 0 === s && (s = !0),
        i = i || "rgba(0,255,0,0.4)",
        t.fillStyle = i,
        t.strokeStyle = i,
        t.lineWidth = n || 1,
        e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.halfWidth, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
    },
    t.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
        t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height),
        t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)),
        t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)),
        t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)),
        t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down),
        t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
    },
    t.Physics.Arcade.Body.prototype.constructor = t.Physics.Arcade.Body,
    t.Physics.Arcade.TilemapCollision = function() {},
    t.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function(t, e, i, s, n, r) {
            if (t.body) {
                var o = e.getTiles(t.body.position.x - t.body.tilePadding.x - e.getTileOffsetX(), t.body.position.y - t.body.tilePadding.y - e.getTileOffsetY(), t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                if (0 !== o.length) for (var a = 0; a < o.length; a++) s ? s.call(n, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a]))
            }
        },
        collideGroupVsTilemapLayer: function(t, e, i, s, n, r) {
            if (0 !== t.length) for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, r)
        },
        separateTile: function(t, e, i, s, n) {
            if (!e.enable) return ! 1;
            var r = s.getTileOffsetX(),
            o = s.getTileOffsetY();
            if (!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return ! 1;
            if (n) return ! 0;
            if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return ! 1;
            if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return ! 1;
            if (! (i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return ! 1;
            var a = 0,
            h = 0,
            l = 0,
            c = 1;
            if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return ! 0; (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
            } else {
                if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return ! 0; (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, s))
            }
            return 0 !== a || 0 !== h
        },
        tileCheckX: function(t, e, i) {
            var s = 0,
            n = i.getTileOffsetX();
            return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (s = t.x - n - e.right) < -this.TILE_BIAS && (s = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (s = t.right - n - e.left) > this.TILE_BIAS && (s = 0),
            0 !== s && (t.customSeparateX ? t.overlapX = s: this.processTileSeparationX(t, s)),
            s
        },
        tileCheckY: function(t, e, i) {
            var s = 0,
            n = i.getTileOffsetY();
            return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (s = t.y - n - e.bottom) < -this.TILE_BIAS && (s = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (s = t.bottom - n - e.top) > this.TILE_BIAS && (s = 0),
            0 !== s && (t.customSeparateY ? t.overlapY = s: this.processTileSeparationY(t, s)),
            s
        },
        processTileSeparationX: function(t, e) {
            e < 0 ? (t.blocked.left = !0, t.blocked.none = !1) : e > 0 && (t.blocked.right = !0, t.blocked.none = !1),
            t.position.x -= e,
            0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
        },
        processTileSeparationY: function(t, e) {
            e < 0 ? (t.blocked.up = !0, t.blocked.none = !1) : e > 0 && (t.blocked.down = !0, t.blocked.none = !1),
            t.position.y -= e,
            0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
        }
    },
    t.Utils.mixinPrototype(t.Physics.Arcade.prototype, t.Physics.Arcade.TilemapCollision.prototype),
    p2.Body.prototype.parent = null,
    p2.Spring.prototype.parent = null,
    t.Physics.P2 = function(e, i) {
        this.game = e,
        void 0 === i ? i = {
            gravity: [0, 0],
            broadphase: new p2.SAPBroadphase
        }: (i.hasOwnProperty("gravity") || (i.gravity = [0, 0]), i.hasOwnProperty("broadphase") || (i.broadphase = new p2.SAPBroadphase)),
        this.config = i,
        this.world = new p2.World(this.config),
        this.frameRate = 1 / 60,
        this.useElapsedTime = !1,
        this.paused = !1,
        this.materials = [],
        this.gravity = new t.Physics.P2.InversePointProxy(this, this.world.gravity),
        this.walls = {
            left: null,
            right: null,
            top: null,
            bottom: null
        },
        this.onBodyAdded = new t.Signal,
        this.onBodyRemoved = new t.Signal,
        this.onSpringAdded = new t.Signal,
        this.onSpringRemoved = new t.Signal,
        this.onConstraintAdded = new t.Signal,
        this.onConstraintRemoved = new t.Signal,
        this.onContactMaterialAdded = new t.Signal,
        this.onContactMaterialRemoved = new t.Signal,
        this.postBroadphaseCallback = null,
        this.callbackContext = null,
        this.onBeginContact = new t.Signal,
        this.onEndContact = new t.Signal,
        i.hasOwnProperty("mpx") && i.hasOwnProperty("pxm") && i.hasOwnProperty("mpxi") && i.hasOwnProperty("pxmi") && (this.mpx = i.mpx, this.mpxi = i.mpxi, this.pxm = i.pxm, this.pxmi = i.pxmi),
        this.world.on("beginContact", this.beginContactHandler, this),
        this.world.on("endContact", this.endContactHandler, this),
        this.collisionGroups = [],
        this.nothingCollisionGroup = new t.Physics.P2.CollisionGroup(1),
        this.boundsCollisionGroup = new t.Physics.P2.CollisionGroup(2),
        this.everythingCollisionGroup = new t.Physics.P2.CollisionGroup(2147483648),
        this.boundsCollidesWith = [],
        this._toRemove = [],
        this._collisionGroupID = 2,
        this._boundsLeft = !0,
        this._boundsRight = !0,
        this._boundsTop = !0,
        this._boundsBottom = !0,
        this._boundsOwnGroup = !1,
        this.setBoundsToWorld(!0, !0, !0, !0, !1)
    },
    t.Physics.P2.prototype = {
        removeBodyNextStep: function(t) {
            this._toRemove.push(t)
        },
        preUpdate: function() {
            for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
            this._toRemove.length = 0
        },
        enable: function(e, i, s) {
            void 0 === i && (i = !1),
            void 0 === s && (s = !0);
            var n = 1;
            if (Array.isArray(e)) for (n = e.length; n--;) e[n] instanceof t.Group ? this.enable(e[n].children, i, s) : (this.enableBody(e[n], i), s && e[n].hasOwnProperty("children") && e[n].children.length > 0 && this.enable(e[n], i, !0));
            else e instanceof t.Group ? this.enable(e.children, i, s) : (this.enableBody(e, i), s && e.hasOwnProperty("children") && e.children.length > 0 && this.enable(e.children, i, !0))
        },
        enableBody: function(e, i) {
            e.hasOwnProperty("body") && null === e.body && (e.body = new t.Physics.P2.Body(this.game, e, e.x, e.y, 1), e.body.debug = i, void 0 !== e.anchor && e.anchor.set(.5))
        },
        setImpactEvents: function(t) {
            t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
        },
        setPostBroadphaseCallback: function(t, e) {
            this.postBroadphaseCallback = t,
            this.callbackContext = e,
            null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
        },
        postBroadphaseHandler: function(t) {
            if (this.postBroadphaseCallback && 0 !== t.pairs.length) for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
        },
        impactHandler: function(t) {
            if (t.bodyA.parent && t.bodyB.parent) {
                var e = t.bodyA.parent,
                i = t.bodyB.parent;
                e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB),
                i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA),
                e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB),
                i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
            }
        },
        beginContactHandler: function(t) {
            t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
        },
        endContactHandler: function(t) {
            t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
        },
        setBoundsToWorld: function(t, e, i, s, n) {
            this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
        },
        setWorldMaterial: function(t, e, i, s, n) {
            void 0 === e && (e = !0),
            void 0 === i && (i = !0),
            void 0 === s && (s = !0),
            void 0 === n && (n = !0),
            e && this.walls.left && (this.walls.left.shapes[0].material = t),
            i && this.walls.right && (this.walls.right.shapes[0].material = t),
            s && this.walls.top && (this.walls.top.shapes[0].material = t),
            n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
        },
        updateBoundsCollisionGroup: function(t) {
            void 0 === t && (t = !0);
            var e = t ? this.boundsCollisionGroup.mask: this.everythingCollisionGroup.mask;
            this.walls.left && (this.walls.left.shapes[0].collisionGroup = e),
            this.walls.right && (this.walls.right.shapes[0].collisionGroup = e),
            this.walls.top && (this.walls.top.shapes[0].collisionGroup = e),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e),
            this._boundsOwnGroup = t
        },
        setBounds: function(t, e, i, s, n, r, o, a, h) {
            void 0 === n && (n = this._boundsLeft),
            void 0 === r && (r = this._boundsRight),
            void 0 === o && (o = this._boundsTop),
            void 0 === a && (a = this._boundsBottom),
            void 0 === h && (h = this._boundsOwnGroup),
            this.setupWall(n, "left", t, e, 1.5707963267948966, h),
            this.setupWall(r, "right", t + i, e, -1.5707963267948966, h),
            this.setupWall(o, "top", t, e, -3.141592653589793, h),
            this.setupWall(a, "bottom", t, e + s, 0, h),
            this._boundsLeft = n,
            this._boundsRight = r,
            this._boundsTop = o,
            this._boundsBottom = a,
            this._boundsOwnGroup = h
        },
        setupWall: function(t, e, i, s, n, r) {
            t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                mass: 0,
                position: [this.pxmi(i), this.pxmi(s)],
                angle: n
            }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), r && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
        },
        pause: function() {
            this.paused = !0
        },
        resume: function() {
            this.paused = !1
        },
        update: function() {
            this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
        },
        reset: function() {
            this.world.on("beginContact", this.beginContactHandler, this),
            this.world.on("endContact", this.endContactHandler, this),
            this.nothingCollisionGroup = new t.Physics.P2.CollisionGroup(1),
            this.boundsCollisionGroup = new t.Physics.P2.CollisionGroup(2),
            this.everythingCollisionGroup = new t.Physics.P2.CollisionGroup(2147483648),
            this._collisionGroupID = 2,
            this.setBoundsToWorld(!0, !0, !0, !0, !1)
        },
        clear: function() {
            this.world.time = 0,
            this.world.fixedStepTime = 0,
            this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
            for (var t = this.world.constraints,
            e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]);
            var i = this.world.bodies;
            for (e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]);
            var s = this.world.springs;
            for (e = s.length - 1; e >= 0; e--) this.world.removeSpring(s[e]);
            var n = this.world.contactMaterials;
            for (e = n.length - 1; e >= 0; e--) this.world.removeContactMaterial(n[e]);
            this.world.off("beginContact", this.beginContactHandler, this),
            this.world.off("endContact", this.endContactHandler, this),
            this.postBroadphaseCallback = null,
            this.callbackContext = null,
            this.impactCallback = null,
            this.collisionGroups = [],
            this._toRemove = [],
            this.boundsCollidesWith = [],
            this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }
        },
        destroy: function() {
            this.clear(),
            this.game = null
        },
        addBody: function(t) {
            return ! t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
        },
        removeBody: function(t) {
            return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)),
            t
        },
        addSpring: function(e) {
            return e instanceof t.Physics.P2.Spring || e instanceof t.Physics.P2.RotationalSpring ? this.world.addSpring(e.data) : this.world.addSpring(e),
            this.onSpringAdded.dispatch(e),
            e
        },
        removeSpring: function(e) {
            return e instanceof t.Physics.P2.Spring || e instanceof t.Physics.P2.RotationalSpring ? this.world.removeSpring(e.data) : this.world.removeSpring(e),
            this.onSpringRemoved.dispatch(e),
            e
        },
        createDistanceConstraint: function(e, i, s, n, r, o) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.DistanceConstraint(this, e, i, s, n, r, o));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createGearConstraint: function(e, i, s, n) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.GearConstraint(this, e, i, s, n));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createRevoluteConstraint: function(e, i, s, n, r, o) {
            if (e = this.getBody(e), s = this.getBody(s), e && s) return this.addConstraint(new t.Physics.P2.RevoluteConstraint(this, e, i, s, n, r, o));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createLockConstraint: function(e, i, s, n, r) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.LockConstraint(this, e, i, s, n, r));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createPrismaticConstraint: function(e, i, s, n, r, o, a) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.PrismaticConstraint(this, e, i, s, n, r, o, a));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        addConstraint: function(t) {
            return this.world.addConstraint(t),
            this.onConstraintAdded.dispatch(t),
            t
        },
        removeConstraint: function(t) {
            return this.world.removeConstraint(t),
            this.onConstraintRemoved.dispatch(t),
            t
        },
        addContactMaterial: function(t) {
            return this.world.addContactMaterial(t),
            this.onContactMaterialAdded.dispatch(t),
            t
        },
        removeContactMaterial: function(t) {
            return this.world.removeContactMaterial(t),
            this.onContactMaterialRemoved.dispatch(t),
            t
        },
        getContactMaterial: function(t, e) {
            return this.world.getContactMaterial(t, e)
        },
        setMaterial: function(t, e) {
            for (var i = e.length; i--;) e[i].setMaterial(t)
        },
        createMaterial: function(e, i) {
            e = e || "";
            var s = new t.Physics.P2.Material(e);
            return this.materials.push(s),
            void 0 !== i && i.setMaterial(s),
            s
        },
        createContactMaterial: function(e, i, s) {
            void 0 === e && (e = this.createMaterial()),
            void 0 === i && (i = this.createMaterial());
            var n = new t.Physics.P2.ContactMaterial(e, i, s);
            return this.addContactMaterial(n)
        },
        getBodies: function() {
            for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
            return t
        },
        getBody: function(e) {
            return e instanceof p2.Body ? e: e instanceof t.Physics.P2.Body ? e.data: e.body && e.body.type === t.Physics.P2JS ? e.body.data: null
        },
        getSprings: function() {
            for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
            return t
        },
        getConstraints: function() {
            for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
            return t
        },
        hitTest: function(e, i, s, n) {
            void 0 === i && (i = this.world.bodies),
            void 0 === s && (s = 5),
            void 0 === n && (n = !1);
            for (var r = [this.pxmi(e.x), this.pxmi(e.y)], o = [], a = i.length; a--;) i[a] instanceof t.Physics.P2.Body && (!n || i[a].data.type !== p2.Body.STATIC) ? o.push(i[a].data) : i[a] instanceof p2.Body && i[a].parent && (!n || i[a].type !== p2.Body.STATIC) ? o.push(i[a]) : i[a] instanceof t.Sprite && i[a].hasOwnProperty("body") && (!n || i[a].body.data.type !== p2.Body.STATIC) && o.push(i[a].body.data);
            return this.world.hitTest(r, o, s)
        },
        toJSON: function() {
            return this.world.toJSON()
        },
        createCollisionGroup: function(e) {
            var i = Math.pow(2, this._collisionGroupID);
            this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | i),
            this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | i),
            this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | i),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | i),
            this._collisionGroupID++;
            var s = new t.Physics.P2.CollisionGroup(i);
            return this.collisionGroups.push(s),
            e && this.setCollisionGroup(e, s),
            s
        },
        setCollisionGroup: function(e, i) {
            if (e instanceof t.Group) for (var s = 0; s < e.total; s++) e.children[s].body && e.children[s].body.type === t.Physics.P2JS && e.children[s].body.setCollisionGroup(i);
            else e.body.setCollisionGroup(i)
        },
        createSpring: function(e, i, s, n, r, o, a, h, l) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addSpring(new t.Physics.P2.Spring(this, e, i, s, n, r, o, a, h, l));
            console.warn("Cannot create Spring, invalid body objects given")
        },
        createRotationalSpring: function(e, i, s, n, r) {
            if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addSpring(new t.Physics.P2.RotationalSpring(this, e, i, s, n, r));
            console.warn("Cannot create Rotational Spring, invalid body objects given")
        },
        createBody: function(e, i, s, n, r, o) {
            void 0 === n && (n = !1);
            var a = new t.Physics.P2.Body(this.game, null, e, i, s);
            return ! (o && !a.addPolygon(r, o)) && (n && this.world.addBody(a.data), a)
        },
        createParticle: function(e, i, s, n, r, o) {
            void 0 === n && (n = !1);
            var a = new t.Physics.P2.Body(this.game, null, e, i, s);
            return ! (o && !a.addPolygon(r, o)) && (n && this.world.addBody(a.data), a)
        },
        convertCollisionObjects: function(t, e, i) {
            void 0 === i && (i = !0);
            for (var s = [], n = 0, r = t.collision[e].length; n < r; n++) {
                var o = t.collision[e][n],
                a = o.polyline || o.polygon;
                if (a) var h = this.createBody(o.x, o.y, 0, i, {},
                a);
                else o.rectangle && (h = this.createBody(o.x, o.y, 0, i)).addRectangle(o.width, o.height, o.width / 2, o.height / 2);
                h && s.push(h)
            }
            return s
        },
        clearTilemapLayerBodies: function(t, e) {
            e = t.getLayer(e);
            for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
            t.layers[e].bodies.length = 0
        },
        convertTilemap: function(t, e, i, s) {
            e = t.getLayer(e),
            void 0 === i && (i = !0),
            void 0 === s && (s = !0),
            this.clearTilemapLayerBodies(t, e);
            for (var n = 0,
            r = 0,
            o = 0,
            a = 0,
            h = t.layers[e].height; a < h; a++) {
                n = 0;
                for (var l = 0,
                c = t.layers[e].width; l < c; l++) {
                    var u = t.layers[e].data[a][l];
                    if (u && u.index > -1 && u.collides) if (s) {
                        var d = t.getTileRight(e, l, a);
                        0 === n && (r = u.x * u.width, o = u.y * u.height, n = u.width),
                        d && d.collides ? n += u.width: ((p = this.createBody(r, o, 0, !1)).addRectangle(n, u.height, n / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0)
                    } else {
                        var p = this.createBody(u.x * u.width, u.y * u.height, 0, !1);
                        p.addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0),
                        i && this.addBody(p),
                        t.layers[e].bodies.push(p)
                    }
                }
            }
            return t.layers[e].bodies
        },
        mpx: function(t) {
            return 20 * t
        },
        pxm: function(t) {
            return.05 * t
        },
        mpxi: function(t) {
            return - 20 * t
        },
        pxmi: function(t) {
            return - .05 * t
        }
    },
    Object.defineProperty(t.Physics.P2.prototype, "friction", {
        get: function() {
            return this.world.defaultContactMaterial.friction
        },
        set: function(t) {
            this.world.defaultContactMaterial.friction = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "restitution", {
        get: function() {
            return this.world.defaultContactMaterial.restitution
        },
        set: function(t) {
            this.world.defaultContactMaterial.restitution = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "contactMaterial", {
        get: function() {
            return this.world.defaultContactMaterial
        },
        set: function(t) {
            this.world.defaultContactMaterial = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "applySpringForces", {
        get: function() {
            return this.world.applySpringForces
        },
        set: function(t) {
            this.world.applySpringForces = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "applyDamping", {
        get: function() {
            return this.world.applyDamping
        },
        set: function(t) {
            this.world.applyDamping = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "applyGravity", {
        get: function() {
            return this.world.applyGravity
        },
        set: function(t) {
            this.world.applyGravity = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "solveConstraints", {
        get: function() {
            return this.world.solveConstraints
        },
        set: function(t) {
            this.world.solveConstraints = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "time", {
        get: function() {
            return this.world.time
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "emitImpactEvent", {
        get: function() {
            return this.world.emitImpactEvent
        },
        set: function(t) {
            this.world.emitImpactEvent = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "sleepMode", {
        get: function() {
            return this.world.sleepMode
        },
        set: function(t) {
            this.world.sleepMode = t
        }
    }),
    Object.defineProperty(t.Physics.P2.prototype, "total", {
        get: function() {
            return this.world.bodies.length
        }
    }),
    t.Physics.P2.FixtureList = function(t) {
        Array.isArray(t) || (t = [t]),
        this.rawList = t,
        this.init(),
        this.parse(this.rawList)
    },
    t.Physics.P2.FixtureList.prototype = {
        init: function() {
            this.namedFixtures = {},
            this.groupedFixtures = [],
            this.allFixtures = []
        },
        setCategory: function(t, e) {
            this.getFixtures(e).forEach(function(e) {
                e.collisionGroup = t
            })
        },
        setMask: function(t, e) {
            this.getFixtures(e).forEach(function(e) {
                e.collisionMask = t
            })
        },
        setSensor: function(t, e) {
            this.getFixtures(e).forEach(function(e) {
                e.sensor = t
            })
        },
        setMaterial: function(t, e) {
            this.getFixtures(e).forEach(function(e) {
                e.material = t
            })
        },
        getFixtures: function(t) {
            var e = [];
            if (t) {
                t instanceof Array || (t = [t]);
                var i = this;
                return t.forEach(function(t) {
                    i.namedFixtures[t] && e.push(i.namedFixtures[t])
                }),
                this.flatten(e)
            }
            return this.allFixtures
        },
        getFixtureByKey: function(t) {
            return this.namedFixtures[t]
        },
        getGroup: function(t) {
            return this.groupedFixtures[t]
        },
        parse: function() {
            var t, e, i, s;
            for (t in s = [], i = this.rawList) e = i[t],
            isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)),
            s.push(this.allFixtures = this.flatten(this.groupedFixtures))
        },
        flatten: function(t) {
            var e, i;
            return e = [],
            i = arguments.callee,
            t.forEach(function(t) {
                return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
            }),
            e
        }
    },
    t.Physics.P2.PointProxy = function(t, e) {
        this.world = t,
        this.destination = e
    },
    t.Physics.P2.PointProxy.prototype.constructor = t.Physics.P2.PointProxy,
    Object.defineProperty(t.Physics.P2.PointProxy.prototype, "x", {
        get: function() {
            return this.world.mpx(this.destination[0])
        },
        set: function(t) {
            this.destination[0] = this.world.pxm(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.PointProxy.prototype, "y", {
        get: function() {
            return this.world.mpx(this.destination[1])
        },
        set: function(t) {
            this.destination[1] = this.world.pxm(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.PointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0]
        },
        set: function(t) {
            this.destination[0] = t
        }
    }),
    Object.defineProperty(t.Physics.P2.PointProxy.prototype, "my", {
        get: function() {
            return this.destination[1]
        },
        set: function(t) {
            this.destination[1] = t
        }
    }),
    t.Physics.P2.InversePointProxy = function(t, e) {
        this.world = t,
        this.destination = e
    },
    t.Physics.P2.InversePointProxy.prototype.constructor = t.Physics.P2.InversePointProxy,
    Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.destination[0])
        },
        set: function(t) {
            this.destination[0] = this.world.pxmi(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.destination[1])
        },
        set: function(t) {
            this.destination[1] = this.world.pxmi(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0]
        },
        set: function(t) {
            this.destination[0] = -t
        }
    }),
    Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "my", {
        get: function() {
            return this.destination[1]
        },
        set: function(t) {
            this.destination[1] = -t
        }
    }),
    t.Physics.P2.Body = function(e, i, s, n, r) {
        i = i || null,
        s = s || 0,
        n = n || 0,
        void 0 === r && (r = 1),
        this.game = e,
        this.world = e.physics.p2,
        this.sprite = i,
        this.type = t.Physics.P2JS,
        this.offset = new t.Point,
        this.data = new p2.Body({
            position: [this.world.pxmi(s), this.world.pxmi(n)],
            mass: r
        }),
        this.data.parent = this,
        this.velocity = new t.Physics.P2.InversePointProxy(this.world, this.data.velocity),
        this.force = new t.Physics.P2.InversePointProxy(this.world, this.data.force),
        this.gravity = new t.Point,
        this.onBeginContact = new t.Signal,
        this.onEndContact = new t.Signal,
        this.collidesWith = [],
        this.removeNextStep = !1,
        this.debugBody = null,
        this.dirty = !1,
        this._collideWorldBounds = !0,
        this._bodyCallbacks = {},
        this._bodyCallbackContext = {},
        this._groupCallbacks = {},
        this._groupCallbackContext = {},
        this._reset = !1,
        i && (this.setRectangleFromSprite(i), i.exists && this.game.physics.p2.addBody(this))
    },
    t.Physics.P2.Body.prototype = {
        createBodyCallback: function(t, e, i) {
            var s = -1;
            t.id ? s = t.id: t.body && (s = t.body.id),
            s > -1 && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
        },
        createGroupCallback: function(t, e, i) {
            null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
        },
        getCollisionMask: function() {
            var t = 0;
            this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
            for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
            return t
        },
        updateCollisionMask: function(t) {
            var e = this.getCollisionMask();
            if (void 0 === t) for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
            else t.collisionMask = e
        },
        setCollisionGroup: function(t, e) {
            var i = this.getCollisionMask();
            if (void 0 === e) for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionGroup = t.mask,
            this.data.shapes[s].collisionMask = i;
            else e.collisionGroup = t.mask,
            e.collisionMask = i
        },
        clearCollision: function(t, e, i) {
            if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i) for (var s = this.data.shapes.length - 1; s >= 0; s--) t && (this.data.shapes[s].collisionGroup = null),
            e && (this.data.shapes[s].collisionMask = null);
            else t && (i.collisionGroup = null),
            e && (i.collisionMask = null);
            t && (this.collidesWith.length = 0)
        },
        removeCollisionGroup: function(t, e, i) {
            var s;
            if (void 0 === e && (e = !0), Array.isArray(t)) for (r = 0; r < t.length; r++)(s = this.collidesWith.indexOf(t[r])) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
            else(s = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
            var n = this.getCollisionMask();
            if (void 0 === i) for (var r = this.data.shapes.length - 1; r >= 0; r--) this.data.shapes[r].collisionMask = n;
            else i.collisionMask = n
        },
        collides: function(t, e, i, s) {
            if (Array.isArray(t)) for (r = 0; r < t.length; r++) - 1 === this.collidesWith.indexOf(t[r]) && (this.collidesWith.push(t[r]), e && this.createGroupCallback(t[r], e, i));
            else - 1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
            var n = this.getCollisionMask();
            if (void 0 === s) for (var r = this.data.shapes.length - 1; r >= 0; r--) this.data.shapes[r].collisionMask = n;
            else s.collisionMask = n
        },
        adjustCenterOfMass: function() {
            this.data.adjustCenterOfMass(),
            this.shapeChanged()
        },
        getVelocityAtPoint: function(t, e) {
            return this.data.getVelocityAtPoint(t, e)
        },
        applyDamping: function(t) {
            this.data.applyDamping(t)
        },
        applyImpulse: function(t, e, i) {
            this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
        },
        applyImpulseLocal: function(t, e, i) {
            this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
        },
        applyForce: function(t, e, i) {
            this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
        },
        setZeroForce: function() {
            this.data.setZeroForce()
        },
        setZeroRotation: function() {
            this.data.angularVelocity = 0
        },
        setZeroVelocity: function() {
            this.data.velocity[0] = 0,
            this.data.velocity[1] = 0
        },
        setZeroDamping: function() {
            this.data.damping = 0,
            this.data.angularDamping = 0
        },
        toLocalFrame: function(t, e) {
            return this.data.toLocalFrame(t, e)
        },
        toWorldFrame: function(t, e) {
            return this.data.toWorldFrame(t, e)
        },
        rotateLeft: function(t) {
            this.data.angularVelocity = this.world.pxm( - t)
        },
        rotateRight: function(t) {
            this.data.angularVelocity = this.world.pxm(t)
        },
        moveForward: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = e * Math.cos(i),
            this.data.velocity[1] = e * Math.sin(i)
        },
        moveBackward: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = -e * Math.cos(i),
            this.data.velocity[1] = -e * Math.sin(i)
        },
        thrust: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle + Math.PI / 2;
            this.data.force[0] += e * Math.cos(i),
            this.data.force[1] += e * Math.sin(i)
        },
        thrustLeft: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle;
            this.data.force[0] += e * Math.cos(i),
            this.data.force[1] += e * Math.sin(i)
        },
        thrustRight: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle;
            this.data.force[0] -= e * Math.cos(i),
            this.data.force[1] -= e * Math.sin(i)
        },
        reverse: function(t) {
            var e = this.world.pxmi( - t),
            i = this.data.angle + Math.PI / 2;
            this.data.force[0] -= e * Math.cos(i),
            this.data.force[1] -= e * Math.sin(i)
        },
        moveLeft: function(t) {
            this.data.velocity[0] = this.world.pxmi( - t)
        },
        moveRight: function(t) {
            this.data.velocity[0] = this.world.pxmi(t)
        },
        moveUp: function(t) {
            this.data.velocity[1] = this.world.pxmi( - t)
        },
        moveDown: function(t) {
            this.data.velocity[1] = this.world.pxmi(t)
        },
        preUpdate: function() {
            this.dirty = !0,
            this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
        },
        postUpdate: function() {
            this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x,
            this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y,
            this.fixedRotation || (this.sprite.rotation = this.data.angle),
            this.debugBody && this.debugBody.updateSpriteTransform(),
            this.dirty = !1
        },
        reset: function(t, e, i, s) {
            void 0 === i && (i = !1),
            void 0 === s && (s = !1),
            this.setZeroForce(),
            this.setZeroVelocity(),
            this.setZeroRotation(),
            i && this.setZeroDamping(),
            s && (this.mass = 1),
            this.x = t,
            this.y = e
        },
        addToWorld: function() {
            if (this.game.physics.p2._toRemove) for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
            this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
        },
        removeFromWorld: function() {
            this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
        },
        destroy: function() {
            this.removeFromWorld(),
            this.clearShapes(),
            this._bodyCallbacks = {},
            this._bodyCallbackContext = {},
            this._groupCallbacks = {},
            this._groupCallbackContext = {},
            this.debugBody && this.debugBody.destroy(!0, !0),
            this.debugBody = null,
            this.sprite && (this.sprite.body = null, this.sprite = null)
        },
        clearShapes: function() {
            for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
            this.shapeChanged()
        },
        addShape: function(t, e, i, s) {
            return void 0 === e && (e = 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = 0),
            this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s),
            this.shapeChanged(),
            t
        },
        addCircle: function(t, e, i, s) {
            var n = new p2.Circle({
                radius: this.world.pxm(t)
            });
            return this.addShape(n, e, i, s)
        },
        addRectangle: function(t, e, i, s, n) {
            var r = new p2.Box({
                width: this.world.pxm(t),
                height: this.world.pxm(e)
            });
            return this.addShape(r, i, s, n)
        },
        addPlane: function(t, e, i) {
            var s = new p2.Plane;
            return this.addShape(s, t, e, i)
        },
        addParticle: function(t, e, i) {
            var s = new p2.Particle;
            return this.addShape(s, t, e, i)
        },
        addLine: function(t, e, i, s) {
            var n = new p2.Line({
                length: this.world.pxm(t)
            });
            return this.addShape(n, e, i, s)
        },
        addCapsule: function(t, e, i, s, n) {
            var r = new p2.Capsule({
                length: this.world.pxm(t),
                radius: this.world.pxm(e)
            });
            return this.addShape(r, i, s, n)
        },
        addPolygon: function(t, e) {
            t = t || {},
            Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
            var i = [];
            if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
            else if (Array.isArray(e[0])) i = e.slice();
            else if ("number" == typeof e[0]) for (var s = 0,
            n = e.length; s < n; s += 2) i.push([e[s], e[s + 1]]);
            var r = i.length - 1;
            i[r][0] === i[0][0] && i[r][1] === i[0][1] && i.pop();
            for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]),
            i[o][1] = this.world.pxmi(i[o][1]);
            var a = this.data.fromPolygon(i, t);
            return this.shapeChanged(),
            a
        },
        removeShape: function(t) {
            var e = this.data.removeShape(t);
            return this.shapeChanged(),
            e
        },
        setCircle: function(t, e, i, s) {
            return this.clearShapes(),
            this.addCircle(t, e, i, s)
        },
        setRectangle: function(t, e, i, s, n) {
            return void 0 === t && (t = 16),
            void 0 === e && (e = 16),
            this.clearShapes(),
            this.addRectangle(t, e, i, s, n)
        },
        setRectangleFromSprite: function(t) {
            return void 0 === t && (t = this.sprite),
            this.clearShapes(),
            this.addRectangle(t.width, t.height, 0, 0, t.rotation)
        },
        setMaterial: function(t, e) {
            if (void 0 === e) for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
            else e.material = t
        },
        shapeChanged: function() {
            this.debugBody && this.debugBody.draw()
        },
        addPhaserPolygon: function(t, e) {
            for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                var r = i[n],
                o = this.addFixture(r);
                s[r.filter.group] = s[r.filter.group] || [],
                s[r.filter.group] = s[r.filter.group].concat(o),
                r.fixtureKey && (s[r.fixtureKey] = o)
            }
            return this.data.aabbNeedsUpdate = !0,
            this.shapeChanged(),
            s
        },
        addFixture: function(t) {
            var e = [];
            if (t.circle) { (l = new p2.Circle({
                    radius: this.world.pxm(t.circle.radius)
                })).collisionGroup = t.filter.categoryBits,
                l.collisionMask = t.filter.maskBits,
                l.sensor = t.isSensor;
                var i = p2.vec2.create();
                i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2),
                i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2),
                this.data.addShape(l, i),
                e.push(l)
            } else for (var s = t.polygons,
            n = p2.vec2.create(), r = 0; r < s.length; r++) {
                for (var o = s[r], a = [], h = 0; h < o.length; h += 2) a.push([this.world.pxmi(o[h]), this.world.pxmi(o[h + 1])]);
                for (var l = new p2.Convex({
                    vertices: a
                }), c = 0; c !== l.vertices.length; c++) {
                    var u = l.vertices[c];
                    p2.vec2.sub(u, u, l.centerOfMass)
                }
                p2.vec2.scale(n, l.centerOfMass, 1),
                n[0] -= this.world.pxmi(this.sprite.width / 2),
                n[1] -= this.world.pxmi(this.sprite.height / 2),
                l.updateTriangles(),
                l.updateCenterOfMass(),
                l.updateBoundingRadius(),
                l.collisionGroup = t.filter.categoryBits,
                l.collisionMask = t.filter.maskBits,
                l.sensor = t.isSensor,
                this.data.addShape(l, n),
                e.push(l)
            }
            return e
        },
        loadPolygon: function(t, e, i) {
            if (null === t) s = e;
            else var s = this.game.cache.getPhysicsData(t, e);
            "number" != typeof i && (i = 1);
            for (var n = p2.vec2.create(), r = 0; r < s.length; r++) {
                for (var o = [], a = 0; a < s[r].shape.length; a += 2) o.push([this.world.pxmi(s[r].shape[a] * i), this.world.pxmi(s[r].shape[a + 1] * i)]);
                for (var h = new p2.Convex({
                    vertices: o
                }), l = 0; l !== h.vertices.length; l++) {
                    var c = h.vertices[l];
                    p2.vec2.sub(c, c, h.centerOfMass)
                }
                p2.vec2.scale(n, h.centerOfMass, 1),
                n[0] -= this.world.pxmi(this.sprite.width / 2),
                n[1] -= this.world.pxmi(this.sprite.height / 2),
                h.updateTriangles(),
                h.updateCenterOfMass(),
                h.updateBoundingRadius(),
                this.data.addShape(h, n)
            }
            return this.data.aabbNeedsUpdate = !0,
            this.shapeChanged(),
            !0
        }
    },
    t.Physics.P2.Body.prototype.constructor = t.Physics.P2.Body,
    t.Physics.P2.Body.DYNAMIC = 1,
    t.Physics.P2.Body.STATIC = 2,
    t.Physics.P2.Body.KINEMATIC = 4,
    Object.defineProperty(t.Physics.P2.Body.prototype, "static", {
        get: function() {
            return this.data.type === t.Physics.P2.Body.STATIC
        },
        set: function(e) {
            e && this.data.type !== t.Physics.P2.Body.STATIC ? (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0) : e || this.data.type !== t.Physics.P2.Body.STATIC || (this.data.type = t.Physics.P2.Body.DYNAMIC, this.mass = 1)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "dynamic", {
        get: function() {
            return this.data.type === t.Physics.P2.Body.DYNAMIC
        },
        set: function(e) {
            e && this.data.type !== t.Physics.P2.Body.DYNAMIC ? (this.data.type = t.Physics.P2.Body.DYNAMIC, this.mass = 1) : e || this.data.type !== t.Physics.P2.Body.DYNAMIC || (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "kinematic", {
        get: function() {
            return this.data.type === t.Physics.P2.Body.KINEMATIC
        },
        set: function(e) {
            e && this.data.type !== t.Physics.P2.Body.KINEMATIC ? (this.data.type = t.Physics.P2.Body.KINEMATIC, this.mass = 4) : e || this.data.type !== t.Physics.P2.Body.KINEMATIC || (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "allowSleep", {
        get: function() {
            return this.data.allowSleep
        },
        set: function(t) {
            t !== this.data.allowSleep && (this.data.allowSleep = t)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "angle", {
        get: function() {
            return t.Math.wrapAngle(t.Math.radToDeg(this.data.angle))
        },
        set: function(e) {
            this.data.angle = t.Math.degToRad(t.Math.wrapAngle(e))
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "angularDamping", {
        get: function() {
            return this.data.angularDamping
        },
        set: function(t) {
            this.data.angularDamping = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "angularForce", {
        get: function() {
            return this.data.angularForce
        },
        set: function(t) {
            this.data.angularForce = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "angularVelocity", {
        get: function() {
            return this.data.angularVelocity
        },
        set: function(t) {
            this.data.angularVelocity = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "damping", {
        get: function() {
            return this.data.damping
        },
        set: function(t) {
            this.data.damping = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "fixedRotation", {
        get: function() {
            return this.data.fixedRotation
        },
        set: function(t) {
            t !== this.data.fixedRotation && (this.data.fixedRotation = t)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "inertia", {
        get: function() {
            return this.data.inertia
        },
        set: function(t) {
            this.data.inertia = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "mass", {
        get: function() {
            return this.data.mass
        },
        set: function(t) {
            t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "motionState", {
        get: function() {
            return this.data.type
        },
        set: function(t) {
            t !== this.data.type && (this.data.type = t)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "rotation", {
        get: function() {
            return this.data.angle
        },
        set: function(t) {
            this.data.angle = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function() {
            return this.data.sleepSpeedLimit
        },
        set: function(t) {
            this.data.sleepSpeedLimit = t
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.data.position[0])
        },
        set: function(t) {
            this.data.position[0] = this.world.pxmi(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.data.position[1])
        },
        set: function(t) {
            this.data.position[1] = this.world.pxmi(t)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "id", {
        get: function() {
            return this.data.id
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "debug", {
        get: function() {
            return null !== this.debugBody
        },
        set: function(e) {
            e && !this.debugBody ? this.debugBody = new t.Physics.P2.BodyDebug(this.game, this.data) : !e && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
        }
    }),
    Object.defineProperty(t.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function() {
            return this._collideWorldBounds
        },
        set: function(t) {
            t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
        }
    }),
    t.Physics.P2.BodyDebug = function(e, i, s) {
        t.Group.call(this, e);
        var n = {
            pixelsPerLengthUnit: e.physics.p2.mpx(1),
            debugPolygons: !1,
            lineWidth: 1,
            alpha: .5
        };
        this.settings = Object.assign(n, s),
        this.ppu = this.settings.pixelsPerLengthUnit,
        this.ppu = -1 * this.ppu,
        this.body = i,
        this.canvas = new t.Graphics(e),
        this.canvas.alpha = this.settings.alpha,
        this.add(this.canvas),
        this.draw(),
        this.updateSpriteTransform()
    },
    t.Physics.P2.BodyDebug.prototype = Object.create(t.Group.prototype),
    t.Physics.P2.BodyDebug.prototype.constructor = t.Physics.P2.BodyDebug,
    Object.assign(t.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function() {
            this.position.x = this.body.position[0] * this.ppu,
            this.position.y = this.body.position[1] * this.ppu,
            this.rotation = this.body.angle
        },
        draw: function() {
            var t, e, i, s, n, r, o, a, h, l, c, u, d, p;
            if (o = this.body, (h = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), r = this.lineWidth, o instanceof p2.Body && o.shapes.length) {
                var f = o.shapes.length;
                for (s = 0; s !== f;) {
                    if (a = (e = o.shapes[s]).position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.radius * this.ppu, i, r);
                    else if (e instanceof p2.Capsule) this.drawCapsule(h, a[0] * this.ppu, a[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, 16711680, i, r);
                    else if (e instanceof p2.Plane) this.drawPlane(h, a[0] * this.ppu, -a[1] * this.ppu, i, 16711680, 5 * r, 10 * r, 10 * r, 100 * this.ppu, t);
                    else if (e instanceof p2.Line) this.drawLine(h, e.length * this.ppu, 16711680, r);
                    else if (e instanceof p2.Box) this.drawRectangle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, 16711680, i, r);
                    else if (e instanceof p2.Convex) {
                        for (c = [], u = p2.vec2.create(), n = d = 0, p = e.vertices.length; p >= 0 ? d < p: d > p; n = p >= 0 ? ++d: --d) l = e.vertices[n],
                        p2.vec2.rotate(u, l, t),
                        c.push([(u[0] + a[0]) * this.ppu, -(u[1] + a[1]) * this.ppu]);
                        this.drawConvex(h, c, e.triangles, 16711680, i, r, this.settings.debugPolygons, [a[0] * this.ppu, -a[1] * this.ppu])
                    }
                    s++
                }
            }
        },
        drawRectangle: function(t, e, i, s, n, r, o, a, h) {
            void 0 === h && (h = 1),
            void 0 === o && (o = 0),
            t.lineStyle(h, o, 1),
            t.beginFill(a),
            t.drawRect(e - n / 2, i - r / 2, n, r)
        },
        drawCircle: function(t, e, i, s, n, r, o) {
            void 0 === o && (o = 1),
            void 0 === r && (r = 16777215),
            t.lineStyle(o, 0, 1),
            t.beginFill(r, 1),
            t.drawCircle(e, i, 2 * -n),
            t.endFill(),
            t.moveTo(e, i),
            t.lineTo(e + n * Math.cos( - s), i + n * Math.sin( - s))
        },
        drawLine: function(t, e, i, s) {
            void 0 === s && (s = 1),
            void 0 === i && (i = 0),
            t.lineStyle(5 * s, i, 1),
            t.moveTo( - e / 2, 0),
            t.lineTo(e / 2, 0)
        },
        drawConvex: function(t, e, i, s, n, r, o, a) {
            var h, l, c, u, d, p, f, g, m, y, v;
            if (void 0 === r && (r = 1), void 0 === s && (s = 0), o) {
                for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) u = e[l % e.length],
                d = e[(l + 1) % e.length],
                f = u[0],
                y = u[1],
                g = d[0],
                v = d[1],
                t.lineStyle(r, h[l % h.length], 1),
                t.moveTo(f, -y),
                t.lineTo(g, -v),
                t.drawCircle(f, -y, 2 * r),
                l++;
                return t.lineStyle(r, 0, 1),
                t.drawCircle(a[0], a[1], 2 * r)
            }
            for (t.lineStyle(r, s, 1), t.beginFill(n), l = 0; l !== e.length;) p = (c = e[l])[0],
            m = c[1],
            0 === l ? t.moveTo(p, -m) : t.lineTo(p, -m),
            l++;
            if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]),
            t.lineTo(e[0][0], -e[0][1])
        },
        drawPath: function(t, e, i, s, n) {
            var r, o, a, h, l, c, u, d, p, f, g;
            for (void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof s && t.beginFill(s), o = null, a = null, r = 0; r < e.length;) f = (p = e[r])[0],
            g = p[1],
            f === o && g === a || (0 === r ? t.moveTo(f, g) : (h = o, l = a, c = f, u = g, d = e[(r + 1) % e.length][0], 0 != (c - h) * (e[(r + 1) % e.length][1] - l) - (d - h) * (u - l) && t.lineTo(f, g)), o = f, a = g),
            r++;
            "number" == typeof s && t.endFill(),
            e.length > 2 && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
        },
        drawPlane: function(t, e, i, s, n, r, o, a, h, l) {
            var c, u;
            void 0 === r && (r = 1),
            void 0 === s && (s = 16777215),
            t.lineStyle(r, n, 11),
            t.beginFill(s),
            t.moveTo(e, -i),
            c = e + Math.cos(l) * this.game.width,
            u = i + Math.sin(l) * this.game.height,
            t.lineTo(c, -u),
            t.moveTo(e, -i),
            c = e + Math.cos(l) * -this.game.width,
            u = i + Math.sin(l) * -this.game.height,
            t.lineTo(c, -u)
        },
        drawCapsule: function(t, e, i, s, n, r, o, a, h) {
            void 0 === h && (h = 1),
            void 0 === o && (o = 0),
            t.lineStyle(h, o, 1);
            var l = Math.cos(s),
            c = Math.sin(s);
            t.beginFill(a, 1),
            t.drawCircle( - n / 2 * l + e, -n / 2 * c + i, 2 * -r),
            t.drawCircle(n / 2 * l + e, n / 2 * c + i, 2 * -r),
            t.endFill(),
            t.lineStyle(h, o, 0),
            t.beginFill(a, 1),
            t.moveTo( - n / 2 * l + r * c + e, -n / 2 * c + r * l + i),
            t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i),
            t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i),
            t.lineTo( - n / 2 * l - r * c + e, -n / 2 * c - r * l + i),
            t.endFill(),
            t.lineStyle(h, o, 1),
            t.moveTo( - n / 2 * l + r * c + e, -n / 2 * c + r * l + i),
            t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i),
            t.moveTo( - n / 2 * l - r * c + e, -n / 2 * c - r * l + i),
            t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i)
        },
        randomPastelHex: function() {
            var t, e, i, s;
            return i = [255, 255, 255],
            s = Math.floor(256 * Math.random()),
            e = Math.floor(256 * Math.random()),
            t = Math.floor(256 * Math.random()),
            s = Math.floor((s + 3 * i[0]) / 4),
            e = Math.floor((e + 3 * i[1]) / 4),
            t = Math.floor((t + 3 * i[2]) / 4),
            this.rgbToHex(s, e, t)
        },
        rgbToHex: function(t, e, i) {
            return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
        },
        componentToHex: function(t) {
            var e;
            return 2 === (e = t.toString(16)).length ? e: e + "0"
        }
    }),
    t.Physics.P2.Spring = function(t, e, i, s, n, r, o, a, h, l) {
        this.game = t.game,
        this.world = t,
        void 0 === s && (s = 1),
        void 0 === n && (n = 100),
        void 0 === r && (r = 1);
        var c = {
            restLength: s = t.pxm(s),
            stiffness: n,
            damping: r
        };
        null != o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]),
        null != a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]),
        null != h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]),
        null != l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]),
        this.data = new p2.LinearSpring(e, i, c),
        this.data.parent = this
    },
    t.Physics.P2.Spring.prototype.constructor = t.Physics.P2.Spring,
    t.Physics.P2.RotationalSpring = function(t, e, i, s, n, r) {
        this.game = t.game,
        this.world = t,
        void 0 === s && (s = null),
        void 0 === n && (n = 100),
        void 0 === r && (r = 1),
        s && (s = t.pxm(s));
        var o = {
            restAngle: s,
            stiffness: n,
            damping: r
        };
        this.data = new p2.RotationalSpring(e, i, o),
        this.data.parent = this
    },
    t.Physics.P2.Spring.prototype.constructor = t.Physics.P2.Spring,
    t.Physics.P2.Material = function(t) {
        this.name = t,
        p2.Material.call(this)
    },
    t.Physics.P2.Material.prototype = Object.create(p2.Material.prototype),
    t.Physics.P2.Material.prototype.constructor = t.Physics.P2.Material,
    t.Physics.P2.ContactMaterial = function(t, e, i) {
        p2.ContactMaterial.call(this, t, e, i)
    },
    t.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype),
    t.Physics.P2.ContactMaterial.prototype.constructor = t.Physics.P2.ContactMaterial,
    t.Physics.P2.CollisionGroup = function(t) {
        this.mask = t
    },
    t.Physics.P2.DistanceConstraint = function(t, e, i, s, n, r, o) {
        void 0 === s && (s = 100),
        void 0 === n && (n = [0, 0]),
        void 0 === r && (r = [0, 0]),
        void 0 === o && (o = Number.MAX_VALUE),
        this.game = t.game,
        this.world = t;
        var a = {
            distance: s = t.pxm(s),
            localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
            localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
            maxForce: o
        };
        p2.DistanceConstraint.call(this, e, i, a)
    },
    t.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype),
    t.Physics.P2.DistanceConstraint.prototype.constructor = t.Physics.P2.DistanceConstraint,
    t.Physics.P2.GearConstraint = function(t, e, i, s, n) {
        void 0 === s && (s = 0),
        void 0 === n && (n = 1),
        this.game = t.game,
        this.world = t;
        var r = {
            angle: s,
            ratio: n
        };
        p2.GearConstraint.call(this, e, i, r)
    },
    t.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype),
    t.Physics.P2.GearConstraint.prototype.constructor = t.Physics.P2.GearConstraint,
    t.Physics.P2.LockConstraint = function(t, e, i, s, n, r) {
        void 0 === s && (s = [0, 0]),
        void 0 === n && (n = 0),
        void 0 === r && (r = Number.MAX_VALUE),
        this.game = t.game,
        this.world = t;
        var o = {
            localOffsetB: s = [t.pxm(s[0]), t.pxm(s[1])],
            localAngleB: n,
            maxForce: r
        };
        p2.LockConstraint.call(this, e, i, o)
    },
    t.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype),
    t.Physics.P2.LockConstraint.prototype.constructor = t.Physics.P2.LockConstraint,
    t.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, r, o, a) {
        void 0 === s && (s = !0),
        void 0 === n && (n = [0, 0]),
        void 0 === r && (r = [0, 0]),
        void 0 === o && (o = [0, 0]),
        void 0 === a && (a = Number.MAX_VALUE),
        this.game = t.game,
        this.world = t;
        var h = {
            localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
            localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
            localAxisA: o,
            maxForce: a,
            disableRotationalLock: !s
        };
        p2.PrismaticConstraint.call(this, e, i, h)
    },
    t.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype),
    t.Physics.P2.PrismaticConstraint.prototype.constructor = t.Physics.P2.PrismaticConstraint,
    t.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, r, o) {
        void 0 === r && (r = Number.MAX_VALUE),
        void 0 === o && (o = null),
        this.game = t.game,
        this.world = t,
        i = [t.pxmi(i[0]), t.pxmi(i[1])],
        n = [t.pxmi(n[0]), t.pxmi(n[1])],
        o && (o = [t.pxmi(o[0]), t.pxmi(o[1])]);
        var a = {
            worldPivot: o,
            localPivotA: i,
            localPivotB: n,
            maxForce: r
        };
        p2.RevoluteConstraint.call(this, e, s, a)
    },
    t.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype),
    t.Physics.P2.RevoluteConstraint.prototype.constructor = t.Physics.P2.RevoluteConstraint,
    t.ImageCollection = function(t, e, i, s, n, r, o) { (void 0 === i || i <= 0) && (i = 32),
        (void 0 === s || s <= 0) && (s = 32),
        void 0 === n && (n = 0),
        void 0 === r && (r = 0),
        this.name = t,
        this.firstgid = 0 | e,
        this.imageWidth = 0 | i,
        this.imageHeight = 0 | s,
        this.imageMargin = 0 | n,
        this.imageSpacing = 0 | r,
        this.properties = o || {},
        this.images = [],
        this.total = 0
    },
    t.ImageCollection.prototype = {
        containsImageIndex: function(t) {
            return t >= this.firstgid && t < this.firstgid + this.total
        },
        addImage: function(t, e) {
            this.images.push({
                gid: t,
                image: e
            }),
            this.total++
        }
    },
    t.ImageCollection.prototype.constructor = t.ImageCollection,
    t.Tile = function(t, e, i, s, n, r) {
        this.layer = t,
        this.index = e,
        this.x = i,
        this.y = s,
        this.rotation = 0,
        this.flipped = !1,
        this.worldX = i * n,
        this.worldY = s * r,
        this.width = n,
        this.height = r,
        this.centerX = Math.abs(n / 2),
        this.centerY = Math.abs(r / 2),
        this.alpha = 1,
        this.properties = {},
        this.scanned = !1,
        this.faceTop = !1,
        this.faceBottom = !1,
        this.faceLeft = !1,
        this.faceRight = !1,
        this.collideLeft = !1,
        this.collideRight = !1,
        this.collideUp = !1,
        this.collideDown = !1,
        this.collisionCallback = null,
        this.collisionCallbackContext = this,
        this.debug = !1
    },
    t.Tile.prototype = {
        containsPoint: function(t, e) {
            return ! (t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
        },
        intersects: function(t, e, i, s) {
            return ! (i <= this.worldX || s <= this.worldY || t >= this.worldX + this.width || e >= this.worldY + this.height)
        },
        setCollisionCallback: function(t, e) {
            this.collisionCallback = t,
            this.collisionCallbackContext = e
        },
        destroy: function() {
            this.collisionCallback = null,
            this.collisionCallbackContext = null,
            this.properties = null
        },
        setCollision: function(t, e, i, s) {
            this.collideLeft = t,
            this.collideRight = e,
            this.collideUp = i,
            this.collideDown = s,
            this.faceLeft = t,
            this.faceRight = e,
            this.faceTop = i,
            this.faceBottom = s
        },
        resetCollision: function() {
            this.collideLeft = !1,
            this.collideRight = !1,
            this.collideUp = !1,
            this.collideDown = !1,
            this.faceTop = !1,
            this.faceBottom = !1,
            this.faceLeft = !1,
            this.faceRight = !1
        },
        isInteresting: function(t, e) {
            return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback: t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown: !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
        },
        copy: function(t) {
            this.index = t.index,
            this.alpha = t.alpha,
            this.properties = t.properties,
            this.collideUp = t.collideUp,
            this.collideDown = t.collideDown,
            this.collideLeft = t.collideLeft,
            this.collideRight = t.collideRight,
            this.collisionCallback = t.collisionCallback,
            this.collisionCallbackContext = t.collisionCallbackContext
        }
    },
    t.Tile.prototype.constructor = t.Tile,
    Object.defineProperty(t.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
        }
    }),
    Object.defineProperty(t.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
        }
    }),
    Object.defineProperty(t.Tile.prototype, "left", {
        get: function() {
            return this.worldX
        }
    }),
    Object.defineProperty(t.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width
        }
    }),
    Object.defineProperty(t.Tile.prototype, "top", {
        get: function() {
            return this.worldY
        }
    }),
    Object.defineProperty(t.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height
        }
    }),
    t.Tilemap = function(e, i, s, n, r, o) {
        this.game = e,
        this.key = i;
        var a = t.TilemapParser.parse(this.game, i, s, n, r, o);
        null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
    },
    t.Tilemap.CSV = 0,
    t.Tilemap.TILED_JSON = 1,
    t.Tilemap.NORTH = 0,
    t.Tilemap.EAST = 1,
    t.Tilemap.SOUTH = 2,
    t.Tilemap.WEST = 3,
    t.Tilemap.prototype = {
        create: function(t, e, i, s, n, r) {
            return void 0 === r && (r = this.game.world),
            this.width = e,
            this.height = i,
            this.setTileSize(s, n),
            this.layers.length = 0,
            this.createBlankLayer(t, e, i, s, n, r)
        },
        setTileSize: function(t, e) {
            this.tileWidth = t,
            this.tileHeight = e,
            this.widthInPixels = this.width * t,
            this.heightInPixels = this.height * e
        },
        addTilesetImage: function(e, i, s, n, r, o, a) {
            if (void 0 === e) return null;
            void 0 === s && (s = this.tileWidth),
            void 0 === n && (n = this.tileHeight),
            void 0 === r && (r = 0),
            void 0 === o && (o = 0),
            void 0 === a && (a = 0),
            0 === s && (s = 32),
            0 === n && (n = 32);
            var h = null;
            if (null != i || (i = e), i instanceof t.BitmapData) h = i.canvas;
            else {
                if (!this.game.cache.checkImageKey(i)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + i + '"'),
                null;
                h = this.game.cache.getImage(i)
            }
            var l = this.getTilesetIndex(e);
            if (null === l && this.format === t.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + e + '"'),
            console.log("Tilesets: ", this.tilesets),
            null;
            if (this.tilesets[l]) return this.tilesets[l].setImage(h),
            this.tilesets[l];
            var c = new t.Tileset(e, a, s, n, r, o, {});
            c.setImage(h),
            this.tilesets.push(c);
            for (var u = this.tilesets.length - 1,
            d = r,
            p = r,
            f = 0,
            g = 0,
            m = 0,
            y = a; y < a + c.total && (this.tiles[y] = [d, p, u], d += s + o, ++f !== c.total) && (++g !== c.columns || (d = r, p += n + o, g = 0, ++m !== c.rows)); y++);
            return c
        },
        createFromObjects: function(e, i, s, n, r, o, a, h, l, c) {
            if (void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = this.game.world), void 0 === h && (h = t.Sprite), void 0 === l && (l = !0), void 0 === c && (c = !0), !this.objects[e]) return console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + e),
            void console.log("Objects: ", this.objects);
            for (var u = 0; u < this.objects[e].length; u++) {
                var d = !1,
                p = this.objects[e][u];
                if (void 0 !== p.gid && "number" == typeof i && p.gid === i ? d = !0 : void 0 !== p.id && "number" == typeof i && p.id === i ? d = !0 : void 0 !== p.name && "string" == typeof i && p.name === i && (d = !0), d) {
                    var f = new h(this.game, parseFloat(p.x, 10), parseFloat(p.y, 10), s, n);
                    for (var g in f.name = p.name,
                    f.autoCull = o,
                    f.exists = r,
                    f.visible = p.visible,
                    c && (p.width && (f.width = p.width), p.height && (f.height = p.height)), p.rotation && (f.angle = p.rotation), l && (f.y -= f.height), a.add(f), p.properties) a.set(f, g, p.properties[g], !1, !1, 0, !0)
                }
            }
        },
        createFromTiles: function(e, i, s, n, r, o) {
            "number" == typeof e && (e = [e]),
            null == i ? i = [] : "number" == typeof i && (i = [i]),
            n = this.getLayer(n),
            void 0 === r && (r = this.game.world),
            void 0 === o && (o = {}),
            void 0 === o.customClass && (o.customClass = t.Sprite),
            void 0 === o.adjustY && (o.adjustY = !0);
            var a = this.layers[n].width,
            h = this.layers[n].height;
            if (this.copy(0, 0, a, h, n), this._results.length < 2) return 0;
            for (var l, c = 0,
            u = 1,
            d = this._results.length; u < d; u++) if ( - 1 !== e.indexOf(this._results[u].index)) {
                for (var p in l = new o.customClass(this.game, this._results[u].worldX, this._results[u].worldY, s), o) l[p] = o[p];
                r.add(l),
                c++
            }
            if (1 === i.length) for (u = 0; u < e.length; u++) this.replace(e[u], i[0], 0, 0, a, h, n);
            else if (i.length > 1) for (u = 0; u < e.length; u++) this.replace(e[u], i[u], 0, 0, a, h, n);
            return c
        },
        createLayer: function(e, i, s, n) {
            void 0 === i && (i = this.game.width),
            void 0 === s && (s = this.game.height),
            void 0 === n && (n = this.game.world);
            var r = e;
            if ("string" == typeof e && (r = this.getLayerIndex(e)), null === r || r > this.layers.length) return console.warn('Tilemap.createLayer: Invalid layer ID given: "' + e + '"'),
            void console.log("Layers: ", this.layers);
            void 0 === i || i <= 0 ? i = Math.min(this.game.width, this.layers[r].widthInPixels) : i > this.game.width && (i = this.game.width),
            void 0 === s || s <= 0 ? s = Math.min(this.game.height, this.layers[r].heightInPixels) : s > this.game.height && (s = this.game.height),
            this.enableDebug && (console.group("Tilemap.createLayer"), console.log("Name:", this.layers[r].name), console.log("Size:", i, "x", s), console.log("Tileset:", this.tilesets[0].name, "index:", r));
            var o = n.add(new t.TilemapLayer(this.game, this, r, i, s));
            return this.enableDebug && console.groupEnd(),
            o
        },
        createBlankLayer: function(e, i, s, n, r, o) {
            if (void 0 === o && (o = this.game.world), null === this.getLayerIndex(e)) {
                for (var a, h = {
                    name: e,
                    x: 0,
                    y: 0,
                    width: i,
                    height: s,
                    widthInPixels: i * n,
                    heightInPixels: s * r,
                    alpha: 1,
                    visible: !0,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: [],
                    data: null
                },
                l = [], c = 0; c < s; c++) {
                    a = [];
                    for (var u = 0; u < i; u++) a.push(new t.Tile(h, -1, u, c, n, r));
                    l.push(a)
                }
                h.data = l,
                this.layers.push(h),
                this.currentLayer = this.layers.length - 1;
                var d = h.widthInPixels,
                p = h.heightInPixels;
                return d > this.game.width && (d = this.game.width),
                p > this.game.height && (p = this.game.height),
                (l = new t.TilemapLayer(this.game, this, this.layers.length - 1, d, p)).name = e,
                o.add(l)
            }
            console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + e)
        },
        getIndex: function(t, e) {
            for (var i = 0; i < t.length; i++) if (t[i].name === e) return i;
            return null
        },
        getLayerIndex: function(t) {
            return this.getIndex(this.layers, t)
        },
        getTilesetIndex: function(t) {
            return this.getIndex(this.tilesets, t)
        },
        getImageIndex: function(t) {
            return this.getIndex(this.images, t)
        },
        setTileIndexCallback: function(t, e, i, s) {
            if (s = this.getLayer(s), "number" == typeof t) null === e ? delete this.layers[s].callbacks[t] : this.layers[s].callbacks[t] = {
                callback: e,
                callbackContext: i
            };
            else for (var n = 0,
            r = t.length; n < r; n++) null === e ? delete this.layers[s].callbacks[t[n]] : this.layers[s].callbacks[t[n]] = {
                callback: e,
                callbackContext: i
            }
        },
        setTileLocationCallback: function(t, e, i, s, n, r, o) {
            if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2)) for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(n, r)
        },
        setCollision: function(t, e, i, s) {
            if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
            if (Array.isArray(t)) {
                for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                s && this.calculateFaces(i)
            }
        },
        setCollisionBetween: function(t, e, i, s, n) {
            if (void 0 === i && (i = !0), void 0 === n && (n = !0), s = this.getLayer(s), !(t > e)) {
                for (var r = t; r <= e; r++) this.setCollisionByIndex(r, i, s, !1);
                n && this.calculateFaces(s)
            }
        },
        setCollisionByExclusion: function(t, e, i, s) {
            void 0 === e && (e = !0),
            void 0 === s && (s = !0),
            i = this.getLayer(i);
            for (var n = 0,
            r = this.tiles.length; n < r; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
            s && this.calculateFaces(i)
        },
        setCollisionByIndex: function(t, e, i, s) {
            if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e) this.collideIndexes.push(t);
            else {
                var n = this.collideIndexes.indexOf(t);
                n > -1 && this.collideIndexes.splice(n, 1)
            }
            for (var r = 0; r < this.layers[i].height; r++) for (var o = 0; o < this.layers[i].width; o++) {
                var a = this.layers[i].data[r][o];
                a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
            }
            return s && this.calculateFaces(i),
            i
        },
        getLayer: function(e) {
            if (void 0 === e) e = this.currentLayer;
            else if ("string" == typeof e) {
                var i = e;
                null === (e = this.getLayerIndex(e)) && console.warn("No such layer name: " + i)
            } else e instanceof t.TilemapLayer && (e = e.index);
            return e
        },
        setPreventRecalculate: function(t) {
            if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                for (var e in this.preventingRecalculate = !1,
                this.needToRecalculate) this.calculateFaces(e);
                this.needToRecalculate = !1
            }
        },
        calculateFaces: function(t) {
            if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
            else for (var e = null,
            i = null,
            s = null,
            n = null,
            r = 0,
            o = this.layers[t].height; r < o; r++) for (var a = 0,
            h = this.layers[t].width; a < h; a++) {
                var l = this.layers[t].data[r][a];
                l && (e = this.getTileAbove(t, a, r), i = this.getTileBelow(t, a, r), s = this.getTileLeft(t, a, r), n = this.getTileRight(t, a, r), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
            }
        },
        getTileAbove: function(t, e, i) {
            return i > 0 ? this.layers[t].data[i - 1][e] : null
        },
        getTileBelow: function(t, e, i) {
            return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
        },
        getTileLeft: function(t, e, i) {
            return e > 0 ? this.layers[t].data[i][e - 1] : null
        },
        getTileRight: function(t, e, i) {
            return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
        },
        setLayer: function(t) {
            t = this.getLayer(t),
            this.layers[t] && (this.currentLayer = t)
        },
        hasTile: function(t, e, i) {
            return i = this.getLayer(i),
            void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
        },
        removeTile: function(e, i, s) {
            if (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && i >= 0 && i < this.layers[s].height && this.hasTile(e, i, s)) {
                var n = this.layers[s].data[i][e];
                return this.layers[s].data[i][e] = new t.Tile(this.layers[s], -1, e, i, this.tileWidth, this.tileHeight),
                this.layers[s].dirty = !0,
                this.calculateFaces(s),
                n
            }
        },
        removeTileWorldXY: function(t, e, i, s, n) {
            return n = this.getLayer(n),
            t = this.game.math.snapToFloor(t, i) / i,
            e = this.game.math.snapToFloor(e, s) / s,
            this.removeTile(t, e, n)
        },
        putTile: function(e, i, s, n) {
            return null === e ? this.removeTile(i, s, n) : (n = this.getLayer(n), i >= 0 && i < this.layers[n].width && s >= 0 && s < this.layers[n].height ? (e instanceof t.Tile ? (r = e.index, this.hasTile(i, s, n) ? this.layers[n].data[s][i].copy(e) : this.layers[n].data[s][i] = new t.Tile(n, r, i, s, e.width, e.height)) : (r = e, this.hasTile(i, s, n) ? this.layers[n].data[s][i].index = r: this.layers[n].data[s][i] = new t.Tile(this.layers[n], r, i, s, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(r) > -1 ? this.layers[n].data[s][i].setCollision(!0, !0, !0, !0) : this.layers[n].data[s][i].resetCollision(), this.layers[n].dirty = !0, this.calculateFaces(n), this.layers[n].data[s][i]) : null);
            var r
        }, putTileWorldXY: function(t, e, i, s, n, r) {
            return r = this.getLayer(r),
            e = this.game.math.snapToFloor(e, s) / s,
            i = this.game.math.snapToFloor(i, n) / n,
            this.putTile(t, e, i, r)
        },
        searchTileIndex: function(t, e, i, s) {
            void 0 === e && (e = 0),
            void 0 === i && (i = !1),
            s = this.getLayer(s);
            var n = 0;
            if (i) {
                for (r = this.layers[s].height - 1; r >= 0; r--) for (o = this.layers[s].width - 1; o >= 0; o--) if (this.layers[s].data[r][o].index === t) {
                    if (n === e) return this.layers[s].data[r][o];
                    n++
                }
            } else for (var r = 0; r < this.layers[s].height; r++) for (var o = 0; o < this.layers[s].width; o++) if (this.layers[s].data[r][o].index === t) {
                if (n === e) return this.layers[s].data[r][o];
                n++
            }
            return null
        },
        getTile: function(t, e, i, s) {
            return void 0 === s && (s = !1),
            i = this.getLayer(i),
            t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null: this.layers[i].data[e][t] : null
        },
        getTileWorldXY: function(t, e, i, s, n, r) {
            return void 0 === i && (i = this.tileWidth),
            void 0 === s && (s = this.tileHeight),
            n = this.getLayer(n),
            t = this.game.math.snapToFloor(t, i) / i,
            e = this.game.math.snapToFloor(e, s) / s,
            this.getTile(t, e, n, r)
        },
        copy: function(t, e, i, s, n) {
            if (n = this.getLayer(n), this.layers[n]) {
                void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                void 0 === i && (i = this.layers[n].width),
                void 0 === s && (s = this.layers[n].height),
                t < 0 && (t = 0),
                e < 0 && (e = 0),
                i > this.layers[n].width && (i = this.layers[n].width),
                s > this.layers[n].height && (s = this.layers[n].height),
                this._results.length = 0,
                this._results.push({
                    x: t,
                    y: e,
                    width: i,
                    height: s,
                    layer: n
                });
                for (var r = e; r < e + s; r++) for (var o = t; o < t + i; o++) this._results.push(this.layers[n].data[r][o]);
                return this._results
            }
            this._results.length = 0
        },
        paste: function(t, e, i, s) {
            if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                for (var n = t - i[1].x, r = e - i[1].y, o = 1; o < i.length; o++) this.layers[s].data[r + i[o].y][n + i[o].x].copy(i[o]);
                this.layers[s].dirty = !0,
                this.calculateFaces(s)
            }
        },
        swap: function(t, e, i, s, n, r, o) {
            o = this.getLayer(o),
            this.copy(i, s, n, r, o),
            this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
        },
        swapHandler: function(t) {
            t.index === this._tempA ? t.index = this._tempB: t.index === this._tempB && (t.index = this._tempA)
        },
        forEach: function(t, e, i, s, n, r, o) {
            o = this.getLayer(o),
            this.copy(i, s, n, r, o),
            this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
        },
        replace: function(t, e, i, s, n, r, o) {
            if (o = this.getLayer(o), this.copy(i, s, n, r, o), !(this._results.length < 2)) {
                for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                this.paste(i, s, this._results, o)
            }
        },
        random: function(t, e, i, s, n) {
            if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                for (var r = [], o = 1; o < this._results.length; o++) if (this._results[o].index) {
                    var a = this._results[o].index; - 1 === r.indexOf(a) && r.push(a)
                }
                for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(r);
                this.paste(t, e, this._results, n)
            }
        },
        shuffle: function(e, i, s, n, r) {
            if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                for (var o = [], a = 1; a < this._results.length; a++) this._results[a].index && o.push(this._results[a].index);
                t.ArrayUtils.shuffle(o);
                for (var h = 1; h < this._results.length; h++) this._results[h].index = o[h - 1];
                this.paste(e, i, this._results, r)
            }
        },
        fill: function(t, e, i, s, n, r) {
            if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                this.paste(e, i, this._results, r)
            }
        },
        removeAllLayers: function() {
            this.layers.length = 0,
            this.currentLayer = 0
        },
        dump: function() {
            for (var t = "",
            e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ",
                this.layers[this.currentLayer].data[i][s] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                t += "\n"
            }
            e[0] = t,
            console.log.apply(console, e)
        },
        destroy: function() {
            this.removeAllLayers(),
            this.data = [],
            this.game = null
        }
    },
    t.Tilemap.prototype.constructor = t.Tilemap,
    Object.defineProperty(t.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer]
        },
        set: function(t) {
            t !== this.currentLayer && this.setLayer(t)
        }
    }),
    t.TilemapLayer = function(e, i, s, n, r) {
        n |= 0,
        r |= 0,
        t.Sprite.call(this, e, 0, 0),
        this.map = i,
        this.index = s,
        this.layer = i.layers[s],
        this.canvas = t.CanvasPool.create(this, n, r),
        this.context = this.canvas.getContext("2d"),
        this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas, null, this.game.resolution))),
        this.type = t.TILEMAPLAYER,
        this.physicsType = t.TILEMAPLAYER,
        this.renderSettings = {
            enableScrollDelta: !0,
            overdrawRatio: .2,
            copyCanvas: null
        },
        this.debug = !1,
        this.exists = !0,
        this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: !0,
            debugAlpha: .5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        },
        this.scrollFactorX = 1,
        this.scrollFactorY = 1,
        this.dirty = !0,
        this.rayStepRate = 4,
        this._wrap = !1,
        this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: i.tileWidth,
            tileHeight: i.tileHeight,
            cw: i.tileWidth,
            ch: i.tileHeight,
            tilesets: []
        },
        this._scrollX = 0,
        this._scrollY = 0,
        this.tileOffset = new t.Point(this.layer.offsetX || 0, this.layer.offsetY || 0),
        this._results = [],
        e.device.canvasBitBltShift || (this.renderSettings.copyCanvas = t.TilemapLayer.ensureSharedCopyCanvas()),
        this.fixedToCamera = !0
    },
    t.TilemapLayer.prototype = Object.create(t.Sprite.prototype),
    t.TilemapLayer.prototype.constructor = t.TilemapLayer,
    t.TilemapLayer.prototype.preUpdateCore = t.Component.Core.preUpdate,
    t.TilemapLayer.sharedCopyCanvas = null,
    t.TilemapLayer.ensureSharedCopyCanvas = function() {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = t.CanvasPool.create(this, 2, 2)),
        this.sharedCopyCanvas
    },
    t.TilemapLayer.prototype.preUpdate = function() {
        return this.preUpdateCore()
    },
    t.TilemapLayer.prototype.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
        this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y
    },
    t.TilemapLayer.prototype._renderCanvas = function(t) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
        this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y,
        this.render(),
        PIXI.Sprite.prototype._renderCanvas.call(this, t)
    },
    t.TilemapLayer.prototype._renderWebGL = function(t) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x,
        this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y,
        this.render(),
        PIXI.Sprite.prototype._renderWebGL.call(this, t)
    },
    t.TilemapLayer.prototype.destroy = function() {
        t.CanvasPool.remove(this),
        t.Component.Destroy.prototype.destroy.call(this)
    },
    t.TilemapLayer.prototype.resize = function(t, e) {
        this.canvas.width = t,
        this.canvas.height = e,
        this.texture.frame.resize(t, e),
        this.texture.width = t,
        this.texture.height = e,
        this.texture.crop.width = t,
        this.texture.crop.height = e,
        this.texture.baseTexture.width = t,
        this.texture.baseTexture.height = e,
        this.texture.baseTexture.dirty(),
        this.texture.requiresUpdate = !0,
        this.texture._updateUvs(),
        this.dirty = !0
    },
    t.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
    },
    t.TilemapLayer.prototype.getTileOffsetX = function() {
        return this.tileOffset.x || (this.fixedToCamera ? 0 : this.position.x)
    },
    t.TilemapLayer.prototype.getTileOffsetY = function() {
        return this.tileOffset.y || (this.fixedToCamera ? 0 : this.position.y)
    },
    t.TilemapLayer.prototype._fixX = function(t) {
        return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t: 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x: this._scrollX + (t - this._scrollX / this.scrollFactorX)
    },
    t.TilemapLayer.prototype._unfixX = function(t) {
        return 1 === this.scrollFactorX ? t: this._scrollX / this.scrollFactorX + (t - this._scrollX)
    },
    t.TilemapLayer.prototype._fixY = function(t) {
        return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t: 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y: this._scrollY + (t - this._scrollY / this.scrollFactorY)
    },
    t.TilemapLayer.prototype._unfixY = function(t) {
        return 1 === this.scrollFactorY ? t: this._scrollY / this.scrollFactorY + (t - this._scrollY)
    },
    t.TilemapLayer.prototype.getTileX = function(t) {
        return Math.floor(this._fixX(t) / this._mc.tileWidth)
    },
    t.TilemapLayer.prototype.getTileY = function(t) {
        return Math.floor(this._fixY(t) / this._mc.tileHeight)
    },
    t.TilemapLayer.prototype.getTileXY = function(t, e, i) {
        return i.x = this.getTileX(t),
        i.y = this.getTileY(e),
        i
    },
    t.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
        e || (e = this.rayStepRate),
        void 0 === i && (i = !1),
        void 0 === s && (s = !1);
        var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
        if (0 === n.length) return [];
        for (var r = t.coordinatesOnLine(e), o = [], a = 0; a < n.length; a++) for (var h = 0; h < r.length; h++) {
            var l = n[a],
            c = r[h];
            if (l.containsPoint(c[0], c[1])) {
                o.push(l);
                break
            }
        }
        return o
    },
    t.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, r) {
        void 0 === n && (n = !1),
        void 0 === r && (r = !1);
        var o = !(n || r);
        t = this._fixX(t),
        e = this._fixY(e);
        for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
        for (var u = h; u < h + c; u++) for (var d = a; d < a + l; d++) {
            var p = this.layer.data[u];
            p && p[d] && (o || p[d].isInteresting(n, r)) && this._results.push(p[d])
        }
        return this._results.slice()
    },
    t.TilemapLayer.prototype.resolveTileset = function(t) {
        var e = this._mc.tilesets;
        if (t < 2e3) for (; e.length < t;) e.push(void 0);
        var i = this.map.tiles[t] && this.map.tiles[t][2];
        if (null !== i) {
            var s = this.map.tilesets[i];
            if (s && s.containsTileIndex(t)) return e[t] = s
        }
        return e[t] = null
    },
    t.TilemapLayer.prototype.resetTilesetCache = function() {
        for (var t = this._mc.tilesets; t.length;) t.pop()
    },
    t.TilemapLayer.prototype.setScale = function(t, e) {
        t = t || 1,
        e = e || t;
        for (var i = 0; i < this.layer.data.length; i++) for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
            var r = s[n];
            r.width = this.map.tileWidth * t,
            r.height = this.map.tileHeight * e,
            r.worldX = r.x * r.width,
            r.worldY = r.y * r.height
        }
        this.scale.setTo(t, e)
    },
    t.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
        var s = t.canvas,
        n = s.width - Math.abs(e),
        r = s.height - Math.abs(i),
        o = 0,
        a = 0,
        h = e,
        l = i;
        e < 0 && (o = -e, h = 0),
        i < 0 && (a = -i, l = 0);
        var c = this.renderSettings.copyCanvas;
        if (c) { (c.width < n || c.height < r) && (c.width = n, c.height = r);
            var u = c.getContext("2d");
            u.clearRect(0, 0, n, r),
            u.drawImage(s, o, a, n, r, 0, 0, n, r),
            t.clearRect(h, l, n, r),
            t.drawImage(c, 0, 0, n, r, h, l, n, r)
        } else t.save(),
        t.globalCompositeOperation = "copy",
        t.drawImage(s, o, a, n, r, h, l, n, r),
        t.restore()
    },
    t.TilemapLayer.prototype.renderRegion = function(t, e, i, s, n, r) {
        var o = this.context,
        a = this.layer.width,
        h = this.layer.height,
        l = this._mc.tileWidth,
        c = this._mc.tileHeight,
        u = this._mc.tilesets,
        d = NaN;
        this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(a - 1, n)), s <= r && (s = Math.max(0, s), r = Math.min(h - 1, r)));
        var p, f, g, m, y, v, x = i * l - t,
        b = (i + (1 << 20) * a) % a;
        for (m = (s + (1 << 20) * h) % h, v = r - s, f = s * c - e; v >= 0; m++, v--, f += c) {
            m >= h && (m -= h);
            var _ = this.layer.data[m];
            for (g = b, y = n - i, p = x; y >= 0; g++, y--, p += l) {
                g >= a && (g -= a);
                var w = _[g];
                if (w && !(w.index < 0)) {
                    var T = w.index,
                    P = u[T];
                    void 0 === P && (P = this.resolveTileset(T)),
                    w.alpha === d || this.debug || (o.globalAlpha = w.alpha, d = w.alpha),
                    P ? w.rotation || w.flipped ? (o.save(), o.translate(p + w.centerX, f + w.centerY), o.rotate(w.rotation), w.flipped && o.scale( - 1, 1), P.draw(o, -w.centerX, -w.centerY, T), o.restore()) : P.draw(o, p, f, T) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(p, f, l, c)),
                    w.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(p, f, l, c))
                }
            }
        }
    },
    t.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
        var i = this._mc.scrollX,
        s = this._mc.scrollY,
        n = this.canvas.width,
        r = this.canvas.height,
        o = this._mc.tileWidth,
        a = this._mc.tileHeight,
        h = 0,
        l = -o,
        c = 0,
        u = -a;
        if (t < 0 ? (h = n + t, l = n - 1) : t > 0 && (l = t), e < 0 ? (c = r + e, u = r - 1) : e > 0 && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + s) / a), u = Math.floor((u + s) / a), h <= l) {
            this.context.clearRect(h * o - i, 0, (l - h + 1) * o, r);
            var d = Math.floor((0 + s) / a),
            p = Math.floor((r - 1 + s) / a);
            this.renderRegion(i, s, h, d, l, p)
        }
        if (c <= u) {
            this.context.clearRect(0, c * a - s, n, (u - c + 1) * a);
            var f = Math.floor((0 + i) / o),
            g = Math.floor((n - 1 + i) / o);
            this.renderRegion(i, s, f, c, g, u)
        }
    },
    t.TilemapLayer.prototype.renderFull = function() {
        var t = this._mc.scrollX,
        e = this._mc.scrollY,
        i = this.canvas.width,
        s = this.canvas.height,
        n = this._mc.tileWidth,
        r = this._mc.tileHeight,
        o = Math.floor(t / n),
        a = Math.floor((i - 1 + t) / n),
        h = Math.floor(e / r),
        l = Math.floor((s - 1 + e) / r);
        this.context.clearRect(0, 0, i, s),
        this.renderRegion(t, e, o, h, a, l)
    },
    t.TilemapLayer.prototype.render = function() {
        var t = !1;
        if (this.visible) { (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
            var e = this.canvas.width,
            i = this.canvas.height,
            s = 0 | this._scrollX,
            n = 0 | this._scrollY,
            r = this._mc,
            o = r.scrollX - s,
            a = r.scrollY - n;
            if (t || 0 !== o || 0 !== a || r.renderWidth !== e || r.renderHeight !== i) return this.context.save(),
            r.scrollX = s,
            r.scrollY = n,
            r.renderWidth === e && r.renderHeight === i || (r.renderWidth = e, r.renderHeight = i),
            this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)),
            !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(o, a) : this.renderFull(),
            this.debug && (this.context.globalAlpha = 1, this.renderDebug()),
            this.texture.baseTexture.dirty(),
            this.dirty = !1,
            this.context.restore(),
            !0
        }
    },
    t.TilemapLayer.prototype.renderDebug = function() {
        var t, e, i, s, n, r, o = this._mc.scrollX,
        a = this._mc.scrollY,
        h = this.context,
        l = this.canvas.width,
        c = this.canvas.height,
        u = this.layer.width,
        d = this.layer.height,
        p = this._mc.tileWidth,
        f = this._mc.tileHeight,
        g = Math.floor(o / p),
        m = Math.floor((l - 1 + o) / p),
        y = Math.floor(a / f),
        v = Math.floor((c - 1 + a) / f),
        x = g * p - o,
        b = y * f - a,
        _ = (g + (1 << 20) * u) % u,
        w = (y + (1 << 20) * d) % d;
        for (h.strokeStyle = this.debugSettings.facingEdgeStroke, s = w, r = v - y, e = b; r >= 0; s++, r--, e += f) {
            s >= d && (s -= d);
            var T = this.layer.data[s];
            for (i = _, n = m - g, t = x; n >= 0; i++, n--, t += p) {
                i >= u && (i -= u);
                var P = T[i]; ! P || P.index < 0 || !P.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), P.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), P.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), P.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), P.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
            }
        }
    },
    Object.defineProperty(t.TilemapLayer.prototype, "wrap", {
        get: function() {
            return this._wrap
        },
        set: function(t) {
            this._wrap = t,
            this.dirty = !0
        }
    }),
    Object.defineProperty(t.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._scrollX
        },
        set: function(t) {
            this._scrollX = t
        }
    }),
    Object.defineProperty(t.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._scrollY
        },
        set: function(t) {
            this._scrollY = t
        }
    }),
    Object.defineProperty(t.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw
        },
        set: function(t) {
            this._mc.cw = 0 | t,
            this.dirty = !0
        }
    }),
    Object.defineProperty(t.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch
        },
        set: function(t) {
            this._mc.ch = 0 | t,
            this.dirty = !0
        }
    }),
    t.TilemapParser = {
        INSERT_NULL: !1,
        parse: function(e, i, s, n, r, o) {
            if (void 0 === s && (s = 32), void 0 === n && (n = 32), void 0 === r && (r = 10), void 0 === o && (o = 10), void 0 === i) return this.getEmptyData();
            if (null === i) return this.getEmptyData(s, n, r, o);
            var a = e.cache.getTilemapData(i);
            if (a) {
                if (a.format === t.Tilemap.CSV) return this.parseCSV(i, a.data, s, n);
                if (!a.format || a.format === t.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
            } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + i)
        },
        parseCSV: function(e, i, s, n) {
            for (var r = this.getEmptyData(), o = [], a = (i = i.trim()).split("\n"), h = a.length, l = 0, c = 0; c < a.length; c++) {
                o[c] = [];
                for (var u = a[c].split(","), d = 0; d < u.length; d++) o[c][d] = new t.Tile(r.layers[0], parseInt(u[d], 10), d, c, s, n);
                0 === l && (l = u.length)
            }
            return r.format = t.Tilemap.CSV,
            r.name = e,
            r.width = l,
            r.height = h,
            r.tileWidth = s,
            r.tileHeight = n,
            r.widthInPixels = l * s,
            r.heightInPixels = h * n,
            r.layers[0].width = l,
            r.layers[0].height = h,
            r.layers[0].widthInPixels = r.widthInPixels,
            r.layers[0].heightInPixels = r.heightInPixels,
            r.layers[0].data = o,
            r
        },
        getEmptyData: function(t, e, i, s) {
            return {
                width: null != i ? i: 0,
                height: null != s ? s: 0,
                tileWidth: null != t ? t: 0,
                tileHeight: null != e ? e: 0,
                orientation: "orthogonal",
                version: "1",
                properties: {},
                widthInPixels: 0,
                heightInPixels: 0,
                layers: [{
                    name: "layer",
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    widthInPixels: 0,
                    heightInPixels: 0,
                    alpha: 1,
                    visible: !0,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: [],
                    data: []
                }],
                images: [],
                objects: {},
                collision: {},
                tilesets: [],
                tiles: []
            }
        },
        _slice: function(t, e) {
            var i = {};
            for (var s in e) {
                var n = e[s];
                void 0 !== t[n] && (i[n] = t[n])
            }
            return i
        },
        parseObjectGroup: function(t, e, i, s, n) {
            s = s || t.name,
            n = n || {
                x: 0,
                y: 0
            };
            var r = this._slice;
            s || console.warn("No name found for objectGroup", t),
            void 0 !== n.x && void 0 !== n.y || console.warn("Malformed xy properties in relativePosition", n),
            e[s] = e[s] || [],
            i[s] = i[s] || [];
            for (var o = 0,
            a = t.objects.length; o < a; o++) {
                var h = t.objects[o];
                if (h.gid) l = {
                    gid: h.gid,
                    name: h.name,
                    type: h.type || "",
                    x: h.x + n.x,
                    y: h.y + n.y,
                    width: h.width,
                    height: h.height,
                    visible: h.visible,
                    properties: h.properties
                },
                h.rotation && (l.rotation = h.rotation),
                e[s].push(l);
                else if (h.polyline) {
                    var l = {
                        name: h.name,
                        type: h.type,
                        x: h.x + n.x,
                        y: h.y + n.y,
                        width: h.width,
                        height: h.height,
                        visible: h.visible,
                        properties: h.properties
                    };
                    for (h.rotation && (l.rotation = h.rotation), l.polyline = [], c = 0; c < h.polyline.length; c++) l.polyline.push([h.polyline[c].x, h.polyline[c].y]);
                    i[s].push(l),
                    e[s].push(l)
                } else if (h.polygon) { (l = r(h, ["name", "type", "x", "y", "visible", "rotation", "properties"])).x += n.x,
                    l.y += n.y,
                    l.polygon = [];
                    for (var c = 0; c < h.polygon.length; c++) l.polygon.push([h.polygon[c].x, h.polygon[c].y]);
                    i[s].push(l),
                    e[s].push(l)
                } else h.ellipse ? ((l = r(h, ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"])).x += n.x, l.y += n.y, i[s].push(l), e[s].push(l)) : ((l = r(h, ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).x += n.x, l.y += n.y, l.rectangle = !0, i[s].push(l), e[s].push(l))
            }
            return {
                objectsCollection: e,
                collisionCollection: i
            }
        },
        parseTiledJSON: function(e) {
            if ("orthogonal" !== e.orientation) return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"),
            null;
            for (var i = {
                width: e.width,
                height: e.height,
                tileWidth: e.tilewidth,
                tileHeight: e.tileheight,
                orientation: e.orientation,
                format: t.Tilemap.TILED_JSON,
                version: e.version,
                properties: e.properties,
                widthInPixels: e.width * e.tilewidth,
                heightInPixels: e.height * e.tileheight
            },
            s = [], n = 0; n < e.layers.length; n++) if ("tilelayer" === e.layers[n].type) {
                var r = e.layers[n];
                if (!r.compression && r.encoding && "base64" === r.encoding) {
                    for (var o = window.atob(r.data), a = o.length, h = new Array(a), l = 0; l < a; l += 4) h[l / 4] = (o.charCodeAt(l) | o.charCodeAt(l + 1) << 8 | o.charCodeAt(l + 2) << 16 | o.charCodeAt(l + 3) << 24) >>> 0;
                    r.data = h,
                    delete r.encoding
                } else if (r.compression) {
                    console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + r.name + "'");
                    continue
                }
                k = {
                    name: r.name,
                    x: r.x,
                    y: r.y,
                    width: r.width,
                    height: r.height,
                    widthInPixels: r.width * e.tilewidth,
                    heightInPixels: r.height * e.tileheight,
                    alpha: r.opacity,
                    offsetX: r.offsetx,
                    offsetY: r.offsety,
                    visible: r.visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                },
                r.properties && (k.properties = r.properties);
                var c, u, d, p = 0,
                f = [],
                g = [],
                m = 0;
                for (a = r.data.length; m < a; m++) {
                    if (c = 0, u = !1, d = 0, (A = r.data[m]) > 536870912) switch (A > 2147483648 && (A -= 2147483648, d += 4), A > 1073741824 && (A -= 1073741824, d += 2), A > 536870912 && (A -= 536870912, d += 1), d) {
                    case 5:
                        c = Math.PI / 2;
                        break;
                    case 6:
                        c = Math.PI;
                        break;
                    case 3:
                        c = 3 * Math.PI / 2;
                        break;
                    case 4:
                        c = 0,
                        u = !0;
                        break;
                    case 7:
                        c = Math.PI / 2,
                        u = !0;
                        break;
                    case 2:
                        c = Math.PI,
                        u = !0;
                        break;
                    case 1:
                        c = 3 * Math.PI / 2,
                        u = !0
                    }
                    A > 0 ? ((F = new t.Tile(k, A, p, g.length, e.tilewidth, e.tileheight)).rotation = c, F.flipped = u, 0 !== d && (F.flippedVal = d), f.push(F)) : t.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new t.Tile(k, -1, p, g.length, e.tilewidth, e.tileheight)),
                    ++p === r.width && (g.push(f), p = 0, f = [])
                }
                k.data = g,
                s.push(k)
            }
            i.layers = s;
            var y = [];
            for (n = 0; n < e.layers.length; n++) if ("imagelayer" === e.layers[n].type) {
                var v = e.layers[n],
                x = {
                    name: v.name,
                    image: v.image,
                    x: v.x,
                    y: v.y,
                    alpha: v.opacity,
                    visible: v.visible,
                    properties: {}
                };
                v.properties && (x.properties = v.properties),
                y.push(x)
            }
            i.images = y;
            var b = [],
            _ = {},
            w = [],
            T = null;
            for (n = 0; n < e.tilesets.length; n++) {
                if ((U = e.tilesets[n]).source) console.warn("Phaser.TilemapParser - Phaser can't load external tilesets (%s). Use the Embed Tileset button and then export the map again.", U.source);
                else if (U.image) {
                    var P = new t.Tileset(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                    U.tileproperties && (P.tileProperties = U.tileproperties),
                    P.updateTileData(U.imagewidth, U.imageheight),
                    b.push(P)
                } else {
                    if (!U.tiles) throw new Error("Tileset " + U.name + " has no `image` or `tiles` property.");
                    var C = new t.ImageCollection(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                    for (var S in U.tiles) {
                        x = U.tiles[S].image;
                        var A = U.firstgid + parseInt(S, 10);
                        C.addImage(A, x)
                    }
                    w.push(C)
                }
                for (var S in U.tiles)(R = U.tiles[S].objectgroup) && (_[parseInt(S, 10) + U.firstgid] = R);
                T && (T.lastgid = U.firstgid - 1),
                T = U
            }
            if (0 === b.length && 0 === w.length) throw new Error("This tilemap has no tilesets.");
            i.tilesets = b,
            i.imagecollections = w;
            var E = {},
            M = {};
            for (n = 0; n < e.layers.length; n++) if ("objectgroup" === e.layers[n].type) {
                var R = e.layers[n];
                this.parseObjectGroup(R, E, M)
            }
            for (i.objects = E, i.collision = M, i.tiles = [], n = 0; n < i.tilesets.length; n++) {
                p = (U = i.tilesets[n]).tileMargin;
                var L = U.tileMargin,
                B = 0,
                I = 0,
                O = 0;
                for (m = U.firstgid; m < U.firstgid + U.total && (i.tiles[m] = [p, L, n], p += U.tileWidth + U.tileSpacing, ++B !== U.total) && (++I !== U.columns || (p = U.tileMargin, L += U.tileHeight + U.tileSpacing, I = 0, ++O !== U.rows)); m++);
            }
            var k, F, D, U;
            for (n = 0; n < i.layers.length; n++) for (M[(k = i.layers[n]).name] = [], U = null, l = 0; l < k.data.length; l++) {
                f = k.data[l];
                for (var G = 0; G < f.length; G++) null === (F = f[G]) || F.index < 0 || (D = i.tiles[F.index][2], (U = i.tilesets[D]).tileProperties && U.tileProperties[F.index - U.firstgid] && (F.properties = t.Utils.mixin(U.tileProperties[F.index - U.firstgid], F.properties)), (R = _[F.index]) && this.parseObjectGroup(R, i.objects, i.collision, F.layer.name, {
                    x: F.worldX + R.x,
                    y: F.worldY + R.y
                }))
            }
            return i
        }
    },
    t.Tileset = function(t, e, i, s, n, r, o) { (void 0 === i || i <= 0) && (i = 32),
        (void 0 === s || s <= 0) && (s = 32),
        void 0 === n && (n = 0),
        void 0 === r && (r = 0),
        this.name = t,
        this.firstgid = 0 | e,
        this.tileWidth = 0 | i,
        this.tileHeight = 0 | s,
        this.tileMargin = 0 | n,
        this.tileSpacing = 0 | r,
        this.properties = o || {},
        this.image = null,
        this.rows = 0,
        this.columns = 0,
        this.total = 0,
        this.drawCoords = []
    },
    t.Tileset.prototype = {
        draw: function(t, e, i, s) {
            var n = s - this.firstgid << 1;
            n >= 0 && n + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[n + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
        },
        containsTileIndex: function(t) {
            return t >= this.firstgid && t < this.firstgid + this.total
        },
        setImage: function(t) {
            this.image = t,
            this.updateTileData(t.width, t.height)
        },
        setSpacing: function(t, e) {
            this.tileMargin = 0 | t,
            this.tileSpacing = 0 | e,
            this.image && this.updateTileData(this.image.width, this.image.height)
        },
        updateTileData: function(t, e) {
            var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
            s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            i % 1 == 0 && s % 1 == 0 || console.warn("Phaser.Tileset - '%s' image tile area (%s x %s) is not a whole multiple of tile size (%s x %s + %s + %s)", this.name, t, e, this.tileWidth, this.tileHeight, this.tileMargin, this.tileSpacing),
            i = Math.floor(i),
            s = Math.floor(s),
            (this.rows && this.rows !== i || this.columns && this.columns !== s) && console.warn("Phaser.Tileset - Tile layout from image '%s' (%s rows by %s columns) differs from tileset '%s' (%s rows by %s columns)", this.image.name, s, i, this.name, this.columns, this.rows),
            this.rows = i,
            this.columns = s,
            this.total = i * s,
            this.drawCoords.length = 0;
            for (var n = this.tileMargin,
            r = this.tileMargin,
            o = 0; o < this.rows; o++) {
                for (var a = 0; a < this.columns; a++) this.drawCoords.push(n),
                this.drawCoords.push(r),
                n += this.tileWidth + this.tileSpacing;
                n = this.tileMargin,
                r += this.tileHeight + this.tileSpacing
            }
        }
    },
    t.Tileset.prototype.constructor = t.Tileset,
    t.Particle = function(e, i, s, n, r) {
        t.Sprite.call(this, e, i, s, n, r),
        this.autoScale = !1,
        this.scaleData = null,
        this._s = 0,
        this.autoAlpha = !1,
        this.alphaData = null,
        this._a = 0
    },
    t.Particle.prototype = Object.create(t.Sprite.prototype),
    t.Particle.prototype.constructor = t.Particle,
    t.Particle.prototype.update = function() {
        this.autoScale && (--this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1),
        this.autoAlpha && (--this._a ? this.alpha = this.alphaData[this._a].v: this.autoAlpha = !1)
    },
    t.Particle.prototype.onEmit = function() {},
    t.Particle.prototype.setAlphaData = function(t) {
        this.alphaData = t,
        this._a = t.length - 1,
        this.alpha = this.alphaData[this._a].v,
        this.autoAlpha = !0
    },
    t.Particle.prototype.setScaleData = function(t) {
        this.scaleData = t,
        this._s = t.length - 1,
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y),
        this.autoScale = !0
    },
    t.Particle.prototype.reset = function(e, i, s) {
        return t.Component.Reset.prototype.reset.call(this, e, i, s),
        this.alpha = 1,
        this.scale.set(1),
        this.autoScale = !1,
        this.autoAlpha = !1,
        this
    },
    t.Particles = function(t) {
        this.game = t,
        this.emitters = {},
        this.ID = 0
    },
    t.Particles.prototype = {
        add: function(t) {
            return this.emitters[t.id] = t,
            t
        },
        remove: function(t) {
            delete this.emitters[t.id]
        }
    },
    t.Particles.prototype.constructor = t.Particles,
    t.Particles.Arcade = {},
    t.Particles.Arcade.Emitter = function(e, i, s, n) {
        this.maxParticles = n || 50,
        t.Group.call(this, e),
        this._id = this.game.particles.ID++,
        this.name = "emitter" + this.id,
        this.type = t.EMITTER,
        this.physicsType = t.GROUP,
        this.area = new t.Rectangle(i, s, 1, 1),
        this.minAngle = null,
        this.maxAngle = null,
        this.minSpeed = 0,
        this.maxSpeed = 100,
        this.minParticleSpeed = new t.Point( - 100, -100),
        this.maxParticleSpeed = new t.Point(100, 100),
        this.minParticleScale = 1,
        this.maxParticleScale = 1,
        this.scaleData = null,
        this.minRotation = -360,
        this.maxRotation = 360,
        this.minParticleAlpha = 1,
        this.maxParticleAlpha = 1,
        this.alphaData = null,
        this.particleClass = t.Particle,
        this.particleDrag = new t.Point,
        this.angularDrag = 0,
        this.frequency = 100,
        this.lifespan = 2e3,
        this.bounce = new t.Point,
        this.on = !1,
        this.particleAnchor = new t.Point(.5, .5),
        this.blendMode = t.blendModes.NORMAL,
        this.emitX = i,
        this.emitY = s,
        this.autoScale = !1,
        this.autoAlpha = !1,
        this.particleBringToTop = !1,
        this.particleSendToBack = !1,
        this.counts = {
            emitted: 0,
            failed: 0,
            totalEmitted: 0,
            totalFailed: 0
        },
        this._gravity = new t.Point(0, 100),
        this._minParticleScale = new t.Point(1, 1),
        this._maxParticleScale = new t.Point(1, 1),
        this._total = 0,
        this._timer = 0,
        this._counter = 0,
        this._flowQuantity = 0,
        this._flowTotal = 0,
        this._explode = !0,
        this._frames = null
    },
    t.Particles.Arcade.Emitter.prototype = Object.create(t.Group.prototype),
    t.Particles.Arcade.Emitter.prototype.constructor = t.Particles.Arcade.Emitter,
    t.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.counts.emitted = 0, this.counts.failed = 0, this.on && this.game.time.time >= this._timer) if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal) if (this._flowQuantity > 0) {
            for (t = 0; t < this._flowQuantity; t++) if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                this.on = !1;
                break
            }
        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
        else this.emitParticle() && (this._counter++, this._total > 0 && this._counter >= this._total && (this.on = !1));
        for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
    },
    t.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n, r) {
        void 0 === e && (e = 0),
        void 0 === i && (i = this.maxParticles),
        void 0 === s && (s = !1),
        void 0 === n && (n = !1),
        void 0 === r && (r = null);
        var o, a = 0,
        h = t,
        l = e;
        for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); a < i;) Array.isArray(t) && (h = this.game.rnd.pick(t)),
        Array.isArray(e) && (l = this.game.rnd.pick(e)),
        o = new this.particleClass(this.game, 0, 0, h, l, r),
        this.game.physics.arcade.enable(o, !1),
        o.body.checkCollision.none = !s,
        o.body.collideWorldBounds = n,
        o.body.skipQuadTree = !0,
        o.exists = !1,
        o.visible = !1,
        o.anchor.copyFrom(this.particleAnchor),
        this.add(o),
        a++;
        return this
    },
    t.Particles.Arcade.Emitter.prototype.kill = function() {
        return this.on = !1,
        this.alive = !1,
        this.exists = !1,
        this
    },
    t.Particles.Arcade.Emitter.prototype.revive = function() {
        return this.alive = !0,
        this.exists = !0,
        this
    },
    t.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
        return void 0 === e && (e = this.maxParticles),
        this._flowTotal = 0,
        this.start(!0, t, 0, e, !1),
        this
    },
    t.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, n) {
        return null != e || (e = 250),
        void 0 !== i && 0 !== i || (i = 1),
        void 0 === s && (s = -1),
        void 0 === n && (n = !0),
        i > this.maxParticles && (i = this.maxParticles),
        this._counter = 0,
        this._flowQuantity = i,
        this._flowTotal = s,
        n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i),
        this
    },
    t.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
        if (void 0 === t && (t = !0), void 0 === e && (e = 0), null != i || (i = 250), void 0 === s && (s = 0), void 0 === n && (n = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n) for (var r = 0; r < s; r++) this.emitParticle();
        else this.on = !0,
        this._total = s,
        this._counter = 0,
        this._timer = this.game.time.time + i * this.game.time.slowMotion;
        return this
    },
    t.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
        void 0 === t && (t = null),
        void 0 === e && (e = null);
        var n = this.getNextParticle();
        if (null === n) return this.counts.failed++,
        this.counts.totalFailed++,
        !1;
        this.counts.emitted++,
        this.counts.totalEmitted++;
        var r = this.game.rnd;
        void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && (n.loadTexture(i), n.frame = Array.isArray(this._frames) ? r.pick(this._frames) : this._frames);
        var o = this.emitX,
        a = this.emitY;
        return null !== t ? o = t: this.width > 1 && (o = r.between(this.left, this.right)),
        null !== e ? a = e: this.height > 1 && (a = r.between(this.top, this.bottom)),
        this.resetParticle(n, o, a),
        !0
    },
    t.Particles.Arcade.Emitter.prototype.getNextParticle = function() {
        for (var t = this.length; t--;) {
            var e = this.next();
            if (!e.exists) return e
        }
        return null
    },
    t.Particles.Arcade.Emitter.prototype.resetParticle = function(t, e, i) {
        var s = this.game.rnd;
        t.reset(e, i),
        t.angle = 0,
        t.lifespan = this.lifespan,
        this.particleBringToTop ? this.bringToTop(t) : this.particleSendToBack && this.sendToBack(t),
        this.autoScale ? t.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? t.scale.set(s.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y ? t.scale.set(s.realInRange(this._minParticleScale.x, this._maxParticleScale.x), s.realInRange(this._minParticleScale.y, this._maxParticleScale.y)) : t.scale.set(this._minParticleScale.x, this._minParticleScale.y),
        this.autoAlpha ? t.setAlphaData(this.alphaData) : t.alpha = s.realInRange(this.minParticleAlpha, this.maxParticleAlpha),
        t.blendMode = this.blendMode;
        var n = t.body;
        n.updateBounds(),
        n.bounce.copyFrom(this.bounce),
        n.drag.copyFrom(this.particleDrag),
        null != this.minAngle && null != this.maxAngle ? this.game.physics.arcade.velocityFromAngle(this.minAngle === this.maxAngle ? this.minAngle: s.between(this.minAngle, this.maxAngle), this.minSpeed === this.maxSpeed ? this.minSpeed: s.between(this.minSpeed, this.maxSpeed), n.velocity) : (n.velocity.x = s.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), n.velocity.y = s.between(this.minParticleSpeed.y, this.maxParticleSpeed.y)),
        n.angularVelocity = s.between(this.minRotation, this.maxRotation),
        n.gravity.copyFrom(this.gravity),
        n.angularDrag = this.angularDrag,
        t.onEmit()
    },
    t.Particles.Arcade.Emitter.prototype.destroy = function() {
        this.game.particles.remove(this),
        t.Group.prototype.destroy.call(this, !0, !1)
    },
    t.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
        return this.area.width = t,
        this.area.height = e,
        this
    },
    t.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
        return t = t || 0,
        e = e || 0,
        this.minParticleSpeed.x = t,
        this.maxParticleSpeed.x = e,
        this
    },
    t.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
        return t = t || 0,
        e = e || 0,
        this.minParticleSpeed.y = t,
        this.maxParticleSpeed.y = e,
        this
    },
    t.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
        return t = t || 0,
        e = e || 0,
        this.minRotation = t,
        this.maxRotation = e,
        this
    },
    t.Particles.Arcade.Emitter.prototype.setAlpha = function(e, i, s, n, r) {
        if (void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 0), void 0 === n && (n = t.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleAlpha = e, this.maxParticleAlpha = i, this.autoAlpha = !1, s > 0 && e !== i) {
            var o = {
                v: e
            },
            a = this.game.make.tween(o).to({
                v: i
            },
            s, n);
            a.yoyo(r),
            this.alphaData = a.generateData(60),
            this.alphaData.reverse(),
            this.autoAlpha = !0
        }
        return this
    },
    t.Particles.Arcade.Emitter.prototype.setScale = function(e, i, s, n, r, o, a) {
        if (void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = t.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(e, s), this._maxParticleScale.set(i, n), this.autoScale = !1, r > 0 && (e !== i || s !== n)) {
            var h = {
                x: e,
                y: s
            },
            l = this.game.make.tween(h).to({
                x: i,
                y: n
            },
            r, o);
            l.yoyo(a),
            this.scaleData = l.generateData(60),
            this.scaleData.reverse(),
            this.autoScale = !0
        }
        return this
    },
    t.Particles.Arcade.Emitter.prototype.setAngle = function(t, e, i, s) {
        return this.minAngle = t,
        this.maxAngle = e,
        null != i && (this.minSpeed = i),
        null != s && (this.maxSpeed = s),
        this
    },
    t.Particles.Arcade.Emitter.prototype.at = function(t) {
        return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height),
        this
    },
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "gravity", {
        get: function() {
            return this._gravity
        },
        set: function(t) {
            "number" == typeof t ? this._gravity.y = t: this._gravity = t
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "id", {
        get: function() {
            return this._id
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width
        },
        set: function(t) {
            this.area.width = t
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height
        },
        set: function(t) {
            this.area.height = t
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX
        },
        set: function(t) {
            this.emitX = t
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY
        },
        set: function(t) {
            this.emitY = t
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2)
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2)
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2)
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2)
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "output", {
        get: function() {
            return 1e3 * this._flowQuantity / this.frequency
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "lifespanOutput", {
        get: function() {
            return (0 === this.lifespan ? 1 / 0 : this.lifespan) * this._flowQuantity / this.frequency
        }
    }),
    Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "remainder", {
        get: function() {
            return this.maxParticles - this.lifespanOutput
        }
    }),
    t.Weapon = function(e, i) {
        t.Plugin.call(this, e, i),
        this.bullets = null,
        this.autoExpandBulletsGroup = !1,
        this.autofire = !1,
        this.shots = 0,
        this.fireLimit = 0,
        this.fireRate = 100,
        this.fireRateVariance = 0,
        this.fireFrom = new t.Rectangle(0, 0, 1, 1),
        this.fireAngle = t.ANGLE_UP,
        this.bulletInheritSpriteSpeed = !1,
        this.bulletAnimation = "",
        this.bulletFrameRandom = !1,
        this.bulletFrameCycle = !1,
        this.bulletWorldWrap = !1,
        this.bulletWorldWrapPadding = 0,
        this.bulletAngleOffset = 0,
        this.bulletAngleVariance = 0,
        this.bulletSpeed = 200,
        this.bulletSpeedVariance = 0,
        this.bulletLifespan = 0,
        this.bulletKillDistance = 0,
        this.bulletGravity = new t.Point(0, 0),
        this.bulletRotateToVelocity = !1,
        this.bulletKey = "",
        this.bulletFrame = "",
        this._bulletClass = t.Bullet,
        this._bulletCollideWorldBounds = !1,
        this._bulletKillType = t.Weapon.KILL_WORLD_BOUNDS,
        this._data = {
            customBody: !1,
            width: 0,
            height: 0,
            offsetX: 0,
            offsetY: 0
        },
        this.bounds = new t.Rectangle,
        this.bulletBounds = e.world.bounds,
        this.bulletFrames = [],
        this.bulletFrameIndex = 0,
        this.anims = {},
        this.onFire = new t.Signal,
        this.onKill = new t.Signal,
        this.onFireLimit = new t.Signal,
        this.trackedSprite = null,
        this.trackedPointer = null,
        this.multiFire = !1,
        this._hasFired = !1,
        this.trackRotation = !1,
        this.trackOffset = new t.Point,
        this._nextFire = 0,
        this._tempNextFire = 0,
        this._rotatedPoint = new t.Point
    },
    t.Weapon.prototype = Object.create(t.Plugin.prototype),
    t.Weapon.prototype.constructor = t.Weapon,
    t.Weapon.KILL_NEVER = 0,
    t.Weapon.KILL_LIFESPAN = 1,
    t.Weapon.KILL_DISTANCE = 2,
    t.Weapon.KILL_WEAPON_BOUNDS = 3,
    t.Weapon.KILL_CAMERA_BOUNDS = 4,
    t.Weapon.KILL_WORLD_BOUNDS = 5,
    t.Weapon.KILL_STATIC_BOUNDS = 6,
    t.Weapon.prototype.createBullets = function(e, i, s, n) {
        return void 0 === e && (e = 1),
        void 0 === n && (n = this.game.world),
        this.bullets && !this.bullets.game && (this.bullets = null),
        this.bullets || (this.bullets = this.game.add.physicsGroup(t.Physics.ARCADE, n), this.bullets.classType = this._bulletClass),
        0 !== e && ( - 1 === e && (this.autoExpandBulletsGroup = !0, e = 1), this.bullets.createMultiple(e, i, s), this.bullets.setAll("data.bulletManager", this), this.bulletKey = i, this.bulletFrame = s),
        this
    },
    t.Weapon.prototype.forEach = function(t, e) {
        return this.bullets.forEachExists(t, e, arguments),
        this
    },
    t.Weapon.prototype.pauseAll = function() {
        return this.bullets.setAll("body.enable", !1),
        this
    },
    t.Weapon.prototype.resumeAll = function() {
        return this.bullets.setAll("body.enable", !0),
        this
    },
    t.Weapon.prototype.killAll = function() {
        return this.bullets.callAllExists("kill", !0),
        this.bullets.setAll("body.enable", !0),
        this
    },
    t.Weapon.prototype.resetShots = function(t) {
        return this.shots = 0,
        void 0 !== t && (this.fireLimit = t),
        this
    },
    t.Weapon.prototype.destroy = function() {
        this.parent.remove(this, !1),
        this.bullets.destroy(),
        this.game = null,
        this.parent = null,
        this.active = !1,
        this.visible = !1
    },
    t.Weapon.prototype.update = function() {
        this._bulletKillType === t.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)),
        this.autofire && this.fire()
    },
    t.Weapon.prototype.postRender = function() {
        this.multiFire && this._hasFired && (this._hasFired = !1, this._nextFire = this._tempNextFire)
    },
    t.Weapon.prototype.trackSprite = function(t, e, i, s) {
        return void 0 === e && (e = 0),
        void 0 === i && (i = 0),
        void 0 === s && (s = !1),
        this.trackedPointer = null,
        this.trackedSprite = t,
        this.trackRotation = s,
        this.trackOffset.set(e, i),
        this
    },
    t.Weapon.prototype.trackPointer = function(t, e, i) {
        return void 0 === t && (t = this.game.input.activePointer),
        void 0 === e && (e = 0),
        void 0 === i && (i = 0),
        this.trackedPointer = t,
        this.trackedSprite = null,
        this.trackRotation = !1,
        this.trackOffset.set(e, i),
        this
    },
    t.Weapon.prototype.fireMany = function(t, e) {
        this.multiFire = !0;
        var i = [],
        s = this;
        return e || this.trackedSprite || this.trackedPointer ? t.forEach(function(t) {
            i.push(s.fire(e, null, null, t.x, t.y))
        }) : t.forEach(function(t) {
            i.push(s.fire(t))
        }),
        i
    },
    t.Weapon.prototype.fireOffset = function(t, e) {
        return void 0 === t && (t = 0),
        void 0 === e && (e = 0),
        this.fire(null, null, null, t, e)
    },
    t.Weapon.prototype.fire = function(e, i, s, n, r) {
        if (void 0 === i && (i = null), void 0 === s && (s = null), this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return null;
        var o = this.bulletSpeed;
        0 !== this.bulletSpeedVariance && (o += t.Math.between( - this.bulletSpeedVariance, this.bulletSpeedVariance)),
        e ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(e.x, e.y) : (this.fireFrom.x = e.x, this.fireFrom.y = e.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.worldRotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (o += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)),
        void 0 !== n && (this.fireFrom.x += n),
        void 0 !== r && (this.fireFrom.y += r);
        var a = this.fireFrom.width > 1 ? this.fireFrom.randomX: this.fireFrom.x,
        h = this.fireFrom.height > 1 ? this.fireFrom.randomY: this.fireFrom.y,
        l = this.trackRotation ? this.trackedSprite.angle: this.fireAngle;
        null !== i && null !== s && (l = this.game.math.radToDeg(Math.atan2(s - h, i - a))),
        0 !== this.bulletAngleVariance && (l += t.Math.between( - this.bulletAngleVariance, this.bulletAngleVariance));
        var c = 0,
        u = 0;
        0 === l || 180 === l ? c = Math.cos(this.game.math.degToRad(l)) * o: 90 === l || 270 === l ? u = Math.sin(this.game.math.degToRad(l)) * o: (c = Math.cos(this.game.math.degToRad(l)) * o, u = Math.sin(this.game.math.degToRad(l)) * o);
        var d = null;
        if (this.autoExpandBulletsGroup ? (d = this.bullets.getFirstExists(!1, !0, a, h, this.bulletKey, this.bulletFrame)).data.bulletManager = this: d = this.bullets.getFirstExists(!1), d) {
            if (d.reset(a, h), d.data.fromX = a, d.data.fromY = h, d.data.killType = this.bulletKillType, d.data.killDistance = this.bulletKillDistance, d.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === t.Weapon.KILL_LIFESPAN && (d.lifespan = this.bulletLifespan), d.angle = l + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                if (null === d.animations.getAnimation(this.bulletAnimation)) {
                    var p = this.anims[this.bulletAnimation];
                    d.animations.add(p.name, p.frames, p.frameRate, p.loop, p.useNumericIndex)
                }
                d.animations.play(this.bulletAnimation)
            } else this.bulletFrameCycle ? (d.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (d.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
            d.data.bodyDirty && (this._data.customBody && d.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), d.body.collideWorldBounds = this.bulletCollideWorldBounds, d.data.bodyDirty = !1),
            d.body.velocity.set(c, u),
            d.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y);
            var f = 0;
            if (0 !== this.bulletSpeedVariance) {
                var g = this.fireRate; (g += t.Math.between( - this.fireRateVariance, this.fireRateVariance)) < 0 && (g = 0),
                f = this.game.time.now + g
            } else f = this.game.time.now + this.fireRate;
            this.multiFire ? this._hasFired || (this._hasFired = !0, this._tempNextFire = f, this.shots++) : (this._nextFire = f, this.shots++),
            this.onFire.dispatch(d, this, o),
            this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
        }
        return d
    },
    t.Weapon.prototype.fireAtPointer = function(t) {
        return void 0 === t && (t = this.game.input.activePointer),
        this.fire(null, t.worldX, t.worldY)
    },
    t.Weapon.prototype.fireAtSprite = function(t) {
        return this.fire(null, t.world.x, t.world.y)
    },
    t.Weapon.prototype.fireAtXY = function(t, e) {
        return this.fire(null, t, e)
    },
    t.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
        return void 0 === i && (i = 0),
        void 0 === s && (s = 0),
        this._data.customBody = !0,
        this._data.width = t,
        this._data.height = e,
        this._data.offsetX = i,
        this._data.offsetY = s,
        this.bullets.callAll("body.setSize", "body", t, e, i, s),
        this.bullets.setAll("data.bodyDirty", !1),
        this
    },
    t.Weapon.prototype.setBulletFrames = function(e, i, s, n) {
        return void 0 === s && (s = !0),
        void 0 === n && (n = !1),
        this.bulletFrames = t.ArrayUtils.numberArray(e, i),
        this.bulletFrameIndex = 0,
        this.bulletFrameCycle = s,
        this.bulletFrameRandom = n,
        this
    },
    t.Weapon.prototype.addBulletAnimation = function(t, e, i, s, n) {
        return this.anims[t] = {
            name: t,
            frames: e,
            frameRate: i,
            loop: s,
            useNumericIndex: n
        },
        this.bullets.callAll("animations.add", "animations", t, e, i, s, n),
        this.bulletAnimation = t,
        this
    },
    t.Weapon.prototype.debug = function(t, e, i) {
        void 0 === t && (t = 16),
        void 0 === e && (e = 32),
        void 0 === i && (i = !1),
        this.game.debug.text("Weapon Plugin", t, e),
        this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24),
        i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
    },
    Object.defineProperty(t.Weapon.prototype, "bulletClass", {
        get: function() {
            return this._bulletClass
        },
        set: function(t) {
            this._bulletClass = t,
            this.bullets && (this.bullets.classType = this._bulletClass)
        }
    }),
    Object.defineProperty(t.Weapon.prototype, "bulletKillType", {
        get: function() {
            return this._bulletKillType
        },
        set: function(e) {
            switch (e) {
            case t.Weapon.KILL_STATIC_BOUNDS:
            case t.Weapon.KILL_WEAPON_BOUNDS:
                this.bulletBounds = this.bounds;
                break;
            case t.Weapon.KILL_CAMERA_BOUNDS:
                this.bulletBounds = this.game.camera.view;
                break;
            case t.Weapon.KILL_WORLD_BOUNDS:
                this.bulletBounds = this.game.world.bounds
            }
            this._bulletKillType = e
        }
    }),
    Object.defineProperty(t.Weapon.prototype, "bulletCollideWorldBounds", {
        get: function() {
            return this._bulletCollideWorldBounds
        },
        set: function(t) {
            this._bulletCollideWorldBounds = t,
            this.bullets.setAll("body.collideWorldBounds", t),
            this.bullets.setAll("data.bodyDirty", !1)
        }
    }),
    Object.defineProperty(t.Weapon.prototype, "x", {
        get: function() {
            return this.fireFrom.x
        },
        set: function(t) {
            this.fireFrom.x = t
        }
    }),
    Object.defineProperty(t.Weapon.prototype, "y", {
        get: function() {
            return this.fireFrom.y
        },
        set: function(t) {
            this.fireFrom.y = t
        }
    }),
    t.Bullet = function(e, i, s, n, r) {
        t.Sprite.call(this, e, i, s, n, r),
        this.anchor.set(.5),
        this.data = {
            bulletManager: null,
            fromX: 0,
            fromY: 0,
            bodyDirty: !0,
            rotateToVelocity: !1,
            killType: 0,
            killDistance: 0
        }
    },
    t.Bullet.prototype = Object.create(t.Sprite.prototype),
    t.Bullet.prototype.constructor = t.Bullet,
    t.Bullet.prototype.kill = function() {
        return this.alive = !1,
        this.exists = !1,
        this.visible = !1,
        this.data.bulletManager.onKill.dispatch(this),
        this
    },
    t.Bullet.prototype.update = function() {
        this.exists && (this.data.killType > t.Weapon.KILL_LIFESPAN && (this.data.killType === t.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = this.body.velocity.atan()), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
    },
    t.Video = function(e, i, s) {
        if (void 0 === i && (i = null), void 0 === s && (s = null), this.game = e, this.key = i, this.width = 0, this.height = 0, this.type = t.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new t.Signal, this.onChangeSource = new t.Signal, this.onComplete = new t.Signal, this.onAccess = new t.Signal, this.onError = new t.Signal, this.onTimeout = new t.Signal, this.onTouchUnlock = new t.Signal, this.playWhenUnlocked = !0, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._pendingChangeSource = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, i && this.game.cache.checkVideoKey(i)) {
            var n = this.game.cache.getVideo(i);
            n.isBlob ? this.createVideoFromBlob(n.data) : this.video = n.data,
            this.width = this.video.videoWidth,
            this.height = this.video.videoHeight
        } else s && this.createVideoFromURL(s, !1);
        this.video && !s ? (this.baseTexture = new PIXI.BaseTexture(this.video, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(t.Cache.DEFAULT.baseTexture.source, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)),
        this.texture = new PIXI.Texture(this.baseTexture),
        this.textureFrame = new t.Frame(0, 0, 0, this.width, this.height, "video"),
        this.texture.setFrame(this.textureFrame),
        this.texture.valid = !1,
        null !== i && this.video && (this.texture.valid = this.video.canplay),
        this.snapshot = null,
        t.BitmapData && (this.snapshot = new t.BitmapData(this.game, "", this.width, this.height)),
        this.game.device.needsTouchUnlock() ? this.setTouchLock() : n && (n.locked = !1)
    },
    t.Video.prototype = {
        connectToMediaStream: function(t, e) {
            return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)),
            this
        },
        startMediaStream: function(t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"),
            !1;
            null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()),
            this.removeVideoElement(),
            this.video = document.createElement("video"),
            this.video.setAttribute("autoplay", "autoplay"),
            null !== e && (this.video.width = e),
            null !== i && (this.video.height = i),
            this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: t,
                    video: !0
                },
                this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
            } catch(t) {
                this.getUserMediaError(t)
            }
            return this
        },
        getUserMediaTimeout: function() {
            clearTimeout(this._timeOutID),
            this.onTimeout.dispatch(this)
        },
        getUserMediaError: function(t) {
            clearTimeout(this._timeOutID),
            this.onError.dispatch(this, t)
        },
        getUserMediaSuccess: function(t) {
            clearTimeout(this._timeOutID),
            this.videoStream = t,
            void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t: void 0 !== this.video.srcObject ? this.video.srcObject = t: this.video.src = window.URL && window.URL.createObjectURL(t) || t;
            var e = this;
            this.video.onloadeddata = function() {
                var t = 10; !
                function i() {
                    if (t > 0) if (e.video.videoWidth > 0) {
                        var s = e.video.videoWidth,
                        n = e.video.videoHeight;
                        isNaN(e.video.videoHeight) && (n = s / (4 / 3)),
                        e.video.play(),
                        e.isStreaming = !0,
                        e.baseTexture.source = e.video,
                        e.updateTexture(null, s, n),
                        e.onAccess.dispatch(e)
                    } else window.setTimeout(i, 500);
                    else console.warn("Unable to connect to video stream. Webcam error?");
                    t--
                } ()
            }
        },
        createVideoFromBlob: function(t) {
            var e = this;
            return this.video = document.createElement("video"),
            this.video.controls = !1,
            this.video.setAttribute("autoplay", "autoplay"),
            this.video.addEventListener("loadeddata",
            function(t) {
                e.updateTexture(t)
            },
            !0),
            this.video.src = window.URL.createObjectURL(t),
            this.video.canplay = !0,
            this
        },
        createVideoFromURL: function(t, e) {
            return void 0 === e && (e = !1),
            this.texture && (this.texture.valid = !1),
            this.video = document.createElement("video"),
            this.video.controls = !1,
            e && this.video.setAttribute("autoplay", "autoplay"),
            this.video.src = t,
            this.video.canplay = !0,
            this.video.load(),
            this.retry = this.retryLimit,
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
            this.key = t,
            this
        },
        updateTexture: function(t, e, i) {
            var s = !1;
            null != e || (e = this.video.videoWidth, s = !0),
            null != i || (i = this.video.videoHeight),
            this.width = e,
            this.height = i,
            this.baseTexture.source !== this.video && (this.baseTexture.source = this.video),
            this.baseTexture.forceLoaded(e, i),
            this.texture.frame.resize(e, i),
            this.texture.width = e,
            this.texture.height = i,
            this.texture.valid = !0,
            this.snapshot && this.snapshot.resize(e, i),
            s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
        },
        complete: function() {
            this.onComplete.dispatch(this)
        },
        play: function(t, e) {
            return this._pendingChangeSource ? this: (void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop": "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this)
        },
        playHandler: function() {
            this.video.removeEventListener("playing", this._playCallback, !0),
            this.updateTexture()
        },
        stop: function() {
            return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)),
            this.game.onPause.remove(this.setPause, this),
            this.game.onResume.remove(this.setResume, this),
            this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : this.video.srcObject ? (this.video.srcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                t.stop()
            }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()),
            this
        },
        add: function(t) {
            if (Array.isArray(t)) for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
            else t.loadTexture(this);
            return this
        },
        addToWorld: function(t, e, i, s, n, r) {
            n = n || 1,
            r = r || 1;
            var o = this.game.add.image(t, e, this);
            return o.anchor.set(i, s),
            o.scale.set(n, r),
            o
        },
        render: function() { ! this.disableTextureUpload && this.playing && this.baseTexture.dirty()
        },
        setMute: function() {
            this._muted || (this._muted = !0, this.video.muted = !0)
        },
        unsetMute: function() {
            this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
        },
        setPause: function() {
            this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
        },
        setResume: function() { ! this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
        },
        changeSource: function(t, e) {
            return void 0 === e && (e = !0),
            this.texture.valid = !1,
            this.video.pause(),
            this._pendingChangeSource = !0,
            this.retry = this.retryLimit,
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
            this.video.src = t,
            this.video.load(),
            this._autoplay = e,
            e || (this.paused = !0),
            this
        },
        checkVideoProgress: function() {
            4 === this.video.readyState ? (this._pendingChangeSource = !1, this.updateTexture()) : --this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming)
        },
        setTouchLock: function() {
            this.game.input.addTouchLockCallback(this.unlock, this, !0),
            this.touchLocked = !0
        },
        unlock: function() {
            if (this.touchLocked = !1, this.playWhenUnlocked && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)), this.key) {
                var t = this.game.cache.getVideo(this.key);
                t && !t.isBlob && (t.locked = !1)
            }
            return this.onTouchUnlock.dispatch(this),
            !0
        },
        grab: function(t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(),
            this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i),
            this.snapshot;
            console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable")
        },
        removeVideoElement: function() {
            if (this.video) {
                for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                this.video.removeAttribute("autoplay"),
                this.video.removeAttribute("src"),
                this.video = null
            }
        },
        destroy: function() {
            this.stop(),
            this.removeVideoElement(),
            this.touchLocked && this.game.input.removeTouchLockCallback(this.unlock, this),
            this._retryID && window.clearTimeout(this._retryID)
        }
    },
    Object.defineProperty(t.Video.prototype, "currentTime", {
        get: function() {
            return this.video ? this.video.currentTime: 0
        },
        set: function(t) {
            this.video.currentTime = t
        }
    }),
    Object.defineProperty(t.Video.prototype, "duration", {
        get: function() {
            return this.video ? this.video.duration: 0
        }
    }),
    Object.defineProperty(t.Video.prototype, "progress", {
        get: function() {
            return this.video ? this.video.currentTime / this.video.duration: 0
        }
    }),
    Object.defineProperty(t.Video.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(t) {
            if (t = t || null) {
                if (this._muted) return;
                this._codeMuted = !0,
                this.setMute()
            } else {
                if (!this._muted) return;
                this._codeMuted = !1,
                this.unsetMute()
            }
        }
    }),
    Object.defineProperty(t.Video.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(t) {
            if (t = t || null, !this.touchLocked) if (t) {
                if (this._paused) return;
                this._codePaused = !0,
                this.setPause()
            } else {
                if (!this._paused) return;
                this._codePaused = !1,
                this.setResume()
            }
        }
    }),
    Object.defineProperty(t.Video.prototype, "volume", {
        get: function() {
            return this.video ? this.video.volume: 1
        },
        set: function(t) {
            t < 0 ? t = 0 : t > 1 && (t = 1),
            this.video && (this.video.volume = t)
        }
    }),
    Object.defineProperty(t.Video.prototype, "playbackRate", {
        get: function() {
            return this.video ? this.video.playbackRate: 1
        },
        set: function(t) {
            this.video && (this.video.playbackRate = t)
        }
    }),
    Object.defineProperty(t.Video.prototype, "loop", {
        get: function() {
            return !! this.video && this.video.loop
        },
        set: function(t) {
            t && this.video ? this.video.loop = "loop": this.video && (this.video.loop = "")
        }
    }),
    Object.defineProperty(t.Video.prototype, "playing", {
        get: function() {
            return ! (!this.video || this.video.paused && this.video.ended)
        }
    }),
    t.Video.prototype.constructor = t.Video,
    void 0 === PIXI.blendModes && (PIXI.blendModes = t.blendModes),
    void 0 === PIXI.scaleModes && (PIXI.scaleModes = t.scaleModes),
    void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)),
    void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new t.Matrix),
    PIXI.TextureSilentFail = !0,
    PIXI.canUseNewCanvasBlendModes = function() {
        return t.Device.canUseMultiply
    },
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = t), exports.Phaser = t) : "undefined" != typeof define && define.amd ? define("Phaser", this.Phaser = t) : this.Phaser = t,
    t
}.call(this);
function Swipe(t, i) {
    var e = this;
    e.DIRECTION_UP = 1,
    e.DIRECTION_DOWN = 2,
    e.DIRECTION_LEFT = 4,
    e.DIRECTION_RIGHT = 8,
    e.DIRECTION_UP_RIGHT = 16,
    e.DIRECTION_UP_LEFT = 32,
    e.DIRECTION_DOWN_RIGHT = 64,
    e.DIRECTION_DOWN_LEFT = 128,
    e.game = t,
    e.model = void 0 !== i ? i: null,
    e.dragLength = 100,
    e.diagonalDelta = 50,
    e.swiping = !1,
    e.direction = null,
    e.tmpDirection = null,
    e.tmpCallback = null,
    e.diagonalDisabled = !1,
    this.game.input.onDown.add(function() {
        e.swiping = !0
    }),
    this.game.input.onUp.add(function() {
        e.swiping = !1
    }),
    this.setupKeyboard()
}
Swipe.prototype.setupKeyboard = function() {
    var t = this,
    i = this.game.input.keyboard.addKey(Phaser.Keyboard.UP);
    i.onDown.add(function() {
        if (null !== t.tmpDirection) {
            switch (t.tmpDirection) {
            case t.DIRECTION_LEFT:
                t.direction = t.DIRECTION_UP_LEFT,
                null !== t.model && t.model.upLeft && t.model.upLeft();
                break;
            case t.DIRECTION_RIGHT:
                t.direction = t.DIRECTION_UP_RIGHT,
                null !== t.model && t.model.upRight && t.model.upRight();
                break;
            default:
                t.direction = t.DIRECTION_UP,
                null !== t.model && t.model.up && t.model.up()
            }
            t.tmpDirection = null,
            t.tmpCallback = null
        } else t.tmpDirection = t.DIRECTION_UP,
        t.tmpCallback = null !== t.model && t.model.up ? t.model.up: null
    }),
    i.onUp.add(this.keyUp, this);
    var e = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
    e.onDown.add(function() {
        if (null !== t.tmpDirection) {
            switch (t.tmpDirection) {
            case t.DIRECTION_LEFT:
                t.direction = t.DIRECTION_DOWN_LEFT,
                null !== t.model && t.model.downLeft && t.model.downLeft();
                break;
            case t.DIRECTION_RIGHT:
                t.direction = t.DIRECTION_DOWN_RIGHT,
                null !== t.model && t.model.downRight && t.model.downRight();
                break;
            default:
                t.direction = t.DIRECTION_DOWN,
                null !== t.model && t.model.down && t.model.down()
            }
            t.tmpDirection = null,
            t.tmpCallback = null
        } else t.tmpDirection = t.DIRECTION_DOWN,
        t.tmpCallback = null !== t.model && t.model.down ? t.model.down: null
    }),
    e.onUp.add(this.keyUp, this);
    var l = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
    l.onDown.add(function() {
        if (null !== t.tmpDirection) {
            switch (t.tmpDirection) {
            case t.DIRECTION_UP:
                t.direction = t.DIRECTION_UP_LEFT,
                null !== t.model && t.model.upLeft && t.model.upLeft();
                break;
            case t.DIRECTION_DOWN:
                t.direction = t.DIRECTION_DOWN_LEFT,
                null !== t.model && t.model.downLeft && t.model.downLeft();
                break;
            default:
                t.direction = t.DIRECTION_LEFT,
                null !== t.model && t.model.left && t.model.left()
            }
            t.tmpDirection = null,
            t.tmpCallback = null
        } else t.tmpDirection = t.DIRECTION_LEFT,
        t.tmpCallback = null !== t.model && t.model.left ? t.model.left: null
    }),
    l.onUp.add(this.keyUp, this);
    var o = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
    o.onDown.add(function() {
        if (null !== t.tmpDirection) {
            switch (t.tmpDirection) {
            case t.DIRECTION_UP:
                t.direction = t.DIRECTION_UP_RIGHT,
                null !== t.model && t.model.upRight && t.model.upRight();
                break;
            case t.DIRECTION_DOWN:
                t.direction = t.DIRECTION_DOWN_RIGHT,
                null !== t.model && t.model.downRight && t.model.downRight();
                break;
            default:
                t.direction = t.DIRECTION_RIGHT,
                null !== t.model && t.model.right && t.model.right()
            }
            t.tmpDirection = null,
            t.tmpCallback = null
        } else t.tmpDirection = t.DIRECTION_RIGHT,
        t.tmpCallback = null !== t.model && t.model.right ? t.model.right: null
    }),
    o.onUp.add(this.keyUp, this)
},
Swipe.prototype.keyUp = function() {
    this.direction = this.tmpDirection,
    this.tmpDirection = null,
    null !== this.tmpCallback && (this.tmpCallback.call(this.model), this.tmpCallback = null)
},
Swipe.prototype.check = function() {
    if (null !== this.direction) {
        var t = {
            x: 0,
            y: 0,
            direction: this.direction
        };
        return this.direction = null,
        t
    }
    if (!this.swiping) return null;
    if (Phaser.Point.distance(this.game.input.activePointer.position, this.game.input.activePointer.positionDown) < this.dragLength) return null;
    this.swiping = !1;
    var i = null,
    e = this.game.input.activePointer.position.x - this.game.input.activePointer.positionDown.x,
    l = this.game.input.activePointer.position.y - this.game.input.activePointer.positionDown.y,
    o = (t = {
        x: this.game.input.activePointer.positionDown.x,
        y: this.game.input.activePointer.positionDown.y
    },
    Math.abs(e)),
    n = Math.abs(l);
    return ! this.diagonalDisabled && o > this.dragLength - this.diagonalDelta && n > this.dragLength - this.diagonalDelta ? e > 0 && l > 0 ? (i = this.DIRECTION_DOWN_RIGHT, null !== this.model && this.model.downRight && this.model.downRight(t)) : e > 0 && l < 0 ? (i = this.DIRECTION_UP_RIGHT, null !== this.model && this.model.upRight && this.model.upRight(t)) : e < 0 && l > 0 ? (i = this.DIRECTION_DOWN_LEFT, null !== this.model && this.model.downLeft && this.model.downLeft(t)) : e < 0 && l < 0 && (i = this.DIRECTION_UP_LEFT, null !== this.model && this.model.upLeft && this.model.upLeft(t)) : (o > this.dragLength || n > this.dragLength) && (o > n ? e > 0 ? (i = this.DIRECTION_RIGHT, null !== this.model && this.model.right && this.model.right(t)) : e < 0 && (i = this.DIRECTION_LEFT, null !== this.model && this.model.left && this.model.left(t)) : l > 0 ? (i = this.DIRECTION_DOWN, null !== this.model && this.model.down && this.model.down(t)) : l < 0 && (i = this.DIRECTION_UP, null !== this.model && this.model.up && this.model.up(t))),
    null !== i ? (t.direction = i, t) : null
},
"undefined" != typeof exports && "undefined" != typeof module && module.exports && (module.exports = Swipe);
var shopAdvConfigs = {
    probability: 75,
    coolDownTime: 60
},
resultAdvConfigs = {
    probability: 100,
    coolDownTime: 0
};
var game, __extends = this && this.__extends ||
function() {
    var t = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array &&
    function(t, e) {
        t.__proto__ = e
    } ||
    function(t, e) {
        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
    };
    return function(e, i) {
        function o() {
            this.constructor = e
        }
        t(e, i),
        e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o)
    }
} (); !
function(t) {
    var e = function() {
        function t() {}
        return t.Boot = "Boot",
        t.Preloader = "Preloader",
        t.MainMenu = "MainMenu",
        t.Game = "Game",
        t.ChooseHero = "ChooseHero",
        t.ChooseGameFormat = "ChooseGameFormat",
        t.Shop = "Shop",
        t.Credits = "Credits",
        t.Result = "Result",
        t
    } ();
    t.WindowsConsts = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.Items1 = "Items1",
        t.Items2 = "Items2",
        t.Barrel = "Barrel",
        t.Background = "background",
        t.BackgroundMenu = "backgroundMenu",
        t.BackgroundPause = "backgroundPause",
        t.FamobiLogo = "famobiLogo",
        t.PauseLogo = "PauseLogo",
        t.Skull = "skull",
        t.SkullLight = "skull_light",
        t.MenuStar = "menuStar",
        t.MenuLogo = "menuLogo",
        t.Loading = "loading",
        t.ChoiceBackground = "choiceBackground",
        t.Lock = "lock",
        t.CoinPanel = "coinPanel",
        t.ThreeXThree = "ThreeXThree",
        t.FourXFour = "FourXFour",
        t.CardBackground = "cardBackrounds",
        t.NoAccess = "noAccess",
        t.Boss = "boss",
        t.Enemy = "enemy",
        t.Shield = "shields",
        t.CardLifeCircle = "cardLifeCircle",
        t.CardPowerUpCircle = "cardPowerUpCircle",
        t.SmallRing = "smallRing",
        t.BigRing = "bigRing",
        t.Hero = "hero",
        t.HeroBomb = "heroBomb",
        t.HeroKey = "heroKey",
        t.HeroGun = "heroGun",
        t.Health = "health",
        t.Coin = "coin",
        t.CoinBag = "coinBag",
        t.Cannon = "cannon",
        t.BombFlame = "bomb_flame",
        t.GameStatusPanel = "menuPanel",
        t.SmallBtnBackground = "smallBtnBackground",
        t.BigBtnBackground = "bigBtnBackground",
        t.SoundBtn = "soundBtn",
        t.PauseBtn = "pauseBtn",
        t.HomeBtn = "homeBtn",
        t.HomeSmallBtn = "homeBtnSmall",
        t.GroupBtn = "groupBtn",
        t.NextBtn = "nextBtn",
        t.PrevBtn = "prevBtn",
        t.PlayBtn = "playBtn",
        t.PlusBtn = "plusBtn",
        t.ResumeBtn = "resumeBtn",
        t.SettingsBtn = "settingsBtn",
        t.ControlBtn = "controlBtn",
        t.AdvPlayBtn = "advPlayBtn",
        t.IBtn = "iBtn",
        t.Shadow = "shadow",
        t.ShopItemBackground = "shopItemBackground",
        t.BigHeart = "heartBig",
        t.BigHorseshoe = "horseshoeBig",
        t.BigLuck = "luckBig",
        t.Key2 = "key2",
        t.Key3 = "key3",
        t.Key4 = "key4",
        t.SmallHeart = "heartSmall",
        t.SmallHorseshoe = "horseshoeSmall",
        t.SmallLuck = "luckSmall",
        t.SmallKey = "key_small",
        t.Medal = "medal",
        t.Trap = "trap",
        t.Chest = "chest",
        t.LockBody = "lockBody",
        t.LockBridge = "lockBridge",
        t.LockSwitch = "lockSwitch",
        t.LockArrow = "lockArrow",
        t.LockRod = "lockRod",
        t.LockDoubleRod = "lockDoubleRod",
        t.LockBomb = "lockBomb",
        t.LockBombLamp = "lockBombLamp",
        t.LockFixedRod = "lockFixedRod",
        t.LockDoubleFixedRod = "lockDoubleFixedRod",
        t.MouseClick = "mouse_click",
        t.Core = "core",
        t.Smoke1 = "smoke_1",
        t.Smoke2 = "smoke_2",
        t.Smoke3 = "smoke_3",
        t.Smoke4 = "smoke_4",
        t.Smoke5 = "smoke_5",
        t.Bomb = "bomb",
        t.Poison = "poison",
        t.Boom = "boom",
        t.Lightning = "lightning",
        t.BigLightning = "lightning_1",
        t.SmallLightning = "lightning_2",
        t.Multiplier2 = "multiplier2",
        t.Multiplier3 = "multiplier3",
        t.Dust = "dust",
        t.BarrelIronDot = "barrelIronDot",
        t.BarrelIron = "barrelIron",
        t.BarrelCircleDark = "barrelCircleDark",
        t.BarrelCircleLight = "barrelCircleLight",
        t.BarrelBoardRight1 = "barrelBoardRight1",
        t.BarrelBoardRight2 = "barrelBoardRight2",
        t.BarrelBoard1 = "barrelBoard1",
        t.BarrelBoard2 = "barrelBoard2",
        t.BarrelBoard3 = "barrelBoard3",
        t.BarrelBoard4 = "barrelBoard4",
        t.BarrelBoard5 = "barrelBoard5",
        t.BarrelBoard6 = "barrelBoard6",
        t.BarrelBoard7 = "barrelBoard7",
        t.BarrelBoard8 = "barrelBoard8",
        t.BarrelBoard9 = "barrelBoard9",
        t.BarrelBoard10 = "barrelBoard10",
        t.BarrelBoardStraight1 = "barrelBoardStraight1",
        t.BarrelBoardStraight2 = "barrelBoardStraight2",
        t.Enemy9Vane = "enemy_9_vane",
        t.Enemy9Pipe = "enemy_9_pipe",
        t.TurnsToBoss = "turnsToBoss",
        t.CheckMark = "check",
        t.Arm = "arm",
        t.MoreGames = "more_games",
        t.BigPlayBtn = "bigPlayBtn",
        t.AdvPanel = "advPanel",
        t.Smile = "smile",
        t.NoIcon = "noIcon",
        t
    } ();
    t.ArtConsts = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.Click = "click",
        t.Barrel1 = "barrel1",
        t.Barrel2 = "barrel2",
        t.Bomb = "bomb",
        t.BossAppearance = "bossAppearance",
        t.Buy = "buy",
        t.Cannon = "cannon",
        t.Card = "card",
        t.ChestOpening = "chestOpening",
        t.Coin = "coin",
        t.CoinsBag = "coinsBag",
        t.CoinsCounting = "coinsCounting",
        t.Health1 = "health1",
        t.Health2 = "health2",
        t.HeroDies = "heroDies",
        t.Hit1 = "hit1",
        t.Hit2 = "hit2",
        t.Horseshoe = "horseshoe",
        t.Idol = "idol",
        t.IncorrectClick = "incorrectClick",
        t.Lighting = "lighting",
        t.Melody = "melody",
        t.PickLockFail = "picklockFail",
        t.PickLockNeutral = "picklockNeutral",
        t.PickLockSuccess = "picklockSuccess",
        t.Poison = "poison",
        t.Revive = "revive",
        t.ShieldMetal = "shieldMetal",
        t.ShieldWood = "shieldWood",
        t.Skull = "skull",
        t.Move01 = "move01",
        t.Move02 = "move02",
        t.Trap = "trap",
        t
    } ();
    t.SoundConsts = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.Width = 640,
        t.Height = 960,
        t.HeroStartRow = 2,
        t.HeroStartColumn = 2,
        t.CardWidth = 198,
        t.CardHeight = 226,
        t.CardSpaceBetweenWidth = 10,
        t.CardSpaceBetweenHeight = 10,
        t.AnimationTime = 185,
        t.AnimationMultiplier = .5,
        t.ScaleZoom = 1.2,
        t.ScaleSpeed = 50,
        t.FlipSpeed = 200,
        t.FlipZoom = 1.3,
        t.SmashDelay = 200,
        t.HeroCurrentLife1 = "HeroCurrentLife1",
        t.HeroCurrentLife2 = "HeroCurrentLife2",
        t.HeroTotalLife1 = "HeroTotalLife1",
        t.HeroTotalLife2 = "HeroTotalLife2",
        t.CardLife = "CardLife",
        t.CardLife1 = "CardLife1",
        t.CardLife2 = "CardLife2",
        t.PowerUpCircle = "PowerUpCircle",
        t.PowerUp = "PowerUp",
        t.CardManAnimation = "CardManAnimation",
        t.WaveSize = 7,
        t.ScaleSize = 30,
        t.textFontWeight = 22,
        t.numbersFontWeight = 28,
        t.resultNumbersFontWeight = 35,
        t.creditsColor = "#ffffff",
        t.creditsFontWeight = 24,
        t.BackgroundImageName = "BackgroundImageName",
        t.BackgroundName = "BackgroundName",
        t.LightningDuration = 50,
        t.ShakeIntensity = .02,
        t.ContainerName = "container",
        t.CoinMaxValue = 5,
        t.Shadow = "shadow",
        t.Hero = "hero",
        t.CardWithArm = "cardWithArm",
        t.CardWithMovingArm = "cardWithMovingArm",
        t.ShowTime = 300,
        t.EasingTo = Phaser.Easing.Quadratic.In,
        t.EasingFrom = Phaser.Easing.Quadratic.Out,
        t.StorageName = "pirated-cards-adventure",
        t.IsDev = !1,
        t.IsAndroid = !1,
        t.HighResolutionScale = !1,
        t.MaxPixelRatio = 3,
        t.WarriorAnimationDuration = 500,
        t
    } ();
    t.Consts = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.HeroBomb = 600,
        t.HeroKey = 900,
        t.HeroGun = 1350,
        t.FourXFour = 750,
        t.Heart = 250,
        t.Horseshoe = 125,
        t.Luck = 125,
        t.Key = 125,
        t
    } ();
    t.PriceConsts = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(t) {
        function e(e, i, o, n, s) {
            var a = t.call(this, e, i, o, n, s) || this;
            return a.playAnimation(),
            a
        }
        return __extends(e, t),
        e.prototype.playAnimation = function() {
            this.canPlayAnimation = !0
        },
        e.prototype.stopAnimation = function() {
            this.canPlayAnimation = !1
        },
        e
    } (Phaser.Sprite);
    t.SpriteAnimationBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return __extends(e, t),
        e
    } (Phaser.Sprite);
    t.SpriteBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s, a, r, h) {
            void 0 === r && (r = !1),
            void 0 === h && (h = t.RandomHelper.getRandomIntInclusive(0, 200));
            var d = e.call(this, i, o, n, s, a) || this;
            return d.waveHeight = t.Consts.WaveSize / 2,
            d.isUp = r,
            setTimeout(d.startAnimation.bind(d), h),
            d
        }
        return __extends(i, e),
        i.prototype.startAnimation = function() {
            this.isStarted = !0
        },
        i.prototype.update = function() {
            this.isStarted && this.canPlayAnimation && (this.waveHeight += .3, this.isUp ? this.y += .3 : this.y -= .3, this.waveHeight >= t.Consts.WaveSize && (this.isUp = !this.isUp, this.waveHeight = 0))
        },
        i
    } (t.SpriteAnimationBase);
    t.SpriteShakeBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(0),
            h = t.BtnHelper.getBtnBackgroundArtName(s);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, h + r) || this).artName = h,
            a.inputEnabled = !0,
            a.input.pixelPerfectOver = !0,
            a.input.pixelPerfectClick = !0,
            a.events.onInputOver.add(a.onInputOver, a),
            a.events.onInputOut.add(a.onInputOut, a),
            a.events.onInputDown.add(a.clickHandler, a),
            a
        }
        return __extends(i, e),
        i.prototype.clickHandler = function() {
            this.frameName = this.artName + t.FrameHelper.getFrame(1),
            setTimeout(this.onInputOut.bind(this), 100)
        },
        i.prototype.onInputOver = function() {
            this.frameName = this.artName + t.FrameHelper.getFrame(1)
        },
        i.prototype.onInputOut = function() {
            this.frameName = this.artName + t.FrameHelper.getFrame(0)
        },
        i
    } (Phaser.Sprite);
    t.SpriteBtnBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            var i = null !== e && e.apply(this, arguments) || this;
            return i.centerX = t.Consts.Width / 2,
            i.centerY = t.Consts.Height / 2,
            i.gameWidth = t.Consts.Width,
            i.gameHeight = t.Consts.Height,
            i
        }
        return __extends(i, e),
        i.prototype.create = function() {
            this.game.scale.onSizeChange.add(this.scaleGameContainer, this),
            this.background = new Phaser.Group(this.game),
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.BackgroundMenu),
            this.gameContainer = new Phaser.Group(this.game, this.world),
            t.ScaleHelper.scaleContainer(this.gameContainer, this.gameWidth, this.gameHeight)
        },
        i.prototype.scaleGameContainer = function() {
            t.ScaleHelper.scaleContainer(this.gameContainer, this.gameWidth, this.gameHeight),
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.BackgroundMenu)
        },
        i.prototype.addMenuTopPanel = function(e, i) {
            void 0 === e && (e = null),
            void 0 === i && (i = !0),
            this.coinPanel = new t.CoinPanel(this.game, 0, 0),
            this.coinPanel.x = this.centerX,
            this.coinPanel.y = this.coinPanel.height + 15,
            this.gameContainer.add(this.coinPanel),
            i && (this.settingBtn = new t.Btn(this.game, 0, 0, t.BtnType.HomeSmall, this.onSettingBtnClick.bind(this), !0), this.settingBtn.x = this.gameWidth - this.settingBtn.width, this.settingBtn.y = this.coinPanel.height + 15, this.gameContainer.add(this.settingBtn)),
            e && (this.prevBtn = new t.Btn(this.game, 0, this.coinPanel.height + 15, t.BtnType.PrevSmall, e, !0), this.prevBtn.x = this.prevBtn.width, this.gameContainer.add(this.prevBtn))
        },
        i.prototype.showTopPanel = function() {
            this.settingBtn && this.moveFromTop(this.settingBtn),
            this.moveFromTop(this.coinPanel, .25 * t.Consts.ShowTime),
            this.prevBtn && this.moveFromTop(this.prevBtn, .5 * t.Consts.ShowTime)
        },
        i.prototype.hideTopPanel = function() {
            this.settingBtn && this.moveToTop(this.settingBtn, .5 * t.Consts.ShowTime),
            this.moveToTop(this.coinPanel, .25 * t.Consts.ShowTime),
            this.prevBtn && this.moveToTop(this.prevBtn)
        },
        i.prototype.onSettingBtnClick = function() {},
        i.prototype.updateAllChildren = function(t) {
            for (var e = 0; e < t.children.length; e++) {
                var i = t.children[e];
                i && i.update()
            }
        },
        i.prototype.fadeIn = function(t) {
            t.alpha = 0,
            this.game.add.tween(t).to({
                alpha: 1
            },
            300).start()
        },
        i.prototype.fadeOut = function(t, e) {
            t.alpha = 1;
            var i = this.game.add.tween(t).to({
                alpha: 0
            },
            200).start();
            e && i.onComplete.add(e)
        },
        i.prototype.fadeInState = function() {
            this.fadeIn(this.gameContainer)
        },
        i.prototype.fadeOutState = function(t) {
            this.fadeOut(this.gameContainer, this.changeState.bind(this, t))
        },
        i.prototype.changeState = function(t) {
            this.game.state.start(t, !0, !1)
        },
        i.prototype.moveFromTop = function(e, i) {
            void 0 === i && (i = 0);
            var o = e.y;
            e.y = -1e3,
            e.alpha = 0,
            this.game.add.tween(e).to({
                y: o,
                alpha: 1
            },
            t.Consts.ShowTime, t.Consts.EasingFrom, !0, i)
        },
        i.prototype.moveToTop = function(e, i) {
            void 0 === i && (i = 0),
            this.game.add.tween(e).to({
                y: -1e3,
                alpha: 0
            },
            t.Consts.ShowTime, t.Consts.EasingTo, !0, i)
        },
        i.prototype.moveFromBottom = function(e, i) {
            void 0 === i && (i = 0);
            var o = e.y;
            e.y = 1e3,
            e.alpha = 0,
            this.game.add.tween(e).to({
                y: o,
                alpha: 1
            },
            t.Consts.ShowTime, t.Consts.EasingFrom, !0, i)
        },
        i.prototype.moveToBottom = function(e, i) {
            void 0 === i && (i = 0),
            this.game.add.tween(e).to({
                y: 1e3,
                alpha: 0
            },
            t.Consts.ShowTime, t.Consts.EasingTo, !0, i)
        },
        i.prototype.moveFromLeft = function(e, i, o) {
            void 0 === i && (i = 0),
            void 0 === o && (o = !0);
            var n = e.x;
            return e.x = -1e3,
            e.alpha = 0,
            this.game.add.tween(e).to({
                x: n,
                alpha: 1
            },
            t.Consts.ShowTime, t.Consts.EasingFrom, o, i)
        },
        i.prototype.moveToLeft = function(e, i, o) {
            void 0 === i && (i = 0),
            void 0 === o && (o = !0);
            var n = e.x,
            s = this.game.add.tween(e).to({
                x: -1e3,
                alpha: 0
            },
            t.Consts.ShowTime, t.Consts.EasingTo, o, i);
            return s.onComplete.add(function() {
                e.x = n,
                e.alpha = 1,
                e.visible = !1
            }),
            s
        },
        i.prototype.moveFromRight = function(e, i) {
            void 0 === i && (i = 0);
            var o = e.x;
            e.x = 1e3,
            e.alpha = 0,
            this.game.add.tween(e).to({
                x: o,
                alpha: 1
            },
            t.Consts.ShowTime, t.Consts.EasingFrom, !0, i)
        },
        i.prototype.moveToRight = function(e, i) {
            void 0 === i && (i = 0),
            this.game.add.tween(e).to({
                x: 1e3,
                alpha: 0
            },
            t.Consts.ShowTime, t.Consts.EasingTo, !0, i)
        },
        i
    } (Phaser.State);
    t.StateBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e) {
            this.shape = t,
            this.game = e
        }
        return e.prototype.startTurnAnimation = function(e, i) {
            void 0 === i && (i = this.removeShapeFromStage);
            var o = t.TweenHelper.turnAnimationStart(this.game, this.shape);
            return o.onStart.add(this.playCardSoundInSeconds, this),
            o.onComplete.add(i, this),
            o.onComplete.add(e),
            o
        },
        e.prototype.playCardSoundInSeconds = function() {
            setTimeout(this.playCardSound.bind(this), 50)
        },
        e.prototype.playCardSound = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Card)
        },
        e.prototype.endTurnAnimationStart = function() {
            this.shape.scale.set(0, t.Consts.FlipZoom)
        },
        e.prototype.endTurnAnimationEnd = function() {
            this.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss && t.SoundController.instance.playSound(t.SoundConsts.BossAppearance),
            this.shape.scale.x = .1,
            t.TweenHelper.turnAnimationEnd(this.game, this.shape).start()
        },
        e.prototype.removeChild = function() {
            var t = [],
            e = this.game.add.tween(this.shape.scale).to({
                x: 1.1,
                y: 1.1
            },
            50).to({
                x: 1,
                y: 1
            },
            50).to({
                x: 1.1,
                y: 1.1
            },
            50).to({
                x: 0,
                y: 0
            },
            80, null, null, 100);
            return e.onComplete.add(this.removeShapeFromStage.bind(this)),
            t.push(e),
            t
        },
        e.prototype.removeShapeFromStage = function() {
            this.shape.destroy()
        },
        e
    } ();
    t.CardSpriteBase = e;
    var i = function(e) {
        function i(t, i) {
            var o = e.call(this, t, i) || this;
            return o.canLightningStrike = !1,
            o
        }
        return __extends(i, e),
        i.prototype.playNoAccess = function() {
            t.SoundController.instance.playSound(t.SoundConsts.IncorrectClick);
            var e = new t.NoAccess(this.shape.game, 0, -.5);
            this.shape.addChild(e),
            e.play(t.AnimationConsts.Action, 60, !1, !0)
        },
        i.prototype.setCoordinate = function(t) {
            this.shape.x = t.x,
            this.shape.y = t.y
        },
        i.prototype.moveTo = function(t, e) {
            return this.game.add.tween(this.shape).to({
                x: t.x,
                y: t.y
            },
            e)
        },
        i.prototype.getCenterX = function() {
            return this.shape.x
        },
        i.prototype.getCenterY = function() {
            return this.shape.y
        },
        i.prototype.runLightning = function() {
            this.bigLightningSprite || (this.bigLightningSprite = new t.BigLightning(this.game, 0, 0), this.bigLightningSprite.alpha = 0, this.shape.add(this.bigLightningSprite)),
            this.bigLightningSprite.y = 20;
            var e = [],
            i = this.game.add.tween(this.bigLightningSprite).to({
                alpha: 1
            },
            50).to({
                y: -20
            },
            200).to({
                alpha: 0
            },
            50);
            return i.onStart.add(this.onBigLightingStart, this),
            e.push(i),
            e
        },
        i.prototype.onBigLightingStart = function() {
            this.smallLightningSprite || (this.smallLightningSprite = new t.SmallLightning(this.game, 0, 0), this.smallLightningSprite.alpha = 0, this.shape.add(this.smallLightningSprite));
            var e = t.Consts.CardWidth / 2 - 20,
            i = t.Consts.CardHeight / 2 - 20;
            t.RandomHelper.getRandomBool() && (e = -e),
            t.RandomHelper.getRandomBool() && (i = -i),
            this.smallLightningSprite.x = e,
            this.smallLightningSprite.y = i,
            this.game.add.tween(this.smallLightningSprite).to({
                alpha: 1
            },
            1).to({
                alpha: 0
            },
            1, null, !0, 100)
        },
        i.prototype.getScaleTween = function(t, e) {
            for (var i = [], o = 2; o < arguments.length; o++) i[o - 2] = arguments[o];
            var n, s = this.game.add.tween(t.scale).to({
                x: 2.5,
                y: 2.5
            },
            200),
            a = this.game.add.tween(t.scale).to({
                x: 1,
                y: 1
            },
            200);
            return (n = s.onComplete).add.apply(n, [e, this, null].concat(i)),
            s.chain(a),
            s
        },
        i.prototype.getCardLifeText = function() {
            return this.shape.getByName(t.Consts.CardLife)
        },
        i
    } (e);
    t.CardBase = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {
            this.isInterstitialReady = !1,
            this.isRewardedVideoReady = !1,
            this.wasLastRewardedVideoSuccessfull = !1,
            this.admobid = {
                banner: "",
                interstitial: "/37336410/InAppInterstitial//A-APPSTORE-PLAY",
                rewardvideo: "/6062/sanghan_rweb_ad_unit"
            },
            this.onAdDismissSignal = new Phaser.Signal
        }
        return Object.defineProperty(e, "instance", {
            get: function() {
                return e._instance ? e._instance: e._instance = new e
            },
            enumerable: !0,
            configurable: !0
        }),
        e.prototype.createDeviceReadyHandler = function() {
            t.Consts.IsAndroid && (/(ipad|iphone|ipod|android|windows phone)/i.test(navigator.userAgent) ? document.addEventListener("deviceready", this.onDeviceReady.bind(this), !1) : this.onDeviceReady())
        },
        e.prototype.onDeviceReady = function() {
            t.Consts.IsAndroid && (AdMob ? (AdMob.setOptions({
                customTargeting: {
                    game: "pirate-cards.android",
                    uuid: "a39fb0b2-caf7-4c43-b500-e00f98ec5969",
                    video: 1
                }
            }), document.addEventListener("onAdFailLoad", this.onAdFailLoad.bind(this)), document.addEventListener("onAdLoaded", this.onAdLoaded.bind(this)), document.addEventListener("onAdPresent", this.onAdPresent.bind(this)), document.addEventListener("onAdLeaveApp", this.onAdLeaveApp.bind(this)), document.addEventListener("onAdDismiss", this.onAdDismiss.bind(this))) : console.log("admob plugin not ready"))
        },
        e.prototype.onAdFailLoad = function(t) {
            var e = this;
            console.log("onAdFailload " + t.error + " - " + t.adType + " - " + t.reason, t),
            "interstitial" == t.adType ? this.isInterstitialReady = !1 : "rewardvideo" == t.adType && (this.isRewardedVideoReady = !1, this.wasLastRewardedVideoSuccessfull = !1),
            setTimeout(function() {
                "rewardvideo" != t.adType || e.isRewardedVideoReady || e.prepareRewardedAdv(!1),
                "interstitial" != t.adType || e.isInterstitialReady || e.prepareAdv(!1)
            },
            2e4)
        },
        e.prototype.onAdLoaded = function(t) {
            console.log("onAdLoaded: " + t.adType, t),
            "interstitial" == t.adType ? this.isInterstitialReady = !0 : "rewardvideo" == t.adType && (this.isRewardedVideoReady = !0, this.wasLastRewardedVideoSuccessfull = !1)
        },
        e.prototype.onAdPresent = function(t) {
            console.log("onAdPresent: ", t),
            "interstitial" == t.adType ? this.isInterstitialReady = !1 : "rewardvideo" == t.adType && (this.isRewardedVideoReady = !1, this.wasLastRewardedVideoSuccessfull = !0)
        },
        e.prototype.onAdLeaveApp = function(t) {
            console.log("onAdLeaveApp: ", t),
            "rewardvideo" == t.adType && console.log("leaving app, give reward to user: ", this.wasLastRewardedVideoSuccessfull)
        },
        e.prototype.onAdDismiss = function(t) {
            console.log("onAdDismiss", arguments),
            "rewardvideo" == t.adType && (this.isRewardedVideoReady = !1, this.prepareRewardedAdv(!1)),
            "interstitial" == t.adType && (this.isInterstitialReady = !1, this.prepareAdv(!1)),
            this.onAdDismissSignal.dispatch(t)
        },
        e.prototype.wasRecentRewardedVideoFinished = function() {
            return ! t.Consts.IsAndroid || this.wasLastRewardedVideoSuccessfull
        },
        e.prototype.isInterstitialAvailable = function() {
            return ! t.Consts.IsAndroid || this.isInterstitialReady
        },
        e.prototype.isRewardedVideoAvailable = function() {
            return t.Consts.IsAndroid ? this.isRewardedVideoReady: window.famobi.hasRewardedAd ? window.famobi.hasRewardedAd() : void 0
        },
        e.prototype.prepareAdv = function(e) {
            var i = this;
            void 0 === e && (e = !1),
            0 != t.Consts.IsAndroid && (AdMob ? AdMob.prepareInterstitial({
                adId: this.admobid.interstitial,
                autoShow: e
            },
            function() {
                i.isInterstitialReady = !0
            },
            function() {
                i.isInterstitialReady = !1
            }) : console.log("Ad plugin is not loaded"))
        },
        e.prototype.prepareRewardedAdv = function(e) {
            var i = this;
            void 0 === e && (e = !1),
            0 != t.Consts.IsAndroid && (AdMob ? AdMob.prepareRewardVideoAd({
                adId: this.admobid.rewardvideo,
                autoShow: e
            },
            function() {
                i.isRewardedVideoReady = !0
            },
            function() {
                i.isRewardedVideoReady = !1
            }) : console.log("Ad plugin is not loaded"))
        },
        e.prototype.showAd = function(e) {
            var i = this;
            t.Consts.IsAndroid ? AdMob.isInterstitialReady(function(t) {
                t && i.isInterstitialReady ? AdMob.showInterstitial(function() {
                    e && e()
                },
                function() {
                    e && e()
                }) : e && e()
            }) : window.famobi.showAd(e)
        },
        e.prototype.showRewardedAd = function(e) {
            t.Consts.IsAndroid ? AdMob ? AdMob.showRewardVideoAd(function() {},
            function() {}) : console.log("Ad plugin is not loaded") : window.famobi.rewardedAd(e)
        },
        e._instance = null,
        e
    } ();
    t.AdManager = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            var o = e.call(this, i.gameConfig) || this;
            return i.instance = o,
            o.state.add(t.WindowsConsts.Boot, t.Boot, !1),
            o.state.add(t.WindowsConsts.Preloader, t.Preloader, !1),
            o.state.add(t.WindowsConsts.MainMenu, t.MainMenu, !1),
            o.state.add(t.WindowsConsts.Game, t.Game, !1),
            o.state.add(t.WindowsConsts.ChooseHero, t.ChooseHero, !1),
            o.state.add(t.WindowsConsts.ChooseGameFormat, t.ChooseGameFormat, !1),
            o.state.add(t.WindowsConsts.Shop, t.Shop, !1),
            o.state.add(t.WindowsConsts.Credits, t.Credits, !1),
            o.state.add(t.WindowsConsts.Result, t.Result, !1),
            o.state.start(t.WindowsConsts.Boot),
            t.AdManager.instance.prepareAdv(!1),
            t.AdManager.instance.prepareRewardedAdv(!1),
            o
        }
        return __extends(i, e),
        i.prototype.pauseGame = function() {
            t.SoundController.instance.pauseAudio(),
            this.paused = !0
        },
        i.prototype.unpauseGame = function(e) {
            void 0 === e && (e = !1),
            !isPageVisible || adIsShowing && !e ? console.log("resuming game is not allowed now because ads are displaying or page isn't  visible...") : (this.paused = !1, t.SoundController.instance.resumeAudio(), console.log("resuming game..."))
        },
        i.gameConfig = {
            width: window.innerWidth,
            height: window.innerHeight,
            renderer: Phaser.CANVAS,
            transparent: !0,
            enableDebug: !1
        },
        i
    } (Phaser.Game);
    t.GameEngine = e
} (CardsMatch || (CardsMatch = {}));
var CardsMatch, isPageVisible = !0,
adIsShowing = !1;
if (CardsMatch.Consts.IsAndroid) window.onload = function() {
    game = new CardsMatch.GameEngine
},
CardsMatch.AdManager.instance.createDeviceReadyHandler(),
document.addEventListener("DOMContentLoaded",
function() {
    if ("-ms-user-select" in document.documentElement.style && navigator.userAgent.match(/IEMobile\/10\.0/)) {
        var t = document.createElement("style");
        t.appendChild(document.createTextNode("@-ms-viewport{width:auto!important}")),
        document.getElementsByTagName("head")[0].appendChild(t)
    }
}),
document.addEventListener("backbutton",
function() {
    window.confirm("Are you sure to quit?") && navigator.app.exitApp()
}),
document.addEventListener("pause",
function() {
    game.pauseGame()
}),
document.addEventListener("resume",
function() {
    game.unpauseGame()
});
else {
    var hidden, visibilityChange;
    function handleVisibilityChange() {
        document[hidden] ? (isPageVisible = !1, game && !adIsShowing && game.pauseGame()) : (isPageVisible = !0, game && !adIsShowing && game.unpauseGame())
    }
    window.famobi_onPauseRequested = function() {
        adIsShowing = !0,
        game && game.pauseGame()
    },
    window.famobi_onResumeRequested = function() {
        adIsShowing = !1,
        game && game.unpauseGame()
    },
    void 0 !== document.hidden ? (hidden = "hidden", visibilityChange = "visibilitychange") : void 0 !== document.msHidden ? (hidden = "msHidden", visibilityChange = "msvisibilitychange") : void 0 !== document.webkitHidden && (hidden = "webkitHidden", visibilityChange = "webkitvisibilitychange"),
    void 0 === document.addEventListener || void 0 === document[hidden] ? console.log("Browser doesn't support the Page Visibility API.") : document.addEventListener(visibilityChange, handleVisibilityChange, !1)
} !
function(t) {
    var e = function() {
        function t() {}
        return t.Action = "Action",
        t.State = "State",
        t.Open = "Open",
        t.Close = "Close",
        t
    } ();
    t.AnimationConsts = e
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Right = 1] = "Right",
        t[t.Down = 2] = "Down",
        t[t.Left = 3] = "Left",
        t[t.Up = 4] = "Up"
    } (t.MoveType || (t.MoveType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Sound = 1] = "Sound",
        t[t.Pause = 2] = "Pause",
        t[t.Home = 3] = "Home",
        t[t.HomeSmall = 4] = "HomeSmall",
        t[t.Group = 5] = "Group",
        t[t.Next = 6] = "Next",
        t[t.Prev = 7] = "Prev",
        t[t.PrevSmall = 8] = "PrevSmall",
        t[t.Play = 9] = "Play",
        t[t.Plus = 10] = "Plus",
        t[t.Resume = 11] = "Resume",
        t[t.Settings = 12] = "Settings",
        t[t.Control = 13] = "Control",
        t[t.Adv = 14] = "Adv",
        t[t.I = 15] = "I"
    } (t.BtnType || (t.BtnType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Default = 0] = "Default",
        t[t.Warrior = 1] = "Warrior",
        t[t.Hero = 2] = "Hero",
        t[t.PowerUp = 3] = "PowerUp"
    } (t.CardBackgroundType || (t.CardBackgroundType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Random = 1] = "Random",
        t[t.AfterChest = 2] = "AfterChest",
        t[t.AfterBarrel = 3] = "AfterBarrel",
        t[t.Positive = 4] = "Positive"
    } (t.CardGenerationType || (t.CardGenerationType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Start = 1] = "Start",
        t[t.Center = 2] = "Center",
        t[t.End = 3] = "End"
    } (t.CardPositionType || (t.CardPositionType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e, i = Phaser.ArrayUtils; !
    function(t) {
        t[t.Trap = 1] = "Trap",
        t[t.Warrior = 2] = "Warrior",
        t[t.Health = 3] = "Health",
        t[t.Gold = 4] = "Gold",
        t[t.Armor = 5] = "Armor",
        t[t.Cannon = 6] = "Cannon",
        t[t.Barrel = 7] = "Barrel",
        t[t.Chest = 8] = "Chest",
        t[t.Bomb = 9] = "Bomb",
        t[t.Poison = 10] = "Poison",
        t[t.Horseshoe = 11] = "Horseshoe",
        t[t.Lightning = 12] = "Lightning",
        t[t.Multiplier = 13] = "Multiplier",
        t[t.Skull = 14] = "Skull"
    } (e = t.CardScoreType || (t.CardScoreType = {}));
    var o = function() {
        function t() {}
        return t.isCardScoreTypeNegative = function(t) {
            return t == e.Trap || t == e.Warrior || t == e.Poison
        },
        t.isCardScoreTypePositive = function(t) {
            return t == e.Health || t == e.Armor || t == e.Cannon || t == e.Horseshoe || t == e.Lightning || t == e.Skull
        },
        t.getRandomFromChest = function() {
            return i.getRandomItem(t.itemsFromChest)
        },
        t.getRandomPowerUpFromBarrel = function() {
            return i.getRandomItem(t.itemsFromBarrel)
        },
        t.getRandomPowerUp = function() {
            return i.getRandomItem(t.powerUps)
        },
        t.itemsFromChest = [e.Bomb, e.Poison, e.Horseshoe, e.Lightning, e.Multiplier, e.Skull],
        t.itemsFromBarrel = [e.Health, e.Gold, e.Armor, e.Cannon],
        t.powerUps = [e.Health, e.Armor, e.Cannon, e.Barrel, e.Gold],
        t
    } ();
    t.CardScoreTypeHelper = o
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Base = 1] = "Base",
        t[t.Bomb = 2] = "Bomb",
        t[t.Key = 3] = "Key",
        t[t.Gun = 4] = "Gun"
    } (t.HeroType || (t.HeroType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Bomb = 1] = "Bomb",
        t[t.Fix = 2] = "Fix",
        t[t.Road = 3] = "Road"
    } (t.LockType || (t.LockType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Heart = 1] = "Heart",
        t[t.Horseshoe = 2] = "Horseshoe",
        t[t.Luck = 3] = "Luck",
        t[t.Key = 4] = "Key"
    } (t.ShopItemType || (t.ShopItemType = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) { !
    function(t) {
        t[t.Small = 1] = "Small",
        t[t.Big = 2] = "Big"
    } (t.SpriteSize || (t.SpriteSize = {}))
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Arm + t.FrameHelper.getFrame(0)) || this;
            return s.angle = -30,
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.Arm, 0, 1, "", 4), 2, !0, !1),
            s.animations.play(t.AnimationConsts.Action),
            s
        }
        return __extends(i, e),
        i.prototype.changeFrame = function(e) {
            this.frameName = t.ArtConsts.Arm + t.FrameHelper.getFrame(e)
        },
        i
    } (t.SpriteBase);
    t.Arm = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function o(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            return s.sprites = [],
            s.animationTime = 500,
            s.anchor.set(.5, .5),
            s.sprite = new Phaser.Sprite(i, 0, 28, t.ArtConsts.Items1, t.ArtConsts.Barrel + t.FrameHelper.getFrame(0)),
            s.sprite.anchor.set(.5, .5),
            s.addChild(s.sprite),
            s
        }
        return __extends(o, e),
        o.prototype.open = function() {
            var t = [],
            e = this.game.add.tween(this).to({},
            this.animationTime);
            return e.onStart.add(this.playOpen, this),
            t.push(e),
            t
        },
        o.prototype.generateBarrel = function() {
            this.generateBackItems(),
            this.generateCircles(),
            this.generateCenterItems(),
            this.generateRightItems(),
            this.generateLeftItems(),
            this.generateIronItems()
        },
        o.prototype.generateIronItems = function() {
            this.generateSprite(t.ArtConsts.BarrelIronDot, -5, 20),
            this.generateSprite(t.ArtConsts.BarrelIronDot, -5, 58)
        },
        o.prototype.generateCenterItems = function() {
            this.generateSprite(t.ArtConsts.BarrelBoardStraight1, -15, 45)
        },
        o.prototype.generateLeftItems = function() {
            this.generateSprite(t.ArtConsts.BarrelBoard9, -35, 70, -.3),
            this.generateSprite(t.ArtConsts.BarrelBoard8, -40, 35),
            this.generateSprite(t.ArtConsts.BarrelBoard7, -38, 7),
            this.generateSprite(t.ArtConsts.BarrelBoard3, -28, 60, -.2),
            this.generateSprite(t.ArtConsts.BarrelBoard5, -28, 26)
        },
        o.prototype.generateRightItems = function() {
            this.generateSprite(t.ArtConsts.BarrelBoard6, 20, 12, -.2),
            this.generateSprite(t.ArtConsts.BarrelBoardRight2, 15, 35),
            this.generateSprite(t.ArtConsts.BarrelBoard4, 0, 69)
        },
        o.prototype.generateCircles = function() {
            this.generateSprite(t.ArtConsts.BarrelCircleLight, -5, 0),
            this.generateSprite(t.ArtConsts.BarrelCircleDark, -5, 60)
        },
        o.prototype.generateBackItems = function() {
            this.generateSprite(t.ArtConsts.BarrelBoardRight1, 15, 26),
            this.generateSprite(t.ArtConsts.BarrelBoardStraight2, -10, 26),
            this.generateSprite(t.ArtConsts.BarrelBoard2, -28, 6),
            this.generateSprite(t.ArtConsts.BarrelBoard10, -38, 8, .3)
        },
        o.prototype.playOpen = function() {
            this.sprite.destroy(),
            this.generateBarrel(),
            this.runTween()
        },
        o.prototype.generateSprite = function(e, i, o, n) {
            void 0 === n && (n = 0);
            var s = new Phaser.Sprite(this.game, i, o, t.ArtConsts.Items1, e + t.FrameHelper.getFrame(0));
            s.anchor.set(.5, .5),
            s.rotation = n,
            this.addChild(s),
            this.sprites.push(s)
        },
        o.prototype.runTween = function() {
            this.sprites.forEach(this.runFlySprite.bind(this))
        },
        o.prototype.runFlySprite = function(t) {
            this.addDust();
            var e = new i(t);
            this.game.add.tween(e).to({
                angel: 180
            },
            this.animationTime, "Linear", !0).onComplete.add(function() {
                this.destroy()
            },
            t)
        },
        o.prototype.addDust = function() {
            for (var e = -60; e <= 90; e += 30) for (var i = -51; i <= 90; i += 30) if (( - 60 !== e && 90 !== e || -51 != i) && ( - 60 !== e && 90 !== e || 90 != i)) {
                var o = t.RandomHelper.getRandomIntInclusive(1, 3);
                if (2 !== o && 3 !== o) {
                    var n = new t.Dust(this.game, e, i);
                    n.x += t.RandomHelper.getRandomIntInclusive( - 15, 15),
                    n.y += t.RandomHelper.getRandomIntInclusive( - 15, 15),
                    this.addChild(n)
                }
            }
        },
        o
    } (t.SpriteShakeBase);
    t.Barrel = e;
    var i = function() {
        function e(e) {
            this.sprite = e,
            this.startX = this.sprite.x,
            this.startY = this.sprite.y,
            this.radius = t.RandomHelper.getRandomIntInclusive(10, 70),
            this.rotationStep = -.1,
            t.RandomHelper.getRandomBool() || (this.radius *= -1, this.rotationStep *= -1)
        }
        return Object.defineProperty(e.prototype, "angel", {
            get: function() {
                return 0
            },
            set: function(t) {
                var e, i;
                this.radius > 0 ? (t += 180, e = this.radius * Math.cos(Phaser.Math.degToRad(t)) + this.startX, i = this.radius * Math.sin(Phaser.Math.degToRad(t)) + this.startY) : (t -= 90, e = this.radius * Math.sin(Phaser.Math.degToRad(t)) + this.startX, i = this.radius * Math.cos(Phaser.Math.degToRad(t)) + this.startY),
                e += this.radius,
                this.sprite.position.set(e, i),
                this.sprite.rotation += this.rotationStep
            },
            enumerable: !0,
            configurable: !0
        }),
        e
    } ();
    t.GraphObject = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0),
            r = t.ArtConsts.BigLightning;
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, r + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(r, 0, 5, "", 4), 60, !0, !1),
            s.play(t.AnimationConsts.Action),
            s
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.BigLightning = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.BigPlayBtn + t.FrameHelper.getFrame(0)) || this;
            return a.onClick = s,
            a.anchor.set(.5),
            a.inputEnabled = !0,
            a.input.pixelPerfectOver = !0,
            a.input.pixelPerfectClick = !0,
            a.events.onInputOver.add(a.onInputOver, a),
            a.events.onInputOut.add(a.onInputOut, a),
            a.events.onInputDown.add(a.clickHandler, a),
            a
        }
        return __extends(i, e),
        i.prototype.clickHandler = function() {
            this.frameName = t.ArtConsts.BigPlayBtn + t.FrameHelper.getFrame(1),
            setTimeout(this.onInputOut.bind(this), 100);
            var e = this.width,
            i = this.height,
            o = this.game.add.tween(this).to({
                width: 1.1 * e,
                height: 1.1 * i
            },
            20),
            n = this.game.add.tween(this).to({
                width: e,
                height: i
            },
            20);
            o.chain(n),
            o.start(),
            setTimeout(this.onClickAction.bind(this), 100)
        },
        i.prototype.onClickAction = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Click, 1, !1),
            this.onClick && this.onClick(),
            this.inputEnabled = !1
        },
        i.prototype.onInputOver = function() {
            this.frameName = t.ArtConsts.BigPlayBtn + t.FrameHelper.getFrame(1)
        },
        i.prototype.onInputOut = function() {
            this.frameName = t.ArtConsts.BigPlayBtn + t.FrameHelper.getFrame(0)
        },
        i
    } (Phaser.Sprite);
    t.BigPlayBtn = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = e.call(this, i, o, n) || this;
            return a.container = new Phaser.Sprite(i, 0, 0),
            a.ring = t.ShapeFactoryHelper.getShape(i, 2, 2, t.ArtConsts.Items1, s),
            a.container.addChild(a.ring),
            a.addChild(a.container),
            a
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.canPlayAnimation && (this.container.angle += 2)
        },
        i
    } (t.SpriteAnimationBase);
    t.BigRing = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Bomb + a) || this).anchor.set(.5, .5),
            s.flame = t.ShapeFactoryHelper.getShape(s.game, s.width / 2, -s.height / 3 + 3, t.ArtConsts.Items1, t.ArtConsts.BombFlame, 0),
            s.addChild(s.flame),
            s.flame.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.BombFlame, 0, 2, "", 4), 60, !0, !1),
            s.playAnimation(),
            s
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            e.prototype.playAnimation.call(this),
            this.flame && this.flame.animations.play(t.AnimationConsts.Action)
        },
        i.prototype.stopAnimation = function() {
            e.prototype.stopAnimation.call(this),
            this.flame && this.flame.animations.stop(t.AnimationConsts.Action)
        },
        i
    } (t.SpriteShakeBase);
    t.Bomb = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Boom + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.Boom, 0, 17, "", 4), 60, !1, !1),
            s
        }
        return __extends(i, e),
        i.prototype.changeFrame = function(e) {
            this.frameName = t.ArtConsts.Boom + t.FrameHelper.getFrame(e)
        },
        i
    } (t.SpriteBase);
    t.Boom = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(0),
            h = t.ArtConsts.Boss + "_" + s.toString(),
            d = t.ArtConsts.Items2;
            return (a = e.call(this, i, o, n, d, h + r) || this).setPosition(s),
            a.anchor.set(.5, .9),
            a.animationTween = a.generateTween(),
            a.animationTween.loop(!0),
            a.animationTween.start(),
            a
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            this.animationTween && this.animationTween.isPaused && this.animationTween.resume()
        },
        i.prototype.stopAnimation = function() {
            this.animationTween.pause()
        },
        i.prototype.setPosition = function(t) {
            switch (this.y = 5, t) {
            case 1:
                this.x = -18,
                this.y = 82;
                break;
            case 2:
                this.x = -20,
                this.y = 82;
                break;
            case 3:
                this.x = -25,
                this.y = 80;
                break;
            default:
                throw new Error("Invalid value")
            }
        },
        i.prototype.generateTween = function() {
            return this.game.add.tween(this).to({
                height: .95 * this.height
            },
            500).to({
                height: this.height
            },
            500)
        },
        i
    } (t.SpriteAnimationBase);
    t.Boss = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s, a, r) {
            void 0 === r && (r = !1);
            var h = this,
            d = t.BtnHelper.getBtnSize(s); (h = e.call(this, i, o, n, d) || this).anchor.setTo(.5, .5);
            var c = s == t.BtnType.Sound && t.SoundController.instance.isMuted() ? 2 : 0,
            u = t.FrameHelper.getFrame(c);
            return h.iconArtName = t.BtnHelper.getBtnArtName(s),
            h.icon = new Phaser.Sprite(i, 0, 0, t.ArtConsts.Items1, h.iconArtName + u),
            h.icon.anchor.setTo(.5, .5),
            t.BtnHelper.alignIconCenter(h.icon, s),
            t.BtnHelper.scaleIcon(h.icon, s),
            h.addChild(h.icon),
            h.onClick = a,
            h.isOneClick = r,
            h.btnType = s,
            h.game.world.add(h),
            s == t.BtnType.Adv && i.add.tween(h.scale).to({
                x: 1.05,
                y: 1.05
            },
            300).to({
                x: .95,
                y: .95
            },
            600).to({
                x: 1,
                y: 1
            },
            300).loop(!0).start(),
            h
        }
        return __extends(i, e),
        i.prototype.clickHandler = function() {
            e.prototype.clickHandler.call(this);
            var t = this.width,
            i = this.height,
            o = this.game.add.tween(this).to({
                width: 1.1 * t,
                height: 1.1 * i
            },
            20),
            n = this.game.add.tween(this).to({
                width: t,
                height: i
            },
            20);
            o.chain(n),
            o.start(),
            setTimeout(this.onClickAction.bind(this), 100)
        },
        i.prototype.onClickAction = function() {
            if (t.SoundController.instance.playSound(t.SoundConsts.Click, 1, !1), this.btnType == t.BtnType.Sound) {
                t.SoundController.instance.setVolume(t.SoundController.instance.isMuted() ? 1 : 0);
                var e = t.FrameHelper.getFrame(t.SoundController.instance.isMuted() ? 2 : 0);
                this.icon.frameName = this.iconArtName + e,
                0 == t.Consts.IsAndroid && window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_VOLUMECHANGE, {
                    bgmVolume: t.SoundController.instance.isMuted() ? 0 : 1,
                    sfxVolume: t.SoundController.instance.isMuted() ? 0 : 1
                })
            }
            this.onClick && this.onClick(),
            this.isOneClick && this.disable()
        },
        i.prototype.disable = function() {
            this.inputEnabled = !1
        },
        i.prototype.update = function() {
            e.prototype.update.call(this)
        },
        i.prototype.onInputOver = function() {
            e.prototype.onInputOver.call(this);
            var i = this.btnType === t.BtnType.Sound && t.SoundController.instance.isMuted() ? 3 : 1;
            this.icon.frameName = this.iconArtName + t.FrameHelper.getFrame(i)
        },
        i.prototype.onInputOut = function() {
            e.prototype.onInputOut.call(this);
            var i = this.btnType === t.BtnType.Sound && t.SoundController.instance.isMuted() ? 2 : 0;
            this.icon.frameName = this.iconArtName + t.FrameHelper.getFrame(i)
        },
        i
    } (t.SpriteBtnBase);
    t.Btn = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Cannon + a) || this).anchor.set(.5, .5),
            s.flame = t.ShapeFactoryHelper.getShape(s.game, -s.width / 2 + 5, -s.height / 2 - 3, t.ArtConsts.Items1, t.ArtConsts.BombFlame, 0),
            s.addChild(s.flame),
            s.flame.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.BombFlame, 0, 2, "", 4), 30, !0, !1),
            s.playAnimation(),
            s
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            e.prototype.playAnimation.call(this),
            this.flame && this.flame.animations.play(t.AnimationConsts.Action)
        },
        i.prototype.stopAnimation = function() {
            e.prototype.stopAnimation.call(this),
            this.flame && this.flame.animations.stop(t.AnimationConsts.Action)
        },
        i
    } (t.SpriteShakeBase);
    t.Cannon = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            s.anchor.set(.5, .5);
            var a = t.FrameHelper.getFrame(0);
            s.smoke1 = s.createSmoke(t.ArtConsts.Smoke1 + a),
            s.smoke2 = s.createSmoke(t.ArtConsts.Smoke2 + a),
            s.smoke3 = s.createSmoke(t.ArtConsts.Smoke3 + a),
            s.smoke4 = s.createSmoke(t.ArtConsts.Smoke4 + a),
            s.smoke5 = s.createSmoke(t.ArtConsts.Smoke5 + a),
            s.anchor.set(.5, .5);
            var r = s.generateTween(s.smoke1, 1),
            h = s.generateTween(s.smoke2, 200 / 9),
            d = s.generateTween(s.smoke3, 50),
            c = s.generateTween(s.smoke4, 50),
            u = s.generateTween(s.smoke5, 50);
            return r.chain(h),
            h.chain(d),
            d.chain(c),
            c.chain(u),
            u.onComplete.add(function() {
                this.destroy()
            },
            s),
            r.start(),
            s
        }
        return __extends(i, e),
        i.prototype.createSmoke = function(e) {
            var i = new Phaser.Sprite(this.game, 0, 0, t.ArtConsts.Items1, e);
            return i.anchor.set(.5, .5),
            i.alpha = 0,
            this.addChild(i),
            i
        },
        i.prototype.generateTween = function(t, e) {
            var i = t.width,
            o = t.height;
            t.width = .6 * i,
            t.height = .6 * o;
            var n = this.game.add.tween(t).to({
                alpha: 1,
                width: i,
                height: o
            },
            e),
            s = this.game.add.tween(t).to({
                alpha: 0,
                width: 0,
                height: 0
            },
            e);
            return s.onComplete.add(function() {
                this.destroy()
            },
            t),
            n.onComplete.add(function() {
                s.start()
            },
            this),
            n
        },
        i
    } (Phaser.Sprite);
    t.CannonFlyingSmoke = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(s);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.CardBackground + r) || this).anchor.set(.5, .5),
            a
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.CardBackground = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = t.FrameHelper.getFrame(s);
            return e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.CardLifeCircle + a) || this
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.CardLifeCircle = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(s);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.CardPowerUpCircle + r) || this).anchor.set(.5, .5),
            a
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.CardPowerUpCircle = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Chest + a) || this).anchor.set(.5, .5),
            s
        }
        return __extends(i, e),
        i.prototype.open = function() {
            var t = [];
            t.push(this.game.add.tween(this).to({
                height: .7 * this.height,
                width: 1.1 * this.width
            },
            50));
            var e = this.game.add.tween(this).to({
                width: this.width,
                height: this.height
            },
            70);
            return e.onComplete.add(this.changeToOpen.bind(this)),
            t.push(e),
            t.push(this.game.add.tween(this).to({
                height: 1.3 * this.height,
                width: .9 * this.width
            },
            70)),
            t.push(this.game.add.tween(this).to({
                width: this.width,
                height: this.height
            },
            250)),
            t
        },
        i.prototype.changeToOpen = function() {
            this.frameName = t.ArtConsts.Chest + t.FrameHelper.getFrame(1)
        },
        i
    } (t.SpriteShakeBase);
    t.Chest = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e; !
    function(t) {
        t[t.NeutralSingle = 0] = "NeutralSingle",
        t[t.NeutralDouble = 1] = "NeutralDouble",
        t[t.Bomb = 2] = "Bomb",
        t[t.PositiveSingle = 3] = "PositiveSingle",
        t[t.PositiveDouble = 4] = "PositiveDouble"
    } (e = t.LockItemType || (t.LockItemType = {}));
    var i = function(i) {
        function o(e, o, n) {
            var s = i.call(this, e) || this;
            return s.lockArrowAngle = 20,
            s.lockArrowRotateStep = 3,
            s.radius = 95,
            s.arrowSpeed = 6,
            s.shortLength = 10,
            s.longLength = 40,
            s.clockwise = !0,
            s.items = [],
            s.isFly = !1,
            s.moveBack = !1,
            s.isLongWay = !1,
            s.isLatestMove = !1,
            s.isCompleted = !1,
            s.isFrontOfRoad = !1,
            s.tutorialStep = 0,
            s.isClickDisabled = !1,
            s.onChestOpened = o,
            s.onChestClosed = n,
            s.isTutorial = !t.GameStatus.isTutorialChestSeen,
            s
        }
        return __extends(o, i),
        o.prototype.initGroup = function() {
            this.lockBody = t.ShapeFactoryHelper.getShape(this.game, t.Consts.Width / 2, t.Consts.Height / 2, t.ArtConsts.Items1, t.ArtConsts.LockBody),
            this.lockBridge = new t.LockBridge(this.game, 0, -140),
            this.lockArrow = t.ShapeFactoryHelper.getShape(this.game, 0, 35, t.ArtConsts.Items1, t.ArtConsts.LockArrow),
            this.lockSwitch = t.ShapeFactoryHelper.getShape(this.game, 0, 40, t.ArtConsts.Items1, t.ArtConsts.LockSwitch),
            this.lockBody.anchor.set(.5, .5),
            this.lockBridge.anchor.set(.5, 1),
            this.lockBody.addChild(this.lockBridge),
            this.lockArrow.anchor.set(.5, .9),
            this.lockArrow.angle = 20,
            this.lockBody.addChild(this.lockArrow),
            this.lockSwitch.anchor.set(.5, .5),
            this.lockBody.addChild(this.lockSwitch),
            this.initElements(this.lockBody),
            this.add(this.lockBody)
        },
        o.prototype.initElements = function(t) {
            var e = [],
            i = this.generateArrayOfElements();
            this.sortArray(i);
            for (var o = 0,
            n = 0; n < i.length; n++) {
                var s = i[n],
                a = this.getItemWeight(s),
                r = a > 1 ? o + 1.5 : o + 1,
                h = this.addSpriteByType(r, s);
                e.push(h),
                o += a
            }
            e.forEach(function(e) {
                t.addChild(e)
            })
        },
        o.prototype.sortArray = function(t) {
            t = Phaser.ArrayUtils.shuffle(t);
            for (var i = 0,
            o = !1; i < 100 && !o;) {
                o = !0;
                for (var n = 0; n < t.length; n++) if (0 == n) {
                    if (! (t[n] != e.PositiveSingle && t[n] != e.PositiveDouble || t[n + 1] != e.PositiveSingle && t[n + 1] != e.PositiveDouble)) {
                        var s = t[n];
                        t[n] = t[t.length - 1],
                        t[t.length - 1] = s,
                        o = !1
                    }
                } else if (! (t[n] != e.PositiveSingle && t[n] != e.PositiveDouble || t[n + 1] != e.PositiveSingle && t[n + 1] != e.PositiveDouble)) {
                    s = t[n];
                    t[n] = t[n - 1],
                    t[n - 1] = s,
                    o = !1
                }
                i++
            }
        },
        o.prototype.generateArrayOfElements = function() {
            for (var t = this.isTutorial ? [e.PositiveSingle, e.NeutralDouble, e.PositiveSingle, e.PositiveSingle, e.PositiveDouble] : [e.NeutralSingle, e.NeutralSingle, e.Bomb, e.Bomb, e.Bomb, e.PositiveSingle, e.PositiveSingle], i = 7; i < 15;) {
                var o = this.getNewItemType();
                14 == i && this.getItemWeight(o) > 1 || this.canAddType(t, o) && (t.push(o), i += this.getItemWeight(o))
            }
            return t
        },
        o.prototype.getNewItemType = function() {
            var i = t.RandomHelper.getRandomIntInclusive(0, 100);
            return this.isTutorial ? e.NeutralSingle: i <= 20 ? e.NeutralSingle: i > 20 && i <= 30 ? e.NeutralDouble: i > 30 && i <= 60 ? e.Bomb: i > 60 && i <= 90 ? e.PositiveSingle: i > 90 ? e.PositiveDouble: void 0
        },
        o.prototype.canAddType = function(t, e) {
            if (this.isTutorial) return ! 0;
            var i = this.getMaxAmountOf(e);
            return t.filter(function(t) {
                return t == e
            }).length != i
        },
        o.prototype.getMaxAmountOf = function(e) {
            switch (e) {
            case t.LockItemType.Bomb:
                return 6;
            case t.LockItemType.NeutralDouble:
                return 2;
            case t.LockItemType.NeutralSingle:
                return 4;
            case t.LockItemType.PositiveDouble:
                return 2;
            case t.LockItemType.PositiveSingle:
                return 5
            }
        },
        o.prototype.getItemWeight = function(e) {
            switch (e) {
            case t.LockItemType.Bomb:
            case t.LockItemType.NeutralSingle:
            case t.LockItemType.PositiveSingle:
                return 1;
            case t.LockItemType.NeutralDouble:
            case t.LockItemType.PositiveDouble:
                return 2
            }
        },
        o.prototype.addSpriteByType = function(e, i) {
            switch (i) {
            case t.LockItemType.Bomb:
                return this.getItem(e, t.ArtConsts.LockBomb);
            case t.LockItemType.NeutralSingle:
                return this.getItem(e, t.ArtConsts.LockFixedRod);
            case t.LockItemType.NeutralDouble:
                return this.getItem(e, t.ArtConsts.LockDoubleFixedRod);
            case t.LockItemType.PositiveSingle:
                return this.getItem(e, t.ArtConsts.LockRod);
            case t.LockItemType.PositiveDouble:
                return this.getItem(e, t.ArtConsts.LockDoubleRod)
            }
        },
        o.prototype.getItem = function(e, i) {
            var o = this.radius;
            i == t.ArtConsts.LockFixedRod && (o += 16),
            i == t.ArtConsts.LockBomb && (o += 24),
            i == t.ArtConsts.LockDoubleRod && (o -= 5),
            i == t.ArtConsts.LockDoubleFixedRod && (o += 10);
            var n, s, a = 180 - 22.5 * e;
            n = o * Math.sin(Phaser.Math.degToRad(a)),
            s = o * Math.cos(Phaser.Math.degToRad(a));
            var r = t.ShapeFactoryHelper.getShape(this.game, n, 35 + s, t.ArtConsts.Items1, i);
            r.anchor.set(.5, .5);
            var h = a + 45 * e;
            if (i != t.ArtConsts.LockDoubleRod && i != t.ArtConsts.LockDoubleFixedRod || (h -= 10), r.angle = h, i == t.ArtConsts.LockBomb) {
                var d = new t.LockBombLamp(this.game, 2, 11);
                r.addChild(d)
            }
            return this.items.push(new t.LockItem(e, i, r)),
            r
        },
        o.prototype.update = function() {
            var e = this;
            if (this.isFly) this.lockSwitch.frameName = t.ArtConsts.LockSwitch + t.FrameHelper.getFrame(1),
            this.flyArrow();
            else {
                if (this.isFrontOfRoad) return;
                if (this.tutorialStep >= 2 && (this.tutorialShadow.destroy(), this.isTutorial = !1, t.GameStatus.isTutorialChestSeen = !0), this.lockSwitch.frameName = t.ArtConsts.LockSwitch + t.FrameHelper.getFrame(0), this.isLatestMove && !this.isCompleted) return t.AdManager.instance.isInterstitialAvailable() ? setTimeout(function() {
                    t.AdManager.instance.showAd(e.onChestOpened)
                },
                250) : this.onChestOpened(),
                this.lockSwitch.frameName = t.ArtConsts.LockSwitch + t.FrameHelper.getFrame(1),
                this.isCompleted = !0,
                void(this.isClickDisabled = !0);
                if (this.isTutorial) {
                    if (!this.tutorialShadow) {
                        var i = this.game.add.graphics(0, 0);
                        i.name = t.Consts.Shadow,
                        i.alpha = .5,
                        i.beginFill(0),
                        i.drawRect(2 * -this.game.width, 2 * -this.game.height, 4 * this.game.width, 4 * this.game.height),
                        this.lockBody.addChild(i),
                        this.tutorialShadow = i
                    }
                    this.lockArrow.bringToTop(),
                    this.lockSwitch.bringToTop();
                    var o = this.getItemToMove();
                    if (o.lockType == t.LockType.Road && !o.isMoved) {
                        this.isFrontOfRoad = !0,
                        o.shape.bringToTop();
                        var n = new t.Arm(this.game, this.centerX + 150, this.centerY + 150);
                        n.name = t.Consts.CardWithArm,
                        this.add(n),
                        this.tutorialStep++
                    }
                }
                this.rotateArrow()
            }
        },
        o.prototype.onClick = function() {
            if (!this.isClickDisabled) {
                if (this.isFrontOfRoad = !1, this.isTutorial) {
                    var e = this.getByName(t.Consts.CardWithArm);
                    e && this.remove(e)
                }
                if (!this.isFly) {
                    this.isFly = !0,
                    this.moveBack = !1,
                    this.arrowStartX = this.lockArrow.x,
                    this.arrowStartY = this.lockArrow.y,
                    this.arrowStepX = this.arrowSpeed * Math.sin(Phaser.Math.degToRad(this.lockArrow.angle)),
                    this.arrowStepY = this.arrowSpeed * -Math.cos(Phaser.Math.degToRad(this.lockArrow.angle)),
                    this.itemToMove = this.getItemToMove();
                    var i = this.itemToMove.shape.angle;
                    this.itemToMove.section % 1 != 0 ? i += 190 : i += 180,
                    this.itemToMoveStepX = this.arrowSpeed * Math.sin(Phaser.Math.degToRad(i)),
                    this.itemToMoveStepY = this.arrowSpeed * -Math.cos(Phaser.Math.degToRad(i)),
                    this.isLongWay = this.itemToMove.lockType === t.LockType.Road
                }
            }
        },
        o.prototype.getItemToMove = function() {
            var e = 16 * (this.lockArrow.angle < 0 ? 360 + this.lockArrow.angle: this.lockArrow.angle) / 360,
            i = this.items.map(function(t) {
                return t.section
            }),
            o = t.ArrayHelper.findNearestValue(e, i);
            return this.items.filter(function(t) {
                return t.section === o
            })[0]
        },
        o.prototype.flyArrow = function() {
            var e = this;
            this.moveBack ? (this.lockArrow.x -= this.arrowStepX, this.lockArrow.y -= this.arrowStepY) : (this.lockArrow.x += this.arrowStepX, this.lockArrow.y += this.arrowStepY);
            var i = Math.sqrt(Math.pow(this.lockArrow.x - this.arrowStartX, 2) + Math.pow(this.lockArrow.y - this.arrowStartY, 2));
            if (this.isLongWay) i > this.longLength && (t.SoundController.instance.playSound(t.SoundConsts.PickLockSuccess), this.moveBack = !0, this.itemToMove.isMoved = !0, this.checkIsWin() && (this.isLatestMove = !0, this.lockBridge.open())),
            i > this.shortLength && !this.moveBack && !this.itemToMove.isMoved && (this.itemToMove.shape.x += this.itemToMoveStepX, this.itemToMove.shape.y += this.itemToMoveStepY);
            else if (i > this.shortLength && (t.SoundController.instance.playSound(t.SoundConsts.PickLockNeutral), this.moveBack = !0, this.itemToMove.lockType == t.LockType.Bomb)) return t.AdManager.instance.isInterstitialAvailable() ? setTimeout(function() {
                t.AdManager.instance.showAd(function() {
                    e.onChestClosed && e.onChestClosed()
                })
            },
            500) : this.onChestClosed && this.onChestClosed(),
            void(this.isClickDisabled = !0);
            this.lockArrow.x <= this.arrowStartX + 1.1 && this.lockArrow.x >= this.arrowStartX - 1.1 && this.lockArrow.y <= this.arrowStartY + 1.1 && this.lockArrow.y >= this.arrowStartY - 1.1 && (this.lockArrow.x = this.arrowStartX, this.lockArrow.y = this.arrowStartY, this.isFly = !1)
        },
        o.prototype.rotateArrow = function() {
            this.clockwise ? this.lockArrow.angle += this.lockArrowRotateStep: this.lockArrow.angle -= this.lockArrowRotateStep,
            this.lockArrow.angle <= this.lockArrowAngle && this.lockArrow.angle > 0 && (this.clockwise = !0),
            this.lockArrow.angle >= -this.lockArrowAngle && this.lockArrow.angle < 0 && (this.clockwise = !1)
        },
        o.prototype.checkIsWin = function() {
            var e = !0;
            return this.items.forEach(function(i) {
                i.lockType !== t.LockType.Road || i.isMoved || (e = !1)
            }),
            e
        },
        o.prototype.destroy = function() {
            this.isTutorial && (t.GameStatus.isTutorialChestSeen = !0),
            i.prototype.destroy.call(this, !0)
        },
        o
    } (Phaser.Group);
    t.ChestUnlock = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.ChoiceBackground + a) || this).anchor.set(.5, .5),
            s.game.world.add(s),
            s
        }
        return __extends(i, e),
        i.prototype.changeFrame = function(e) {
            this.frameName = t.ArtConsts.ChoiceBackground + t.FrameHelper.getFrame(e)
        },
        i
    } (t.SpriteBase);
    t.ChoiceBackground = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            return s.coin = new t.Coin(s.game, -30, -s.height / 3, "0"),
            s.addChild(s.coin),
            s.addLock(),
            s.heroType = t.HeroType.Base,
            s.addHero(s.heroType),
            s.iGroup = s.game.add.group(),
            s.addChild(s.iGroup),
            s.showHero(),
            s
        }
        return __extends(i, e),
        i.prototype.addLock = function() {
            this.lock = new t.Lock(this.game, 0, 0),
            this.lock.x = .5 * this.width - .5 * this.lock.width,
            this.lock.y = .5 * this.height - .5 * this.lock.height,
            this.addChild(this.lock)
        },
        i.prototype.hideCoin = function() {
            this.coin.visible = !1
        },
        i.prototype.showCoin = function(t) {
            this.coin.visible = !0,
            this.coin.setText(t.toString())
        },
        i.prototype.hideLock = function() {
            this.lock.isTweenRunning() || (this.lock.visible = !1)
        },
        i.prototype.showLock = function() {
            this.lock.isTweenRunning() || (this.lock.visible = !0)
        },
        i.prototype.startLockAnimation = function() {
            this.lock.isTweenRunning() || this.lock.unlock(this.endLockAnimation.bind(this))
        },
        i.prototype.endLockAnimation = function() {
            this.lock.destroy(),
            this.addLock(),
            this.hideLock()
        },
        i.prototype.setHeroType = function(t) {
            this.showHero(),
            this.heroType != t && (this.heroType = t, this.hero.destroy(), this.addHero(t))
        },
        i.prototype.setHeroTypeCallback = function(t, e, i) {
            this.setHeroType(i)
        },
        i.prototype.setITypeCallback = function(t, e, i) {
            this.setIType(i)
        },
        i.prototype.setIType = function(e) {
            if (this.showIGroup(), this.iHeroType != e) switch (this.iHeroType = e, this.iGroup.removeAll(), e) {
            case t.HeroType.Base:
                this.setIForBase();
                break;
            case t.HeroType.Bomb:
                this.setIForBomb();
                break;
            case t.HeroType.Key:
                this.setIForKey();
                break;
            case t.HeroType.Gun:
                this.setIForGun()
            }
        },
        i.prototype.setIForBase = function() {
            var e = new t.Shield(this.game, -80, 0, 3);
            e.stopAnimation();
            var i = t.TextHelper.getText(this.game, 30, -30, "", "#ffffff", 45);
            e.addChild(i);
            var o = t.TextHelper.getText(this.game, -30, 0, "+", "#ffffff", 45),
            n = new t.Shield(this.game, 25, 0, 0);
            n.stopAnimation();
            var s = t.TextHelper.getText(this.game, 30, -30, "", "#ffffff", 45);
            n.addChild(s);
            var a = t.TextHelper.getText(this.game, 100, 0, "= +1", "#ffffff", 45);
            this.iGroup.add(e),
            this.iGroup.add(o),
            this.iGroup.add(n),
            this.iGroup.add(a)
        },
        i.prototype.setIForBomb = function() {
            var e = new t.Cannon(this.game, -30, -70);
            e.stopAnimation(),
            e.scale.set(.8);
            var i = t.TextHelper.getText(this.game, 30, e.y, "+2", "#ffffff", 45);
            this.iGroup.add(e),
            this.iGroup.add(i);
            var o = new t.Boom(this.game, -90, 50);
            o.changeFrame(2),
            o.scale.set(.4);
            var n = t.TextHelper.getText(this.game, -50, 50, "+", "#ffffff", 45),
            s = new t.HeroSprite(this.game, 0, 30, t.HeroType.Bomb, 0);
            s.stopAnimation(),
            s.scale.set(.6);
            var a = t.TextHelper.getText(this.game, 50, 50, "=", "#ffffff", 45),
            r = t.ShapeFactoryHelper.getShape(this.game, 100, 50, t.ArtConsts.Items1, t.ArtConsts.Smile);
            this.iGroup.add(o),
            this.iGroup.add(n),
            this.iGroup.add(s),
            this.iGroup.add(a),
            this.iGroup.add(r)
        },
        i.prototype.setIForKey = function() {
            var e = new t.Barrel(this.game, -60, -90);
            e.stopAnimation(),
            e.scale.set(.8);
            var i = t.TextHelper.getText(this.game, 10, -70, "", "#ffffff", 45),
            o = t.ShapeFactoryHelper.getShape(this.game, 70, -70, t.ArtConsts.Items1, t.ArtConsts.Smile);
            this.iGroup.add(e),
            this.iGroup.add(i),
            this.iGroup.add(o);
            var n = new t.Chest(this.game, -90, 70);
            n.stopAnimation(),
            n.scale.set(.6);
            var s = t.TextHelper.getText(this.game, -35, 70, "+", "#ffffff", 45),
            a = t.ShapeFactoryHelper.getShape(this.game, 0, 70, t.ArtConsts.Items1, t.ArtConsts.Key4);
            a.scale.set(.8);
            var r = t.TextHelper.getText(this.game, 35, 70, "=", "#ffffff", 45),
            h = new t.Chest(this.game, 90, 70);
            h.stopAnimation(),
            h.changeToOpen(),
            h.scale.set(.6),
            this.iGroup.add(n),
            this.iGroup.add(s),
            this.iGroup.add(a),
            this.iGroup.add(r),
            this.iGroup.add(h)
        },
        i.prototype.setIForGun = function() {
            var e = new t.Shield(this.game, -60, -70, 2);
            e.stopAnimation();
            var i = t.TextHelper.getText(this.game, 10, -70, "", "#ffffff", 45),
            o = t.ShapeFactoryHelper.getShape(this.game, 80, -70, t.ArtConsts.Items1, t.ArtConsts.Lightning);
            this.iGroup.add(e),
            this.iGroup.add(i),
            this.iGroup.add(o);
            var n = new t.Trap(this.game, -90, 70);
            n.scale.set(.5);
            var s = t.TextHelper.getText(this.game, -40, 100, "+", "#ffffff", 45),
            a = new t.HeroSprite(this.game, 15, 40, t.HeroType.Gun, 0);
            a.stopAnimation(),
            a.scale.set(.7);
            var r = t.TextHelper.getText(this.game, 60, 100, "=", "#ffffff", 45),
            h = t.ShapeFactoryHelper.getShape(this.game, 105, 90, t.ArtConsts.Items1, t.ArtConsts.Smile);
            this.iGroup.add(n),
            this.iGroup.add(s),
            this.iGroup.add(a),
            this.iGroup.add(r),
            this.iGroup.add(h)
        },
        i.prototype.addHero = function(e) {
            this.hero = new t.HeroSprite(this.game, 0, this.height / 15, e, 0),
            this.addChild(this.hero)
        },
        i.prototype.showHero = function() {
            this.changeFrame(0),
            this.iGroup.visible = !1,
            this.hero.visible = !0,
            this.coin.visible = !0,
            this.lock.visible = !0
        },
        i.prototype.showIGroup = function() {
            this.changeFrame(1),
            this.iGroup.visible = !0,
            this.hero.visible = !1,
            this.coin.visible = !1,
            this.lock.visible = !1
        },
        i
    } (t.ChoiceBackground);
    t.ChoiceHero = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s, a) {
            void 0 === a && (a = !1);
            var r = this,
            h = t.FrameHelper.getFrame(0),
            d = t.ArtConsts.Coin;
            return (r = e.call(this, i, o, n, t.ArtConsts.Items1, d + h) || this).animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(d, 0, 9, "", 4), 30, !1, !1),
            r.coinTxt = t.TextHelper.getText(i, r.width / 2, 0, s, "#ffffff", t.Consts.numbersFontWeight),
            r.addChild(r.coinTxt),
            r.coinTxt.anchor.set(0, .5),
            r.anchor.setTo(.5, .5),
            r.game.world.add(r),
            r.needToShake = a,
            r
        }
        return __extends(i, e),
        i.prototype.setText = function(t) {
            this.coinTxt.setText(t)
        },
        i.prototype.update = function() {
            this.needToShake && e.prototype.update.call(this)
        },
        i
    } (t.SpriteShakeBase);
    t.Coin = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.CoinBag + a) || this).anchor.set(.5, .5),
            s
        }
        return __extends(i, e),
        i
    } (t.SpriteShakeBase);
    t.CoinBag = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.CoinPanel + a) || this).anchor.set(.5, .5),
            s.coin = new t.Coin(s.game, -s.width / 2 + 70, 0, t.StringFormatHelper.ThousandsSeparator(t.GameStatus.gold)),
            s.addChild(s.coin),
            s.prevCoinCount = t.GameStatus.gold,
            s.game.world.add(s),
            s
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.prevCoinCount != t.GameStatus.gold && (this.coin.play(t.AnimationConsts.Action, null, !1), this.prevCoinCount = t.GameStatus.gold, this.coin.setText(t.StringFormatHelper.ThousandsSeparator(t.GameStatus.gold)))
        },
        i
    } (Phaser.Sprite);
    t.CoinPanel = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Dust + t.FrameHelper.getFrame(0)) || this;
            return s.anchor.set(.5, .5),
            s.alpha = 0,
            s.playAnimation(),
            s
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            var e = this.game.add.tween(this).to({
                alpha: .5
            },
            10, null, null, t.RandomHelper.getRandomIntInclusive(50, 500)),
            i = this.game.add.tween(this.scale).to({
                x: 2.5,
                y: 2.5
            },
            150).to({
                x: 0,
                y: 0
            },
            300, null, null, 50);
            i.onComplete.add(function() {
                this.destroy()
            },
            this),
            e.chain(i),
            e.start()
        },
        i
    } (Phaser.Sprite);
    t.Dust = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(0),
            h = t.ArtConsts.Enemy + "_" + s.toString(),
            d = t.ArtConsts.Items2;
            return (a = e.call(this, i, o, n, d, h + r) || this).setPosition(s),
            a.name = t.Consts.CardManAnimation,
            a.anchor.set(.5, .9),
            a.animationTween = a.generateTween(),
            a.animationTween.loop(!0),
            setTimeout(a.animationTween.start.bind(a.animationTween), t.RandomHelper.getRandomIntInclusive(0, 300)),
            a
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            this.animationTween && this.animationTween.isPaused && this.animationTween.resume()
        },
        i.prototype.stopAnimation = function() {
            this.animationTween.pause()
        },
        i.prototype.setPosition = function(t) {
            switch (t) {
            case 1:
                this.x = -2,
                this.y = 80;
                break;
            case 2:
                this.x = -5,
                this.y = 82;
                break;
            case 3:
                this.x = -11,
                this.y = 81;
                break;
            case 4:
                this.x = -10,
                this.y = 80;
                break;
            case 5:
                this.x = -3,
                this.y = 77;
                break;
            case 6:
                this.x = -13,
                this.y = 80;
                break;
            case 7:
                this.x = -4,
                this.y = 79;
                break;
            case 8:
                this.x = -12,
                this.y = 80;
                break;
            default:
                throw new Error("Invalid value")
            }
        },
        i.prototype.generateTween = function() {
            return this.game.add.tween(this).to({
                width: 1.05 * this.width,
                height: .95 * this.height
            },
            t.Consts.WarriorAnimationDuration).to({
                width: this.width,
                height: this.height
            },
            t.Consts.WarriorAnimationDuration)
        },
        i
    } (t.SpriteAnimationBase);
    t.Enemy = e;
    var i = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            return s.name = t.Consts.CardManAnimation,
            s.scale.set(.9, .9),
            s.anchor.set(.5, .9),
            s.init(),
            s.animationTweens = s.generateTween(),
            s.animationTweens.forEach(function(t) {
                return t.loop(!0)
            }),
            s.animationTweens.forEach(function(t) {
                return t.start()
            }),
            s
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            this.animationTweens && this.animationTweens[0].isPaused && this.animationTweens.forEach(function(t) {
                return t.resume()
            })
        },
        i.prototype.init = function() {
            this.pipe = new Phaser.Sprite(this.game, -2, 10, t.ArtConsts.Items2, t.ArtConsts.Enemy9Pipe + t.FrameHelper.getFrame(0)),
            this.man = new Phaser.Sprite(this.game, -10, 30, t.ArtConsts.Items2, t.ArtConsts.Enemy + "_9" + t.FrameHelper.getFrame(0)),
            this.vane = new o(this.game, 0, -65),
            this.pipe.anchor.set(.5, 1),
            this.man.anchor.set(.5, .5),
            this.vane.anchor.set(.5, .5),
            this.addChild(this.pipe),
            this.addChild(this.man),
            this.addChild(this.vane)
        },
        i.prototype.stopAnimation = function() {
            this.animationTweens.forEach(function(t) {
                return t.pause()
            })
        },
        i.prototype.generateTween = function() {
            return [this.generateTweenUnitForMan(this.man), this.generateTweenUnit(this.pipe), this.generateTweenUnit(this.vane)]
        },
        i.prototype.generateTweenUnit = function(e, i) {
            return void 0 === i && (i = 15),
            this.game.add.tween(e).to({
                y: "+" + i
            },
            t.Consts.WarriorAnimationDuration).to({
                y: "-" + i
            },
            t.Consts.WarriorAnimationDuration)
        },
        i.prototype.generateTweenUnitForMan = function(e, i) {
            return void 0 === i && (i = 15),
            this.game.add.tween(e).to({
                y: "+" + i
            },
            t.Consts.WarriorAnimationDuration).to({
                y: "-" + i
            },
            t.Consts.WarriorAnimationDuration)
        },
        i
    } (t.SpriteAnimationBase);
    t.Enemy9 = i;
    var o = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n, t.ArtConsts.Items2, t.ArtConsts.Enemy9Vane + t.FrameHelper.getFrame(0)) || this;
            return s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.Enemy9Vane, 0, 17, "", 4), 30, !0, !1),
            s.animations.play(t.AnimationConsts.Action),
            s
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.Vane = o
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.GameStatusPanel + a) || this).addChild(t.ShapeFactoryHelper.getShape(s.game, 100, s.height / 2, t.ArtConsts.Items1, t.ArtConsts.TurnsToBoss)),
            s.turnToBoss = t.TextHelper.getText(s.game, 180, s.height / 2, t.GameStatus.turnsToBoss.toString(), "#ffffff", t.Consts.numbersFontWeight),
            s.addChild(s.turnToBoss),
            s.addChild(t.TextHelper.getText(s.game, 280, s.height / 2, "X", "#FF5F41", t.Consts.textFontWeight)),
            s.gameLevel = t.TextHelper.getText(s.game, 305, s.height / 2, t.GameStatus.gameLevel.toString(), "#FCE58D", t.Consts.numbersFontWeight),
            s.addChild(s.gameLevel),
            s.currentCoinValue = t.GameStatus.goldPerGame,
            s.coin = new t.Coin(s.game, 360, s.height / 2, t.StringFormatHelper.ThousandsSeparator(s.currentCoinValue)),
            s.addChild(s.coin),
            s
        }
        return __extends(i, e),
        i.prototype.update = function() {
            var e = 0 == t.GameStatus.turnsToBoss || t.GameStatus.turnsToBoss == t.GameStatus.levelStep + 1 ? "--": t.GameStatus.turnsToBoss.toString();
            this.turnToBoss.setText(e),
            this.gameLevel.setText(t.GameStatus.gameLevel.toString()),
            this.setCoin()
        },
        i.prototype.setCoin = function() {
            this.currentCoinValue != t.GameStatus.goldPerGame && (this.coin.setText(t.StringFormatHelper.ThousandsSeparator(t.GameStatus.goldPerGame)), this.isLongRotation = t.GameStatus.goldPerGame - this.currentCoinValue > t.Consts.CoinMaxValue, this.currentCoinValue = t.GameStatus.goldPerGame, this.coinRotationAnimation = this.coin.animations.play(t.AnimationConsts.Action, 30, this.isLongRotation), this.coinRotationAnimation.onLoop.add(this.onRotationLoop, this))
        },
        i.prototype.onRotationLoop = function() {
            this.isLongRotation && this.coinRotationAnimation.loopCount >= 2 && (this.coinRotationAnimation.loop = !1)
        },
        i
    } (Phaser.Sprite);
    t.GameStatusPanel = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(0),
            h = t.ArtConsts.Health + "_" + s.toString();
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, h + r) || this).anchor.setTo(.5, .5),
            a
        }
        return __extends(i, e),
        i
    } (t.SpriteShakeBase);
    t.Health = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(o, n, s, a, r) {
            void 0 === r && (r = t.RandomHelper.getRandomIntInclusive(0, 300));
            var h = this,
            d = i.getArtConst(a);
            return (h = e.call(this, o, n, s + 70, t.ArtConsts.Items2, d + t.FrameHelper.getFrame(0)) || this).anchor.set(.5, .9),
            h.startAnimation(r),
            h
        }
        return __extends(i, e),
        i.prototype.startAnimation = function(t) {
            this.animationTween && this.animationTween.stop(),
            this.animationTween = this.generateTween(),
            this.animationTween.loop(!0),
            setTimeout(this.animationTween.start.bind(this.animationTween), t)
        },
        i.getArtConst = function(e) {
            switch (e) {
            case t.HeroType.Base:
                return t.ArtConsts.Hero;
            case t.HeroType.Bomb:
                return t.ArtConsts.HeroBomb;
            case t.HeroType.Gun:
                return t.ArtConsts.HeroGun;
            case t.HeroType.Key:
                return t.ArtConsts.HeroKey;
            default:
                throw new Error("Not implemented")
            }
        },
        i.prototype.playAnimation = function() {
            this.animationTween && this.animationTween.isPaused && this.animationTween.resume()
        },
        i.prototype.stopAnimation = function() {
            this.animationTween.pause()
        },
        i.prototype.generateTween = function() {
            return this.game.add.tween(this).to({
                width: 1.05 * this.width,
                height: .95 * this.height
            },
            t.Consts.WarriorAnimationDuration).to({
                width: this.width,
                height: this.height
            },
            t.Consts.WarriorAnimationDuration)
        },
        i
    } (t.SpriteAnimationBase);
    t.HeroSprite = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Lock + a) || this).anchor.setTo(.5, .5),
            s.isRoll = !1,
            s.onAnimation = !1,
            s
        }
        return __extends(i, e),
        i.prototype.changeFrame = function(e) {
            this.frameName = t.ArtConsts.Lock + t.FrameHelper.getFrame(e)
        },
        i.prototype.update = function() {
            this.isRoll && (this.angle += 30),
            this.onAnimation && (this.x += 12, this.y = .01 * Math.pow(this.x - this.beforeX - 50, 2) + this.beforeY - 20, this.y > this.game.height && (this.isRunning = !1, this.onAnimation = !1, this.kill(), this.onComplete()))
        },
        i.prototype.unlock = function(t) {
            this.isRunning = !0,
            this.onComplete = t,
            this.beforeX = this.x,
            this.beforeY = this.y;
            var e = this.game.add.tween(this).to({
                y: this.y - 30
            },
            100, Phaser.Easing.Bounce.In);
            e.onComplete.add(this.changeFrameToOpened, this);
            var i = this.game.add.tween(this).to({
                y: this.y
            },
            50, Phaser.Easing.Bounce.In, null, 30).to({
                y: this.y + 30
            },
            50, null, null, 50);
            i.onComplete.add(this.startRoll.bind(this)),
            i.onComplete.add(this.startAnimation.bind(this)),
            e.chain(i),
            e.start()
        },
        i.prototype.isTweenRunning = function() {
            return this.isRunning || this.isRoll || this.onAnimation
        },
        i.prototype.changeFrameToOpened = function() {
            this.changeFrame(1)
        },
        i.prototype.startAnimation = function() {
            this.onAnimation = !0
        },
        i.prototype.startRoll = function() {
            this.isRoll = !0
        },
        i
    } (t.SpriteBase);
    t.Lock = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0),
            r = t.ArtConsts.LockBombLamp;
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, r + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(r, 0, 19, "", 4), 60, !0, !1),
            setTimeout(s.playAnimation.bind(s), t.RandomHelper.getRandomIntInclusive(30, 300)),
            s
        }
        return __extends(i, e),
        i.prototype.playAnimation = function() {
            this.animations.play(t.AnimationConsts.Action)
        },
        i
    } (Phaser.Sprite);
    t.LockBombLamp = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            s.stars = [],
            s.anchor.set(.5);
            var a = new Phaser.Sprite(i, 0, 0, t.ArtConsts.Items2, t.ArtConsts.MenuLogo + t.FrameHelper.getFrame(0));
            a.anchor.setTo(.5, .5),
            s.addChild(a),
            s.width = a.width,
            s.height = a.height;
            for (var r = -300; r < 450; r += 100) for (var h = -170; h < 260; h += 100) {
                if (2 !== t.RandomHelper.getRandomIntInclusive(1, 2)) {
                    var d = new t.MenuStar(i, r, h, t.RandomHelper.getRandomIntInclusive(0, 500));
                    d.x += t.RandomHelper.getRandomIntInclusive( - 15, 15),
                    d.y += t.RandomHelper.getRandomIntInclusive( - 15, 15),
                    d.anchor.setTo(.5, .5),
                    s.addChild(d),
                    s.stars.push(d)
                }
            }
            return s
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.stars.forEach(function(t) {
                t.update()
            })
        },
        i
    } (Phaser.Sprite);
    t.MenuLogo = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.MenuStar + t.FrameHelper.getFrame(0)) || this;
            return a.startWidth = a.width,
            a.startHeight = a.height,
            a.width = 0,
            a.height = 0,
            a.alpha = 0,
            a.isShow = !1,
            a.delay = s,
            a
        }
        return __extends(i, e),
        i.prototype.update = function() {
            if (this.delay > 0) this.delay--;
            else {
                this.angle += .5;
                this.isShow ? (this.alpha > 0 ? this.alpha -= .0032 : this.alpha = 0, this.width > 0 ? this.width -= .008 * this.startWidth: this.width = 0, this.height > 0 ? this.height -= .008 * this.startHeight: this.height = 0) : (this.alpha < 1 && this.alpha + .008 < 1 ? this.alpha += .008 : this.alpha = 1, this.width < this.startWidth ? this.width += .008 * this.startWidth: this.width = this.startWidth, this.height < this.startHeight ? this.height += .008 * this.startHeight: this.height = this.startHeight),
                1 == this.alpha && this.height == this.startHeight && this.width == this.startWidth && (this.isShow = !0),
                0 == this.alpha && 0 == this.height && 0 == this.width && (this.isShow = !1)
            }
        },
        i
    } (Phaser.Sprite);
    t.MenuStar = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.MouseClick + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.MouseClick, 0, 5, "", 4), 60, !1, !1),
            s.visible = !1,
            s.animations.getAnimation(t.AnimationConsts.Action).onStart.add(s.onAnimationStart, s),
            s.animations.getAnimation(t.AnimationConsts.Action).onComplete.add(s.onAnimationComplete, s),
            s
        }
        return __extends(i, e),
        i.prototype.onAnimationStart = function() {
            this.visible = !0
        },
        i.prototype.onAnimationComplete = function() {
            this.visible = !1
        },
        i
    } (Phaser.Sprite);
    t.MouseClickAnimation = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e; !
    function(t) {
        t[t.X2 = 2] = "X2",
        t[t.X3 = 3] = "X3"
    } (e = t.MultiplierScore || (t.MultiplierScore = {}));
    var i = function(i) {
        function o(e, n, s, a) {
            var r = this,
            h = o.GetArtName(a),
            d = t.FrameHelper.getFrame(0);
            return (r = i.call(this, e, n, s, t.ArtConsts.Items1, h + d) || this).anchor.set(.5, .5),
            r
        }
        return __extends(o, i),
        o.GetArtName = function(i) {
            switch (i) {
            case e.X2:
                return t.ArtConsts.Multiplier2;
            case e.X3:
                return t.ArtConsts.Multiplier3
            }
        },
        o
    } (t.SpriteShakeBase);
    t.Multiplier = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o - 3, n + 1, t.ArtConsts.Items1, t.ArtConsts.NoAccess + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(t.ArtConsts.NoAccess, 0, 5, "", 4), 60, !1),
            s
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.NoAccess = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n, t.ArtConsts.PauseLogo) || this;
            return s.frameNum = 0,
            s.step = 3,
            s.lineWidth = 20,
            s.diameter = 200,
            s.circleAlpha = .65,
            s.isFirstDown = !0,
            s.isDoNothing = !0,
            s.graphics = i.add.graphics(0, 0),
            s.graphics.lineStyle(s.lineWidth, 16777215, s.circleAlpha),
            s.graphics.drawCircle(0, 0, s.diameter),
            s.addChild(s.graphics),
            s
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.isDoNothing ? this.isDoNothing = !this.isDoNothing: (this.isDoNothing = !this.isDoNothing, 40 == this.frameNum ? this.frameNum = 1 : this.frameNum++, this.frameNum <= 10 ? (this.width += this.step, this.height += this.step) : (this.width -= this.step / 3, this.height -= this.step / 3), this.frameNum < 10 ? (this.circleAlpha > .1 && (this.circleAlpha -= .1), this.lineWidth -= .1) : 10 === this.frameNum ? (this.diameter = 200, this.lineWidth = 25, this.circleAlpha = .2) : this.frameNum > 10 && this.frameNum < 19 ? (this.diameter += 20, this.lineWidth -= 1, this.circleAlpha += .1) : this.frameNum > 19 && (this.diameter += 8, this.lineWidth -= .3, this.circleAlpha > .1 && (this.circleAlpha -= .01)), this.graphics.clear(), this.graphics.lineWidth = this.lineWidth, this.graphics.alpha = this.circleAlpha, this.graphics.drawCircle(0, 0, this.diameter))
        },
        i
    } (Phaser.Sprite);
    t.PauseLogo = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            void 0 === s && (s = t.RandomHelper.getRandomIntInclusive(0, 200));
            var a = this,
            r = t.FrameHelper.getFrame(0);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Poison + r, !1, s) || this).anchor.set(.5, .5),
            a
        }
        return __extends(i, e),
        i
    } (t.SpriteShakeBase);
    t.Poison = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s, a, r, h, d) {
            void 0 === r && (r = t.Consts.ScaleSize),
            void 0 === h && (h = .3),
            void 0 === d && (d = !1);
            var c = e.call(this, i, o, n, s, a) || this;
            return c.waveHeight = 0,
            c.isUp = d,
            c.scaleSize = r,
            c.speed = h,
            c
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.waveHeight += .3,
            this.isUp ? (this.width += this.speed, this.height += this.speed) : (this.width -= this.speed, this.height -= this.speed),
            this.waveHeight >= this.scaleSize && (this.isUp = !this.isUp, this.waveHeight = 0)
        },
        i
    } (Phaser.Sprite);
    t.SpriteScaleBase = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            void 0 === s && (s = !1);
            var a = this,
            r = t.FrameHelper.getFrame(0);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Shadow + r, 7, .2, s) || this).anchor.set(.5, .5),
            a.game.world.add(a),
            a
        }
        return __extends(i, e),
        i
    } (t.SpriteScaleBase);
    t.Shadow = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = this,
            r = t.FrameHelper.getFrame(s);
            return (a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.Shield + r) || this).anchor.add(.5, .5),
            a
        }
        return __extends(i, e),
        i
    } (t.SpriteShakeBase);
    t.Shield = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s, a, r) {
            var h = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.ShopItemBackground + t.FrameHelper.getFrame(0)) || this;
            return h.anchor.set(.5),
            h.price = a,
            h.shopItemType = s,
            h.initMainGroup(s, r),
            h.initIGroup(s),
            h
        }
        return __extends(i, e),
        i.prototype.initMainGroup = function(t, e) {
            this.mainGroup = this.game.add.group(),
            this.addChild(this.mainGroup),
            this.addShadow(t),
            this.addRings(),
            this.addMainImage(t),
            this.addCoin(),
            this.addCheckMark(),
            this.initButtons(),
            this.addIBtn(),
            this.onClickExternal = e
        },
        i.prototype.initIGroup = function(e) {
            switch (this.iGroup = this.game.add.group(), this.addChild(this.iGroup), this.iGroup.visible = !1, this.prevBtn = this.addBtn( - this.width / 3 + 5, this.height / 2 + 10, t.BtnType.PrevSmall, this.onPrevClick), this.iGroup.add(this.prevBtn), e) {
            case t.ShopItemType.Heart:
                this.setIForHeart();
                break;
            case t.ShopItemType.Horseshoe:
                this.setIForHorseshoe();
                break;
            case t.ShopItemType.Luck:
                this.setIForLuck();
                break;
            case t.ShopItemType.Key:
                this.setIForKey()
            }
        },
        i.prototype.addIBtn = function() {
            this.iBtn = this.addBtn( - this.width / 3 + 5, this.height / 2 + 10, t.BtnType.I, this.onIClick),
            this.mainGroup.add(this.iBtn)
        },
        i.prototype.onIClick = function() {
            var e = t.TweenHelper.scaleIn(this.game, this.iBtn);
            this.isAdvVisible = this.rewardedVideoButton.visible;
            var i = this.isAdvVisible ? t.TweenHelper.scaleIn(this.game, this.rewardedVideoButton, !1) : null;
            this.isPlusVisible = this.plusBtn.visible;
            var o = this.isPlusVisible ? t.TweenHelper.scaleIn(this.game, this.plusBtn, !1) : null,
            n = t.TweenHelper.turnAnimationStart(this.game, this);
            n.onComplete.add(this.showIGroup, this);
            var s = t.TweenHelper.turnAnimationEnd(this.game, this);
            s.onComplete.add(this.scaleSprite, this);
            var a = [i, o, n, s, t.TweenHelper.scaleOut(this.game, this.prevBtn)];
            e.chain.apply(e, a.filter(function(t) {
                return null !== t
            }))
        },
        i.prototype.onPrevClick = function() {
            var e = t.TweenHelper.scaleIn(this.game, this.prevBtn),
            i = t.TweenHelper.turnAnimationStart(this.game, this);
            i.onComplete.add(this.showMainGroup, this);
            var o = t.TweenHelper.turnAnimationEnd(this.game, this);
            o.onComplete.add(this.scaleSprite, this);
            var n = [i, o, t.TweenHelper.scaleOut(this.game, this.iBtn), this.isAdvVisible ? t.TweenHelper.scaleOut(this.game, this.rewardedVideoButton, .9) : null, this.isPlusVisible ? t.TweenHelper.scaleOut(this.game, this.plusBtn, .9) : null];
            e.chain.apply(e, n.filter(function(t) {
                return null !== t
            }))
        },
        i.prototype.setIForHeart = function() {
            var e = t.TextHelper.getText(this.game, -30, 0, "+", "#ffffff", 45),
            i = t.ShapeFactoryHelper.getShape(this.game, 20, 0, t.ArtConsts.Items1, t.ArtConsts.BigHeart);
            this.iGroup.add(e),
            this.iGroup.add(i)
        },
        i.prototype.setIForHorseshoe = function() {
            var e = t.ShapeFactoryHelper.getShape(this.game, -80, 30, t.ArtConsts.Items1, t.ArtConsts.BigHorseshoe);
            e.scale.set(.7);
            var i = t.TextHelper.getText(this.game, -35, 30, "+", "#ffffff", 45),
            o = new t.HeroSprite(this.game, 15, -10, t.HeroType.Base);
            o.stopAnimation(),
            o.scale.set(.7);
            var n = t.TextHelper.getText(this.game, 75, 30, "= +1", "#ffffff", 45);
            this.iGroup.add(e),
            this.iGroup.add(i),
            this.iGroup.add(o),
            this.iGroup.add(n)
        },
        i.prototype.setIForLuck = function() {
            var e = new t.Poison(this.game, -80, 0);
            e.stopAnimation();
            var i = t.TextHelper.getText(this.game, -40, 0, "+", "#ffffff", 45),
            o = t.ShapeFactoryHelper.getShape(this.game, -5, 0, t.ArtConsts.Items1, t.ArtConsts.BigLuck);
            o.angle = 20;
            var n = t.TextHelper.getText(this.game, 25, 0, "=", "#ffffff", 45),
            s = new t.Poison(this.game, 75, 0, 0);
            s.stopAnimation();
            var a = t.ShapeFactoryHelper.getShape(this.game, s.x + 5, 0, t.ArtConsts.Items1, t.ArtConsts.NoIcon, 0);
            this.iGroup.add(e),
            this.iGroup.add(i),
            this.iGroup.add(o),
            this.iGroup.add(n),
            this.iGroup.add(s),
            this.iGroup.add(a)
        },
        i.prototype.setIForKey = function() {
            var e = new t.Chest(this.game, -80, 0);
            e.stopAnimation(),
            e.scale.set(.6);
            var i = t.TextHelper.getText(this.game, -30, 0, "+", "#ffffff", 45),
            o = t.ShapeFactoryHelper.getShape(this.game, -5, 0, t.ArtConsts.Items1, t.ArtConsts.Key4);
            o.scale.set(.8);
            var n = t.TextHelper.getText(this.game, 25, 0, "=", "#ffffff", 45),
            s = new t.Chest(this.game, 75, 0);
            s.stopAnimation(),
            s.changeToOpen(),
            s.scale.set(.6),
            this.iGroup.add(e),
            this.iGroup.add(i),
            this.iGroup.add(o),
            this.iGroup.add(n),
            this.iGroup.add(s)
        },
        i.prototype.showIGroup = function() {
            this.changeFrame(1),
            this.iGroup.visible = !0,
            this.mainGroup.visible = !1
        },
        i.prototype.showMainGroup = function() {
            this.changeFrame(0),
            this.iGroup.visible = !1,
            this.mainGroup.visible = !0
        },
        i.prototype.scaleSprite = function() {
            this.scale.set(.88, .88)
        },
        i.prototype.setStatus = function(e) {
            if (void 0 === e && (e = 0), !this.rewardedVideoButton.visible) {
                var i = t.GameStatus.gold >= this.price;
                this.isItemBought() ? this.checkMark.visible = !0 : (this.coin.visible = !0, Math.random() < e / 100 ? this.rewardedVideoButton.visible = !0 : i && (this.plusBtn.visible = !0))
            }
        },
        i.prototype.initButtons = function() {
            this.rewardedVideoButton = this.addBtn(this.width / 2 + 20, this.height / 2 + 20, t.BtnType.Adv, this.onRewardedVideoClicked, !0),
            this.rewardedVideoButton.visible = !1,
            this.mainGroup.add(this.rewardedVideoButton),
            this.plusBtn = this.addBtn(this.width / 2 + 20, this.height / 2 + 20, t.BtnType.Plus, this.onPlusBtnClick),
            this.plusBtn.visible = !1,
            this.mainGroup.add(this.plusBtn)
        },
        i.prototype.isItemBought = function() {
            return this.shopItemType == t.ShopItemType.Heart && t.GameStatus.isHeart || this.shopItemType == t.ShopItemType.Horseshoe && t.GameStatus.isHorseshoe || this.shopItemType == t.ShopItemType.Luck && t.GameStatus.isLuck || this.shopItemType == t.ShopItemType.Key && (t.GameStatus.isKey || t.GameStatus.currentHero == t.HeroType.Key)
        },
        i.prototype.updateGameStatus = function(e) {
            switch (void 0 === e && (e = !0), e && (t.GameStatus.gold -= this.price), this.shopItemType) {
            case t.ShopItemType.Heart:
                t.GameStatus.isHeart = !0;
                break;
            case t.ShopItemType.Horseshoe:
                t.GameStatus.isHorseshoe = !0;
                break;
            case t.ShopItemType.Luck:
                t.GameStatus.isLuck = !0;
                break;
            case t.ShopItemType.Key:
                t.GameStatus.isKey = !0
            }
        },
        i.prototype.onRewardedVideoClicked = function() {
            var e = this;
            t.AdManager.instance.isRewardedVideoAvailable() ? (t.AdManager.instance.onAdDismissSignal.add(this.dispatchAdDismissed, this), t.AdManager.instance.showRewardedAd(function() {
                return e.buyAdv()
            })) : this.buyAdv()
        },
        i.prototype.buyAdv = function() {
            this.updateGameStatus(!1),
            this.buy()
        },
        i.prototype.onPlusBtnClick = function() {
            t.GameStatus.gold < this.price || (this.updateGameStatus(), this.buy())
        },
        i.prototype.buy = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Buy),
            this.plusBtn.visible = !1,
            this.rewardedVideoButton.visible = !1,
            this.coin.visible = !1,
            this.checkMark.visible = !0,
            this.onClickExternal()
        },
        i.prototype.addRings = function() {
            this.mainGroup.addChild(new t.SmallRing(this.game, 0, 0, t.ArtConsts.SmallRing)),
            this.mainGroup.addChild(new t.BigRing(this.game, 0, 0, t.ArtConsts.BigRing))
        },
        i.prototype.addShadow = function(e) {
            switch (e) {
            case t.ShopItemType.Heart:
            case t.ShopItemType.Horseshoe:
            case t.ShopItemType.Luck:
                this.mainGroup.addChild(new t.Shadow(this.game, 0, 80));
                break;
            case t.ShopItemType.Key:
                this.mainGroup.addChild(new t.Shadow(this.game, -40, 80)),
                this.mainGroup.addChild(new t.Shadow(this.game, 0, 60, !0)),
                this.mainGroup.addChild(new t.Shadow(this.game, 40, 80))
            }
        },
        i.prototype.addMainImage = function(e) {
            switch (e) {
            case t.ShopItemType.Heart:
                this.mainGroup.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.BigHeart));
                break;
            case t.ShopItemType.Horseshoe:
                this.mainGroup.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.BigHorseshoe));
                break;
            case t.ShopItemType.Luck:
                var i = t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.BigLuck);
                i.angle = 20,
                this.mainGroup.addChild(i);
                break;
            case t.ShopItemType.Key:
                this.mainGroup.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, -20, t.ArtConsts.Items1, t.ArtConsts.Key4, 0, !0)),
                this.mainGroup.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, -40, 0, t.ArtConsts.Items1, t.ArtConsts.Key2)),
                this.mainGroup.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 40, 0, t.ArtConsts.Items1, t.ArtConsts.Key3))
            }
        },
        i.prototype.addBtn = function(e, i, o, n, s) {
            void 0 === s && (s = !1);
            var a = new t.Btn(this.game, e, i, o, n.bind(this), s);
            return a.x -= a.width / 3,
            a.y -= a.height / 3,
            a.scale.set(.9, .9),
            a
        },
        i.prototype.addCoin = function() {
            this.coin = new t.Coin(this.game, -30, -this.height / 3, this.price.toString()),
            this.mainGroup.addChild(this.coin)
        },
        i.prototype.addCheckMark = function() {
            this.checkMark = t.ShapeFactoryHelper.getShape(this.game, this.width / 3 - 15, this.height / 3, t.ArtConsts.Items1, t.ArtConsts.CheckMark),
            this.mainGroup.addChild(this.checkMark),
            this.checkMark.visible = !1
        },
        i.prototype.dispatchAdDismissed = function(e) {
            "rewardvideo" == e.adType && (t.AdManager.instance.wasRecentRewardedVideoFinished() ? this.buyAdv() : (this.rewardedVideoButton.visible = !1, this.setStatus(0)))
        },
        i.prototype.destroy = function() {
            t.AdManager.instance.onAdDismissSignal.remove(this.dispatchAdDismissed, this),
            e.prototype.destroy.call(this)
        },
        i.prototype.changeFrame = function(e) {
            this.frameName = t.ArtConsts.ShopItemBackground + t.FrameHelper.getFrame(e)
        },
        i
    } (t.SpriteBase);
    t.ShopCard = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.ArtConsts.Skull,
            r = t.FrameHelper.getFrame(1); (s = e.call(this, i, o, n, t.ArtConsts.Items1, a + r) || this).anchor.set(.5, .5);
            var h = Phaser.Animation.generateFrameNames(a, 0, 4, "", 4);
            return h.push.apply(h, Phaser.Animation.generateFrameNames(a, 3, 1, "", 4)),
            s.animations.add(t.AnimationConsts.Action, h, 60, !0, !1),
            s
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.Skull = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = e.call(this, i, o, n) || this;
            return s.anchor.set(.5, .5),
            s.addChild(new t.SkullLight(s.game, o - 5, n - 5, !1)),
            s.addChild(new t.Skull(s.game, 0, 0)),
            s
        }
        return __extends(i, e),
        i
    } (t.SpriteShakeBase);
    t.SkullContainer = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            void 0 === s && (s = !0);
            var a = this,
            r = t.FrameHelper.getFrame(0); ((a = e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.SkullLight + r) || this).anchor.set(.5, .5), a.bringToTop(), s) && a.game.add.tween(a.scale).to({
                x: 1.2,
                y: 1.2
            },
            100).to({
                x: 0,
                y: 0
            },
            200).start().onComplete.add(a.onSkullLightComplete, a);
            return a
        }
        return __extends(i, e),
        i.prototype.onSkullLightComplete = function() {
            this.destroy()
        },
        i
    } (Phaser.Sprite);
    t.SkullLight = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0),
            r = t.ArtConsts.SmallLightning;
            return (s = e.call(this, i, o, n, t.ArtConsts.Items1, r + a) || this).anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Action, Phaser.Animation.generateFrameNames(r, 0, 5, "", 4), 60, !0, !1),
            s.play(t.AnimationConsts.Action),
            s
        }
        return __extends(i, e),
        i
    } (Phaser.Sprite);
    t.SmallLightning = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n, s) {
            var a = e.call(this, i, o, n) || this;
            return a.container = new Phaser.Sprite(i, 0, 0),
            a.ring = t.ShapeFactoryHelper.getShape(i, 2, 2, t.ArtConsts.Items1, s),
            a.container.addChild(a.ring),
            a.addChild(a.container),
            a
        }
        return __extends(i, e),
        i.prototype.update = function() {
            this.canPlayAnimation && (this.container.angle -= 2)
        },
        i
    } (t.SpriteAnimationBase);
    t.SmallRing = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = this,
            a = t.FrameHelper.getFrame(0);
            return (s = e.call(this, i, o - 5, n, t.ArtConsts.Items2, t.ArtConsts.Trap + a) || this).isOpen = !0,
            s.anchor.set(.5, .5),
            s.animations.add(t.AnimationConsts.Open, Phaser.Animation.generateFrameNames(t.ArtConsts.Trap, 0, 4, "", 4), 60, !1, !1),
            s.animations.add(t.AnimationConsts.Close, Phaser.Animation.generateFrameNames(t.ArtConsts.Trap, 4, 0, "", 4), 60, !1, !1),
            s
        }
        return __extends(i, e),
        i.prototype.changeStatus = function() {
            return this.isOpen = !this.isOpen,
            this.isOpen ? this.animations.play(t.AnimationConsts.Close) : this.animations.play(t.AnimationConsts.Open),
            this.isOpen
        },
        i
    } (Phaser.Sprite);
    t.Trap = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(i, o, n) {
            var s = t.FrameHelper.getFrame(1);
            return e.call(this, i, o, n, t.ArtConsts.Items1, t.ArtConsts.LockBridge + s) || this
        }
        return __extends(i, e),
        i.prototype.open = function() {
            this.frameName = t.ArtConsts.LockBridge + t.FrameHelper.getFrame(0)
        },
        i
    } (Phaser.Sprite);
    t.LockBridge = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e, o) {
            void 0 === t && (t = .2),
            void 0 === e && (e = .2),
            void 0 === o && (o = !1),
            this.status = new i,
            this.initialStatus = new i,
            this.updateVal = t,
            this.step = e,
            this.resetToZero = o
        }
        return e.prototype.fillBasket = function(t, e) {
            for (var i = t; i <= e; i++) {
                var o = 3 - (i - 1) * this.step;
                this.initialStatus.ContainsKey(i.toString()) || (this.initialStatus.Add(i.toString(), o), this.status.Add(i.toString(), o))
            }
        },
        e.prototype.fillBasketWithStep = function(e, i, o, n) {
            this.fillBasket(e, Phaser.Math.clamp(i + Math.floor(t.GameStatus.gameLevel / o), e, n))
        },
        e.prototype.getFromBasket = function() {
            for (var t = this.status.Values().reduce(function(t, e) {
                return t + e
            }), e = Math.random() * t, i = 0, o = 0, n = this.status.Keys(); o < n.length; o++) {
                var s = n[o],
                a = this.status.Item(s);
                if (e > i && e < a + i) return this.removeFromBasket(s),
                s;
                i += a
            }
            throw new Error("Item not found in the basked")
        },
        e.prototype.removeFromBasket = function(t) {
            var e = this;
            this.status.Keys().forEach(function(i) {
                i === t ? e.resetToZero ? e.status.Add(t, 0) : e.status.Add(t, e.initialStatus.Item(t)) : e.status.Add(i, e.status.Item(i) + e.updateVal)
            })
        },
        e.AfterChestBasket = function() {
            var i = new e(.5, .2, !0);
            return i.add(t.CardScoreType.Horseshoe.toString(), 1),
            i.add(t.CardScoreType.Bomb.toString(), 1),
            i.add(t.CardScoreType.Lightning.toString(), 1),
            i.add(t.CardScoreType.Skull.toString(), 1),
            i.add(t.CardScoreType.Multiplier.toString(), 1),
            i
        },
        e.prototype.add = function(t, e) {
            this.status.Add(t, e),
            this.initialStatus.Add(t, e)
        },
        e.prototype.print = function(t) {
            this.status.Values().reduce(function(t, e) {
                return t + e
            });
            for (var e = 0,
            i = this.status.Keys(); e < i.length; e++) {
                var o = i[e];
                this.status.Item(o),
                this.initialStatus.Item(o)
            }
            console.groupEnd()
        },
        e
    } ();
    t.Basket = e;
    var i = function() {
        function t() {
            this.items = {},
            this.count = 0
        }
        return t.prototype.ContainsKey = function(t) {
            return this.items.hasOwnProperty(t)
        },
        t.prototype.Count = function() {
            return this.count
        },
        t.prototype.Add = function(t, e) {
            this.items.hasOwnProperty(t) || this.count++,
            this.items[t] = e
        },
        t.prototype.Remove = function(t) {
            var e = this.items[t];
            return delete this.items[t],
            this.count--,
            e
        },
        t.prototype.Item = function(t) {
            return this.items[t]
        },
        t.prototype.Keys = function() {
            var t = [];
            for (var e in this.items) this.items.hasOwnProperty(e) && t.push(e);
            return t
        },
        t.prototype.Values = function() {
            var t = [];
            for (var e in this.items) this.items.hasOwnProperty(e) && t.push(this.items[e]);
            return t
        },
        t
    } ();
    t.KeyedCollection = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(t, i) {
            var o = e.call(this, t, i) || this;
            return o.isOnClickInitiated = !1,
            o.powerUpAmount = 0,
            o.lifeAmount = 0,
            o
        }
        return __extends(i, e),
        i.GetDefault = function(t, e) {
            return new i(t, e)
        },
        i.GetNew = function(e, o, n, s) {
            var a = new i(e, o);
            return a.type = n,
            a.setScore(s),
            t.GameStatus.updateCardCounter(n),
            t.GameStatus.updateMovesAfterSpecialCard(n),
            a
        },
        i.prototype.stepUpdate = function() {
            var e = this.shape.getByName(t.Consts.CardManAnimation);
            if (e instanceof t.Trap) {
                var i = e.changeStatus(),
                o = t.GameStatus.currentHero == t.HeroType.Gun;
                this.lifeAmount = o ? 0 : i ? this.powerUpAmount: 0,
                this.setHealthText()
            }
            this.type == t.CardScoreType.Poison && this.setPowerUp(this.powerUpAmount + 1),
            this.type == t.CardScoreType.Bomb && this.setPowerUp(this.powerUpAmount - 1),
            this.type == t.CardScoreType.Barrel && this.powerUpAmount > 2 && this.setPowerUp(this.powerUpAmount - 1)
        },
        i.prototype.getScore = function() {
            return this.type == t.CardScoreType.Trap ? this.lifeAmount: this.lifeAmount + this.powerUpAmount
        },
        i.prototype.getLife = function() {
            return this.lifeAmount
        },
        i.prototype.getPowerUp = function() {
            return this.powerUpAmount
        },
        i.prototype.multiplyScore = function(t) {
            return this.lifeAmount > 0 ? this.getScaleTween(this.getCardLifeText(), this.increaseLife, t) : this.powerUpAmount > 0 ? this.getScaleTween(this.getPowerUpText(), this.increasePowerUp, t) : null
        },
        i.prototype.increaseLife = function(e, i, o) {
            this.setLife(this.lifeAmount * o),
            this.type === t.CardScoreType.Trap && this.setPowerUp(this.powerUpAmount * o)
        },
        i.prototype.increasePowerUp = function(t, e, i) {
            this.setPowerUp(this.powerUpAmount * i)
        },
        i.prototype.reduceScoreInNSeconds = function(t, e) {
            this.powerUpAmount > 0 && (this.powerUpAmount = this.powerUpAmount - t, setTimeout(this.setPowerUpText.bind(this), e)),
            this.lifeAmount > 0 && (this.lifeAmount = this.lifeAmount - t, setTimeout(this.setHealthText.bind(this), e))
        },
        i.prototype.increaseScoreInNSeconds = function(t, e) {
            this.powerUpAmount > 0 && (this.powerUpAmount = this.powerUpAmount + t, setTimeout(this.increasePowerUpTween.bind(this), e)),
            this.lifeAmount > 0 && (this.lifeAmount = this.lifeAmount + t, setTimeout(this.increaseLifeTween.bind(this), e))
        },
        i.prototype.increasePowerUpTween = function() {
            this.getScaleTween(this.getPowerUpText(), this.setPowerUpText, this.powerUpAmount).start()
        },
        i.prototype.increaseLifeTween = function() {
            this.getScaleTween(this.getCardLifeText(), this.setHealthText, this.lifeAmount).start()
        },
        i.prototype.setScore = function(e) {
            switch (this.type) {
            case t.CardScoreType.Warrior:
                this.initialLife = e,
                this.setLife(e);
                break;
            case t.CardScoreType.Gold:
            case t.CardScoreType.Health:
            case t.CardScoreType.Armor:
            case t.CardScoreType.Poison:
            case t.CardScoreType.Cannon:
            case t.CardScoreType.Lightning:
            case t.CardScoreType.Multiplier:
            case t.CardScoreType.Skull:
            case t.CardScoreType.Barrel:
                this.setPowerUp(e);
                break;
            case t.CardScoreType.Bomb:
                this.setLife(e),
                this.setPowerUp(10);
                break;
            case t.CardScoreType.Trap:
                this.setPowerUp(e),
                this.setLife(e);
                break;
            case t.CardScoreType.Chest:
                break;
            case t.CardScoreType.Horseshoe:
                this.setPowerUp(1)
            }
        },
        i.prototype.setPowerUp = function(t) {
            this.powerUpAmount = t,
            this.setPowerUpText()
        },
        i.prototype.setLife = function(t) {
            this.lifeAmount = t,
            this.setHealthText()
        },
        i.prototype.setHealthText = function() {
            var t = this.getCardLifeText();
            t && t && t.setText(this.lifeAmount.toString())
        },
        i.prototype.setPowerUpText = function() {
            var t = this.getPowerUpText();
            t && t && t.setText(this.powerUpAmount.toString())
        },
        i.prototype.getPowerUpText = function() {
            return this.shape.getByName(t.Consts.PowerUp)
        },
        i.prototype.setOnClickEvent = function(e, i, o) {
            if (!this.isOnClickInitiated) for (var n = 0; n < this.shape.children.length; n++) {
                var s = this.shape.children[n];
                s.name == t.Consts.BackgroundName && (s.inputEnabled = !0, s.events.onInputDown.add(e, o, 1, this), s.events.onInputUp.add(i, o, 1, this), this.isOnClickInitiated = !0)
            }
        },
        i.prototype.isNegative = function() {
            switch (this.type) {
            case t.CardScoreType.Trap:
            case t.CardScoreType.Warrior:
            case t.CardScoreType.Bomb:
            case t.CardScoreType.Poison:
                return ! 0;
            case t.CardScoreType.Health:
            case t.CardScoreType.Gold:
            case t.CardScoreType.Armor:
            case t.CardScoreType.Cannon:
            case t.CardScoreType.Chest:
            case t.CardScoreType.Barrel:
            case t.CardScoreType.Horseshoe:
            case t.CardScoreType.Lightning:
            case t.CardScoreType.Multiplier:
            case t.CardScoreType.Skull:
                return ! 1
            }
        },
        i.prototype.isBoss = function() {
            return this.type == t.CardScoreType.Warrior && this.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss
        },
        i.prototype.getGoldValue = function() {
            return this.initialLife
        },
        i
    } (t.CardBase);
    t.Card = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(e, i) {
            this.healthBasket = new t.Basket,
            this.armorBasket = new t.Basket,
            this.cannonBasket = new t.Basket,
            this.enemyBasket = new t.Basket,
            this.goldBasket = new t.Basket,
            this.chestBasket = t.Basket.AfterChestBasket(),
            this.movesAfterLastSpecialCard = 0,
            this.game = e,
            this.container = i,
            this.cardShapeFactory = new t.CardShapeFactory(e, i)
        }
        return e.prototype.getDefault = function() {
            var e = this.cardShapeFactory.getDefaultShape();
            return t.Card.GetDefault(e, this.game)
        },
        e.prototype.getHero = function() {
            var e = this.cardShapeFactory.getHeroShape(t.GameStatus.currentHero),
            i = new t.Hero(e, this.game);
            return i.setShopItemsStatus(),
            i.totalLife = 10,
            i.currentLife = 10,
            i.armor = 0,
            t.GameStatus.isHorseshoe && (i.totalLife += 1, i.currentLife += 1),
            i.setStatus(),
            this.movesAfterLastSpecialCard++,
            i
        },
        e.prototype.getCard = function(e, i, o) {
            return void 0 === e && (e = t.CardGenerationType.Random),
            t.GameStatus.isNeedCreateBoss && e == t.CardGenerationType.Random ? (t.GameStatus.isNeedCreateBoss = !1, this.getBoss()) : t.GameStatus.isNeedCreateChest && e == t.CardGenerationType.Random ? (t.GameStatus.isNeedCreateChest = !1, this.getChestCard()) : this.generateCardType(e, o) == t.CardBackgroundType.Warrior ? this.getEnemy(i) : this.getPowerUp(e, i, o)
        },
        e.prototype.getHealth = function(e) {
            var i = t.CardScoreType.Health;
            return t.Card.GetNew(this.cardShapeFactory.getPowerUpCardShape(i, e), this.game, i, e)
        },
        e.prototype.generateCardType = function(i, o) {
            if (i == t.CardGenerationType.AfterBarrel && t.GameStatus.currentHero == t.HeroType.Key) return t.CardBackgroundType.PowerUp;
            if (i == t.CardGenerationType.AfterChest || i == t.CardGenerationType.Positive) return t.CardBackgroundType.PowerUp;
            if (i == t.CardGenerationType.AfterBarrel && Math.random() < .75) return t.CardBackgroundType.PowerUp;
            if (t.LogInfo.reset(), t.GameStatus.cardCounter > 2) {
                var n = Math.random();
                if (t.LogInfo.ChanceOfNegativeFromBox = n, n < .8) return t.CardBackgroundType.Warrior
            }
            if (t.GameStatus.cardCounter < -3) {
                var s = Math.random();
                if (t.LogInfo.ChanceOfPositiveFromBox = s, s < .8) return t.CardBackgroundType.PowerUp
            }
            return e.isShouldBePositiveCard(o) ? t.CardBackgroundType.PowerUp: t.CardBackgroundType.Warrior
        },
        e.isShouldBePositiveCard = function(e) {
            var i = e.filter(t.CardScoreTypeHelper.isCardScoreTypePositive).length,
            o = e.filter(t.CardScoreTypeHelper.isCardScoreTypeNegative).length;
            if (!t.GameStatus.isFourXFour && Math.random() < .85 && i <= 1) return Math.random() < .8;
            if (t.GameStatus.isFourXFour && Math.random() < .85 && i <= 2) return Math.random() < .8;
            var n = Math.min(.35, .4 - .01 * t.GameStatus.levelStep),
            s = o * (t.GameStatus.isFourXFour ? .02 : .03),
            a = Phaser.Math.clamp(n + s, .2, .75),
            r = Math.random();
            return t.LogInfo.PositiveCardProbability = a,
            t.LogInfo.CurrentPositiveCardProbability = r,
            r < a
        },
        e.prototype.getPowerUp = function(e, i, o) {
            var n = this.generatePowerUpType(e, o);
            return i = this.generateCardScore(n, i),
            t.Card.GetNew(this.cardShapeFactory.getPowerUpCardShape(n, i), this.game, n, i)
        },
        e.prototype.generateCardScore = function(e, i) {
            if (void 0 === i && (i = 0), 0 == i) switch (e) {
            case t.CardScoreType.Armor:
                this.armorBasket.fillBasketWithStep(1, 4, 3, 10),
                i = Number(this.armorBasket.getFromBasket());
                break;
            case t.CardScoreType.Health:
                this.healthBasket.fillBasketWithStep(1, 4, 3, 10),
                i = Number(this.healthBasket.getFromBasket());
                break;
            case t.CardScoreType.Cannon:
                this.cannonBasket.fillBasketWithStep(1, 1, 3, 10),
                i = Number(this.cannonBasket.getFromBasket()),
                t.GameStatus.currentHero == t.HeroType.Bomb && (i += 2);
                break;
            case t.CardScoreType.Barrel:
                i = this.generateScore(2, 4, 3, 10);
                break;
            case t.CardScoreType.Poison:
                var o = 1 + Math.ceil(t.GameStatus.gameLevel / 2);
                i = o > 10 ? 10 : o;
                break;
            case t.CardScoreType.Lightning:
                i = this.generateScore(1, 4, 3, 10);
                break;
            case t.CardScoreType.Gold:
                this.goldBasket.fillBasketWithStep(1, 4, 2, 1e3),
                i = Number(this.goldBasket.getFromBasket());
                break;
            default:
                i = this.game.rnd.integerInRange(1, 5)
            }
            return e === t.CardScoreType.Bomb && (i = this.game.rnd.integerInRange(1, 4 + Math.ceil(t.GameStatus.gameLevel / 2))) > 10 && (i = 10),
            e === t.CardScoreType.Multiplier && (i = 2),
            i
        },
        e.prototype.generateScore = function(e, i, o, n) {
            var s = i + Math.ceil(t.GameStatus.gameLevel / o),
            a = this.game.rnd.integerInRange(e, s);
            return Phaser.Math.clamp(a, e, n)
        },
        e.prototype.getEnemy = function(e) {
            var i = this.generateEnemyPower(e);
            return t.Consts.IsDev && this.enemyBasket.print("Enemy"),
            0 == e && (e = i, t.GameStatus.gameLevel > 10 && (e += Math.floor((t.GameStatus.gameLevel - 10) / 2))),
            0 == i ? this.getTrap(e + 1) : this.getWarrior(i, e)
        },
        e.prototype.getTrap = function(e) {
            return t.Card.GetNew(this.cardShapeFactory.getTrapCardShape(), this.game, t.CardScoreType.Trap, e)
        },
        e.prototype.getWarrior = function(e, i) {
            return t.Card.GetNew(this.cardShapeFactory.getEnemyCardShape(e), this.game, t.CardScoreType.Warrior, i)
        },
        e.getTrapScore = function() {
            return t.GameStatus.currentHero == t.HeroType.Gun ? 0 : 1 + t.RandomHelper.getRandomIntInclusive(0, Math.ceil(t.GameStatus.gameLevel / 4))
        },
        e.prototype.getBoss = function() {
            var i = this.cardShapeFactory.getBossCardShape(e.generateBossPower()),
            o = 8 + t.GameStatus.gameLevel;
            return t.Card.GetNew(i, this.game, t.CardScoreType.Warrior, o)
        },
        e.prototype.getChestCard = function() {
            var e = t.CardScoreType.Chest,
            i = this.cardShapeFactory.getPowerUpCardShape(e, 0);
            return t.Card.GetNew(i, this.game, e, 0)
        },
        e.prototype.getCoinCard = function(e) {
            var i = t.CardScoreType.Gold;
            0 === e && (e = this.generateCardScore(i));
            var o = this.cardShapeFactory.getPowerUpCardShape(i, e);
            return t.Card.GetNew(o, this.game, i, e)
        },
        e.generateBossPower = function() {
            return t.RandomHelper.getRandomIntInclusive(1, 3)
        },
        e.prototype.generatePowerUpType = function(i, o) {
            return i == t.CardGenerationType.AfterChest ? this.generatePowerUpTypeFromChest() : i == t.CardGenerationType.AfterBarrel ? e.generatePowerUpTypeFromBarrel(o) : e.generatePowerUpCardScoreType(o)
        },
        e.prototype.generatePowerUpTypeFromChest = function() {
            return Number(this.chestBasket.getFromBasket())
        },
        e.generatePowerUpTypeFromBarrel = function(i) {
            return e.generateFromBasket(i, t.CardScoreTypeHelper.getRandomPowerUpFromBarrel, this.maxPowerUpNumber())
        },
        e.generatePowerUpCardScoreType = function(i) {
            return e.generateFromBasket(i, t.CardScoreTypeHelper.getRandomPowerUp, this.maxPowerUpNumber())
        },
        e.generateFromBasket = function(t, e, i) {
            for (var o, n = 0; n < 10 && (o = e(), !(t.filter(function(t) {
                return t === o
            }).length < i)); n++);
            return o
        },
        e.maxPowerUpNumber = function() {
            return t.RandomHelper.getRandomIntInclusive(1, 2)
        },
        e.prototype.generateEnemyPower = function(t) {
            if (this.enemyBasket.fillBasketWithStep(0, 4, 2, 9), 0 == t) return Number(this.enemyBasket.getFromBasket());
            var e = Phaser.Math.clamp(t, 0, 9);
            return this.enemyBasket.removeFromBasket(e.toString()),
            e
        },
        e
    } ();
    t.CardFactory = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e) {
            this.game = t,
            this.container = e
        }
        return e.prototype.getHeroShape = function(e) {
            var i = this.getNewShapeContainer(t.CardBackgroundType.Hero);
            this.addShieldToHero(i),
            this.addLifeToHero(i);
            var o = new t.HeroSprite(this.game, 0, 13, e);
            return o.name = t.Consts.CardManAnimation,
            i.addChild(o),
            i
        },
        e.prototype.getDefaultShape = function() {
            return this.getNewShapeContainer(t.CardBackgroundType.Default)
        },
        e.prototype.getTrapCardShape = function() {
            var e = this.getNewShapeContainer(t.CardBackgroundType.Warrior);
            return this.addTrap(e),
            e
        },
        e.prototype.getEnemyCardShape = function(e) {
            var i = this.getNewShapeContainer(t.CardBackgroundType.Warrior);
            return this.addEnemy(e, i),
            i
        },
        e.prototype.getBossCardShape = function(e) {
            var i = this.getNewShapeContainer(t.CardBackgroundType.Warrior);
            return this.addBoss(i, e),
            i
        },
        e.prototype.getPowerUpCardShape = function(e, i) {
            var o = this.getNewShapeContainer(t.CardBackgroundType.PowerUp);
            switch (e) {
            case t.CardScoreType.Armor:
                this.addShield(o, i);
                break;
            case t.CardScoreType.Barrel:
                this.addBarrel(o);
                break;
            case t.CardScoreType.Bomb:
                this.addBomb(o);
                break;
            case t.CardScoreType.Cannon:
                this.addCannon(o);
                break;
            case t.CardScoreType.Chest:
                this.addChest(o);
                break;
            case t.CardScoreType.Gold:
                this.addGold(o, i);
                break;
            case t.CardScoreType.Health:
                this.addHealth(o, i);
                break;
            case t.CardScoreType.Horseshoe:
                this.addHorseshoe(o);
                break;
            case t.CardScoreType.Lightning:
                this.addLightning(o);
                break;
            case t.CardScoreType.Multiplier:
                this.addMultiplier(o, t.MultiplierScore.X2);
                break;
            case t.CardScoreType.Poison:
                this.addPoison(o);
                break;
            case t.CardScoreType.Skull:
                this.addSkull(o);
                break;
            case t.CardScoreType.Warrior:
            case t.CardScoreType.Trap:
            default:
                throw new Error("Invalid Type")
            }
            return this.addShadow(o),
            e != t.CardScoreType.Chest && e != t.CardScoreType.Horseshoe && e != t.CardScoreType.Multiplier && e != t.CardScoreType.Skull && this.addPowerUp(o),
            o
        },
        e.prototype.getNewShapeContainer = function(t) {
            var e = new Phaser.Group(this.game, this.container);
            return e.x = -500,
            e.y = -500,
            this.addBackground(e, t),
            e
        },
        e.prototype.addShieldToHero = function(e) {
            var i = t.ShapeFactoryHelper.getShape(this.game, t.Consts.CardWidth / 2 - 30, -t.Consts.CardHeight / 2, t.ArtConsts.Items1, t.ArtConsts.Shield);
            i.y += i.height / 3,
            i.scale.set(.9, .9),
            i.name = t.Consts.PowerUpCircle,
            e.addChild(i);
            var o = t.TextHelper.getText(this.game, i.x - 5, i.y + 2, "0", "#ffffff", t.Consts.numbersFontWeight);
            e.addChild(o),
            o.name = t.Consts.PowerUp
        },
        e.prototype.addLifeToHero = function(e) {
            var i = new t.CardLifeCircle(this.game, -t.Consts.CardWidth / 2, -t.Consts.CardHeight / 2 + 2, 1);
            e.addChild(i);
            var o = t.TextHelper.getText(this.game, i.x + i.width / 2, i.y + i.height / 2, "0", "#ffffff", t.Consts.numbersFontWeight);
            e.addChild(o),
            o.name = t.Consts.CardLife
        },
        e.prototype.addBackground = function(e, i) {
            var o = new t.CardBackground(this.game, 0, 0, i);
            o.name = t.Consts.BackgroundName,
            e.addChild(o)
        },
        e.prototype.addLifeToCard = function(e) {
            var i = new t.CardLifeCircle(this.game, -t.Consts.CardWidth / 2 - 1, -t.Consts.CardHeight / 2 + 2, 0);
            e.addChild(i);
            var o = t.TextHelper.getText(this.game, i.x + 29.6, i.y + i.height / 2, "0", "#ffffff", t.Consts.numbersFontWeight);
            e.addChild(o),
            o.name = t.Consts.CardLife
        },
        e.prototype.addBoss = function(e, i) {
            var o = new t.Boss(this.game, 0, 0, i);
            o.name = t.Consts.CardManAnimation,
            this.addLifeToCard(e),
            e.addChild(o)
        },
        e.prototype.addTrap = function(e) {
            var i = new t.Trap(this.game, 0, 0);
            i.name = t.Consts.CardManAnimation,
            e.addChild(i),
            this.addLifeToCard(e)
        },
        e.prototype.addEnemy = function(e, i) {
            var o = 9 === e ? new t.Enemy9(this.game, 0, 0) : new t.Enemy(this.game, 0, 0, e);
            this.addLifeToCard(i),
            i.addChild(o)
        },
        e.prototype.addShield = function(e, i) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing);
            var o = i < 3 ? 0 : i < 5 ? 1 : i < 7 ? 2 : i < 9 ? 3 : 4,
            n = new t.Shield(this.game, 7, -8, o);
            n.name = t.Consts.CardManAnimation,
            e.addChild(n)
        },
        e.prototype.addRings = function(e, i, o) {
            var n = new t.SmallRing(this.game, 0, -11, i),
            s = new t.BigRing(this.game, 0, -11, o);
            e.add(n),
            e.add(s)
        },
        e.prototype.addBarrel = function(e) {
            var i = new t.Barrel(this.game, 0, -40);
            i.name = t.Consts.CardManAnimation,
            e.addChild(i)
        },
        e.prototype.addBomb = function(e) {
            this.addLifeToCard(e),
            e.addChild(new t.Bomb(this.game, 0, 0))
        },
        e.prototype.addCannon = function(e) {
            e.addChild(new t.Cannon(this.game, 0, 0))
        },
        e.prototype.addChest = function(e) {
            var i = new t.Chest(this.game, 0, 0);
            i.name = t.Consts.CardManAnimation,
            e.addChild(i)
        },
        e.prototype.addGold = function(e, i) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing);
            var o = i > t.Consts.CoinMaxValue ? new t.CoinBag(this.game, 0, 0) : new t.Coin(this.game, 0, 0, "", !0);
            o.y = -7,
            o.name = t.Consts.CardManAnimation,
            e.addChild(o)
        },
        e.prototype.addHealth = function(e, i) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing);
            var o = i > 5 ? 2 : 1;
            e.addChild(new t.Health(this.game, 0, -15, o))
        },
        e.prototype.addHorseshoe = function(e) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing),
            e.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.BigHorseshoe))
        },
        e.prototype.addLightning = function(e) {
            e.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.Lightning))
        },
        e.prototype.addMultiplier = function(e, i) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing),
            e.addChild(new t.Multiplier(this.game, 0, -13, i))
        },
        e.prototype.addPoison = function(e) {
            this.addRings(e, t.ArtConsts.SmallRing, t.ArtConsts.BigRing),
            e.addChild(new t.Poison(this.game, 0, 0))
        },
        e.prototype.addSkull = function(e) {
            e.addChild(new t.SkullContainer(this.game, 0, 0))
        },
        e.prototype.addPowerUp = function(e) {
            var i = new t.CardPowerUpCircle(this.game, -t.Consts.CardWidth / 2 + 33, t.Consts.CardHeight / 2 - 33, 0);
            i.name = t.Consts.PowerUpCircle,
            e.addChild(i);
            var o = t.TextHelper.getText(this.game, i.x - 2, i.y + 1, "0", "#ffffff", t.Consts.numbersFontWeight);
            e.addChild(o),
            o.name = t.Consts.PowerUp
        },
        e.prototype.addShadow = function(e) {
            e.add(new t.Shadow(this.game, 0, 2 * t.Consts.CardHeight / 6 - 4))
        },
        e
    } ();
    t.CardShapeFactory = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e, i) {
            this.step = 1,
            this.game = t,
            this.cardFactory = e,
            this.keyboardManager = i
        }
        return e.prototype.initField = function() {
            var e = [],
            i = t.GameStatus.ColumnCount,
            o = t.GameStatus.RowCount,
            n = t.Consts.AnimationTime - (o * i == 9 ? 0 : 50);
            this.field = new t.FieldItems(i, o);
            for (var s = t.RandomHelper.getRandomIntInclusive(1, 5), a = 0; a < o; a++) for (var r = 0; r < i; r++) {
                var h = void 0,
                d = a === t.Consts.HeroStartRow - 1,
                c = r === t.Consts.HeroStartColumn - 1;
                if (d && c)(h = this.cardFactory.getHero()).shape.name = t.Consts.Hero,
                t.GameStatus.isHeroAlive = !0,
                t.GameStatus.isGameEnd = !1;
                else if (t.GameStatus.isTutorialSeen) h = this.getCardFromFactory();
                else if (d && r === t.Consts.HeroStartColumn) {
                    h = this.getEnemyCardFromFactory(s);
                    var u = new t.Arm(this.game, -30, 30);
                    h.shape.name = t.Consts.CardWithArm,
                    h.shape.add(u)
                } else a === t.Consts.HeroStartRow && r === t.Consts.HeroStartColumn ? (h = this.getHealsCardFromFactory(s), this.movingArm = new t.Arm(this.game, -30, -50), this.movingArm.alpha = 0, h.shape.add(this.movingArm), h.shape.name = t.Consts.CardWithMovingArm, this.movingArmY = -200) : h = this.getCardFromFactory();
                var p = new t.FieldPosition(r, a),
                l = this.cardFactory.getDefault();
                e.push(this.moveAndSetWithAnimation(p, l, n)),
                e.push(this.replaceCardByPosition(p, h).setAnimationDuration(1))
            }
            return t.GameStatus.isTutorialSeen || this.addShadow(),
            e
        },
        e.prototype.addShadow = function() {
            var e = this.game.add.graphics(0, 0);
            e.name = t.Consts.Shadow,
            e.alpha = .5,
            e.beginFill(0),
            e.drawRect(2 * -this.game.width, 2 * -this.game.height, 4 * this.game.width, 4 * this.game.height),
            this.cardFactory.container.add(e),
            this.cardFactory.container.bringToTop(this.cardFactory.container.getByName(t.Consts.Hero)),
            this.cardFactory.container.bringToTop(this.cardFactory.container.getByName(t.Consts.CardWithArm))
        },
        e.prototype.runArmTween = function() {
            var e = this.cardFactory.container.getByName(t.Consts.Shadow);
            e && this.cardFactory.container.bringToTop(e),
            this.cardFactory.container.bringToTop(this.cardFactory.container.getByName(t.Consts.Hero)),
            this.cardFactory.container.bringToTop(this.cardFactory.container.getByName(t.Consts.CardWithMovingArm)),
            this.movingArm.alpha = 1,
            this.movingArm.y = this.movingArmY;
            var i = this.movingArmY + 150,
            o = this.game.add.tween(this.movingArm).to({
                y: this.movingArmY
            },
            200).to({
                y: i
            },
            600),
            n = this.game.add.tween(this.movingArm).to({
                y: i
            },
            200);
            o.onStart.add(function() {
                this.movingArm.changeFrame(1)
            },
            this),
            n.onStart.add(function() {
                this.movingArm.changeFrame(0)
            },
            this),
            n.onComplete.add(this.runArmTween, this),
            o.chain(n),
            o.start()
        },
        e.prototype.getChestCardFromFactory = function() {
            var t = this.cardFactory.getChestCard();
            return t.setOnClickEvent(this.onCardDown, this.onCardUp, this),
            t
        },
        e.prototype.getCardFromFactory = function(e, i) {
            void 0 === e && (e = t.CardGenerationType.Random),
            void 0 === i && (i = 0);
            var o = this.cardFactory.getCard(e, i, this.getCardTypesOnTheTable());
            return t.GameStatus.isTutorialSeen && o.setOnClickEvent(this.onCardDown, this.onCardUp, this),
            o
        },
        e.prototype.getEnemyCardFromFactory = function(t) {
            var e = this.cardFactory.getEnemy(t);
            return e.setOnClickEvent(this.onCardDown, this.onCardUp, this),
            e
        },
        e.prototype.getHealsCardFromFactory = function(t) {
            return this.cardFactory.getHealth(t)
        },
        e.prototype.getCardTypesOnTheTable = function() {
            return this.field.getAll().filter(function(e) {
                return e instanceof t.Card
            }).map(function(t) {
                return t.type
            })
        },
        e.prototype.getCoinCardFromFactory = function(t) {
            var e = this.cardFactory.getCoinCard(t);
            return e.setOnClickEvent(this.onCardDown, this.onCardUp, this),
            e
        },
        e.prototype.onCardDown = function(t, e, i, o) {
            this.downPointer = e
        },
        e.prototype.onCardUp = function(e, i, o, n) {
            if (!this.onAnimation) {
                var s = new Phaser.Point(this.downPointer.x, this.downPointer.y),
                a = new Phaser.Point(i.x, i.y);
                if (s.distance(a) > 5) return;
                var r = this.field.getPosition(function(t) {
                    return t === n
                });
                if (!r) return;
                if (this.field.isPositionValid(r.getNewPosition(t.MoveType.Down)) && this.field.get(r.getNewPosition(t.MoveType.Down)) instanceof t.Hero) return void(this.keyboardManager.isUp = !0);
                if (this.field.isPositionValid(r.getNewPosition(t.MoveType.Up)) && this.field.get(r.getNewPosition(t.MoveType.Up)) instanceof t.Hero) return void(this.keyboardManager.isDown = !0);
                if (this.field.isPositionValid(r.getNewPosition(t.MoveType.Left)) && this.field.get(r.getNewPosition(t.MoveType.Left)) instanceof t.Hero) return void(this.keyboardManager.isRight = !0);
                if (this.field.isPositionValid(r.getNewPosition(t.MoveType.Right)) && this.field.get(r.getNewPosition(t.MoveType.Right)) instanceof t.Hero) return void(this.keyboardManager.isLeft = !0);
                n.playNoAccess()
            }
        },
        e.prototype.getHero = function() {
            return this.field.get(this.getHeroPosition())
        },
        e.prototype.getHeroPosition = function() {
            return this.field.getPosition(function(e) {
                return e instanceof t.Hero
            })
        },
        e.prototype.getCardToFight = function(e) {
            var i = this.field.getPosition(function(e) {
                return e instanceof t.Hero
            });
            if (null != i) {
                var o = i.getNewPosition(e);
                if (this.field.isPositionValid(o)) return this.field.get(o)
            }
            return null
        },
        e.prototype.replaceCard = function(e, i, o) {
            void 0 === o && (o = 0);
            var n = this.field.getPosition(function(e) {
                return e instanceof t.Hero
            }),
            s = Array(),
            a = this.getCardFromFactory(i, o);
            return s.push(this.replaceCardByPosition(n.getNewPosition(e), a)),
            t.GameStatus.isTutorialSeen || a.setOnClickEvent(this.onCardDown, this.onCardUp, this),
            s
        },
        e.prototype.tutorialStep1 = function() {
            var e = this;
            this.movingArm.animations.stop(),
            this.runArmTween(),
            t.GameStatus.isTutorialStep1Done = !0,
            this.field.getAll().forEach(function(i) {
                i instanceof t.Card && i.shape.name === t.Consts.CardWithMovingArm && i.setOnClickEvent(e.onCardDown, e.onCardUp, e)
            })
        },
        e.prototype.tutorialStep2 = function(e) {
            t.GameStatus.isTutorialStep2Done = !0,
            this.runAllCardsAroundHero(e)
        },
        e.prototype.tutorialStep3 = function(t) {
            this.runAllCardsAroundHero(t)
        },
        e.prototype.tutorialStep4 = function() {
            var e = this.cardFactory.container.getByName(t.Consts.Shadow);
            this.game.add.tween(e).to({
                alpha: 0
            },
            100).start().onComplete.add(function() {
                var i = this;
                e.destroy(),
                t.GameStatus.isTutorialSeen = !0,
                this.field.getAll().forEach(function(e) {
                    e instanceof t.Card && e.setOnClickEvent(i.onCardDown, i.onCardUp, i)
                })
            }.bind(this))
        },
        e.prototype.runAllCardsAroundHero = function(e) {
            for (var i = 0,
            o = [e.getNewPosition(t.MoveType.Left), e.getNewPosition(t.MoveType.Up), e.getNewPosition(t.MoveType.Right), e.getNewPosition(t.MoveType.Down)]; i < o.length; i++) {
                var n = o[i];
                if (this.field.isPositionValid(n)) {
                    var s = this.field.get(n);
                    this.cardFactory.container.bringToTop(s.shape),
                    s instanceof t.Card && s.setOnClickEvent(this.onCardDown, this.onCardUp, this)
                }
            }
        },
        e.prototype.move = function(e) {
            var i = Array(),
            o = this.getHeroPosition(),
            n = o.getNewPosition(e),
            s = this.field.get(n);
            if (s instanceof t.NullCard) return i;
            this.isPlayMove(s) && setTimeout(this.playMoveSound.bind(this), 115);
            var a, r = this.field.get(o);
            if (s.type === t.CardScoreType.Bomb) i.push(this.moveAndSetWithAnimation(o.getNewPosition(e), r, t.Consts.AnimationTime).setAnimationDuration(1)),
            i.push(this.moveAndSetWithAnimation(o, s, t.Consts.AnimationTime));
            else {
                s.isBoss() && t.GameStatus.gameLevel++;
                var h = this.getCardPositionType(e, o),
                d = this.getCardToReplace(s),
                c = new t.TweenContainer;
                switch ((a = c.tweens).push.apply(a, s.removeChild()), i.push(c), h) {
                case t.CardPositionType.Center:
                    switch (i.push(this.moveAndSetWithAnimation(o.getNewPosition(e), r, t.Consts.AnimationTime)), e) {
                    case t.MoveType.Left:
                        0 === o.row ? i.push.apply(i, this.moveAllLine(t.MoveType.Down, t.MoveType.Up, o.getNewPosition(t.MoveType.Down), d)) : i.push.apply(i, this.moveAllLine(t.MoveType.Up, t.MoveType.Down, o.getNewPosition(t.MoveType.Up), d));
                        break;
                    case t.MoveType.Right:
                        o.row === this.field.getRowCount() - 1 ? i.push.apply(i, this.moveAllLine(t.MoveType.Up, t.MoveType.Down, o.getNewPosition(t.MoveType.Up), d)) : i.push.apply(i, this.moveAllLine(t.MoveType.Down, t.MoveType.Up, o.getNewPosition(t.MoveType.Down), d));
                        break;
                    case t.MoveType.Up:
                        o.column === this.field.getColumnCount() - 1 ? i.push.apply(i, this.moveAllLine(t.MoveType.Left, t.MoveType.Right, o.getNewPosition(t.MoveType.Left), d)) : i.push.apply(i, this.moveAllLine(t.MoveType.Right, t.MoveType.Left, o.getNewPosition(t.MoveType.Right), d));
                        break;
                    case t.MoveType.Down:
                        0 === o.column ? i.push.apply(i, this.moveAllLine(t.MoveType.Right, t.MoveType.Left, o.getNewPosition(t.MoveType.Right), d)) : i.push.apply(i, this.moveAllLine(t.MoveType.Left, t.MoveType.Right, o.getNewPosition(t.MoveType.Left), d))
                    }
                    break;
                case t.CardPositionType.End:
                    i.push.apply(i, this.moveAllLine(this.getOppositeMoveType(e), e, o, d))
                }
            }
            if (!t.GameStatus.isTutorialSeen) {
                var u, p = this.cardFactory.container.getByName(t.Consts.Shadow);
                if (p && this.cardFactory.container.bringToTop(p), this.cardFactory.container.bringToTop(this.cardFactory.container.getByName(t.Consts.Hero)), this.cardFactory.container.bringToTop(s.shape), 1 === this.step)(u = i[i.length - 1]).tweens[u.tweens.length - 1].onComplete.add(function() {
                    this.tutorialStep1()
                }.bind(this));
                if (2 === this.step)(u = i[i.length - 1]).tweens[u.tweens.length - 1].onComplete.add(function() {
                    this.tutorialStep2(n)
                }.bind(this));
                if (3 === this.step)(u = i[i.length - 1]).tweens[u.tweens.length - 1].onComplete.add(function() {
                    this.tutorialStep3(n)
                }.bind(this));
                if (4 === this.step)(u = i[i.length - 1]).tweens[u.tweens.length - 1].onComplete.add(function() {
                    this.tutorialStep4()
                }.bind(this));
                this.step++
            }
            return i
        },
        e.prototype.isPlayMove = function(e) {
            switch (e.type) {
            case t.CardScoreType.Warrior:
                return ! 1;
            case t.CardScoreType.Trap:
                return ! e.shape.getByName(t.Consts.CardManAnimation).isOpen;
            case t.CardScoreType.Health:
            case t.CardScoreType.Gold:
            case t.CardScoreType.Armor:
            case t.CardScoreType.Cannon:
            case t.CardScoreType.Barrel:
            case t.CardScoreType.Chest:
            case t.CardScoreType.Bomb:
            case t.CardScoreType.Poison:
            case t.CardScoreType.Horseshoe:
            case t.CardScoreType.Lightning:
            case t.CardScoreType.Multiplier:
            case t.CardScoreType.Skull:
                return ! 0
            }
        },
        e.prototype.playMoveSound = function() {
            t.SoundController.instance.playSound(Phaser.ArrayUtils.getRandomItem([t.SoundConsts.Move01, t.SoundConsts.Move02]))
        },
        e.prototype.getCardToReplace = function(e) {
            return e.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss ? this.getChestCardFromFactory() : this.getCardFromFactory()
        },
        e.prototype.getCardToReplaceAfterSmash = function(e) {
            e.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss && (t.GameStatus.isNeedCreateChestOnNextStep = !0);
            var i = e.getGoldValue() > 0 ? e.getGoldValue() : e.getScore();
            return this.getCoinCardFromFactory(i)
        },
        e.prototype.getCardPositionType = function(e, i) {
            switch (e) {
            case t.MoveType.Right:
                return i.column == this.field.getColumnCount() - 1 ? t.CardPositionType.Start: 0 == i.column ? t.CardPositionType.Center: t.CardPositionType.End;
            case t.MoveType.Down:
                return i.row == this.field.getRowCount() - 1 ? t.CardPositionType.Start: 0 == i.row ? t.CardPositionType.Center: t.CardPositionType.End;
            case t.MoveType.Left:
                return 0 == i.column ? t.CardPositionType.Start: i.column == this.field.getColumnCount() - 1 ? t.CardPositionType.Center: t.CardPositionType.End;
            case t.MoveType.Up:
                return 0 == i.row ? t.CardPositionType.Start: i.row == this.field.getRowCount() - 1 ? t.CardPositionType.Center: t.CardPositionType.End
            }
        },
        e.prototype.removeAllChild = function() {
            var e = [];
            t.SoundController.instance.playSound(t.SoundConsts.HeroDies);
            for (var i, o = this.field.getAll(), n = 0, s = o = t.RandomHelper.shuffle(o); n < s.length; n++) {
                var a = s[n],
                r = new t.TweenContainer;
                r.animationDuration = t.RandomHelper.getRandomIntInclusive(50, 150),
                (i = r.tweens).push.apply(i, a.removeChild()),
                e.push(r)
            }
            return e
        },
        e.prototype.isBossInTheField = function() {
            return this.field.any(function(e) {
                return ! (e instanceof t.NullCard) && e.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss
            })
        },
        e.prototype.moveAllLine = function(e, i, o, n) {
            for (var s = [], a = t.Consts.AnimationTime * t.Consts.AnimationMultiplier; this.field.isPositionValid(o);) s.push(this.moveAndSetWithAnimation(o.getNewPosition(i), this.field.get(o), t.Consts.AnimationTime).setAnimationDuration(a)),
            o = o.getNewPosition(e);
            var r = this.cardFactory.getDefault(),
            h = o.getNewPosition(i);
            return s.push(this.moveAndSetWithAnimation(h, r, t.Consts.AnimationTime)),
            s.push(this.replaceCardByPosition(h, n).setAnimationDuration(1)),
            s
        },
        e.prototype.stepUpdate = function() {
            for (var e = 0,
            i = this.field.getAll(); e < i.length; e++) {
                var o = i[e];
                o.shape.getByName(t.Consts.CardManAnimation) instanceof t.Boss && this.cardFactory.container.bringToTop(o.shape),
                o.stepUpdate()
            }
        },
        e.prototype.shootCannon = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Cannon);
            var e = this.getHeroPosition(),
            i = this.field.get(e),
            o = [];
            return o.push.apply(o, this.shootCannonInDirection(t.MoveType.Right, i, e)),
            o.push.apply(o, this.shootCannonInDirection(t.MoveType.Left, i, e)),
            o.push.apply(o, this.shootCannonInDirection(t.MoveType.Up, i, e)),
            o.push.apply(o, this.shootCannonInDirection(t.MoveType.Down, i, e)),
            o
        },
        e.prototype.shootCannonInDirection = function(moveType, heroCard, heroPosition) {
            var list = [],
            position = heroPosition.getNewPosition(moveType);
            if (!this.field.isPositionValid(position)) return list;
            var itemCard = this.field.get(position);
            if (t.Field.canShootCard(itemCard)) 
            {
                if (
                    list.push(this.shootCard(heroCard.getCenterX(), heroCard.getCenterY(), itemCard.getCenterX(), itemCard.getCenterY(), 200)), 
                    itemCard.type === t.CardScoreType.Cannon) 
                        itemCard.increaseScoreInNSeconds(heroCard.shootScore, 400);
                else if (heroCard.shootScore >= itemCard.getScore()) {
                    var r = this.getCardToReplaceAfterSmash(itemCard),
                    h = this.replaceCardByPosition(position, r, !0).setAnimationDuration(1);
                    h.tweens[0].delay(400),
                    list.push(h)
                } else itemCard.reduceScoreInNSeconds(heroCard.shootScore, 400)
            }
            return list
        },
        e.prototype.shootCard = function(e, i, o, n, s) {
            var a = t.ShapeFactoryHelper.getShape(this.game, e, i, t.ArtConsts.Items1, t.ArtConsts.Core);
            this.cardFactory.container.add(a);
            var r = this.game.add.tween(a).to({
                x: o,
                y: n
            },
            s);
            r.onUpdateCallback(this.onCoreFlyingUpdate, this),
            r.onComplete.add(this.onCoreFlyingComplete, this);
            var h = new t.TweenContainer;
            return h.animationDuration = 1,
            h.tweens.push(r),
            h
        },
        e.prototype.onCoreFlyingUpdate = function(e) {
            var i = new t.CannonFlyingSmoke(this.game, e.target.x, e.target.y);
            this.cardFactory.container.add(i)
        },
        e.prototype.onCoreFlyingComplete = function(t) {
            this.addBombExplosionAnimation(t.x, t.y, 0),
            t.kill()
        },
        e.canShootCard = function(e) {
            if (e instanceof t.NullCard) return ! 1;
            if (! (e instanceof t.Card)) return ! 0;
            switch (e.type) {
            case t.CardScoreType.Warrior:
            case t.CardScoreType.Trap:
            case t.CardScoreType.Armor:
            case t.CardScoreType.Health:
            case t.CardScoreType.Poison:
            case t.CardScoreType.Cannon:
                return ! 0;
            default:
                return ! 1
            }
        },
        e.prototype.smashBomb = function() {
            for (var e = [], i = 0, o = this.field.getPositions(function(e) {
                var i = e;
                return i && i.type === t.CardScoreType.Bomb && i.getPowerUp() <= 0
            }); i < o.length; i++) {
                var n = o[i];
                t.SoundController.instance.playSound(t.SoundConsts.Bomb);
                var s = this.field.get(n);
                this.addBombExplosionAnimation(s.shape.x, s.shape.y, 100);
                var a = this.getCardToReplaceAfterSmash(this.field.get(n)),
                r = this.replaceCardByPosition(n, a, !0);
                e.push(r);
                for (var h = s.getLife(), d = 0, c = [t.MoveType.Up, t.MoveType.Down, t.MoveType.Left, t.MoveType.Right]; d < c.length; d++) {
                    var u = c[d];
                    if (e.push.apply(e, this.smashBombInDirection(u, n, h)), !t.GameStatus.isHeroAlive) return e
                }
            }
            return e
        },
        e.prototype.smashBombInDirection = function(e, i, o) {
            var n = [],
            s = t.Consts.SmashDelay;
            for (i = i.getNewPosition(e); this.field.isPositionValid(i);) {
                if (n.push.apply(n, this.smashBombInPosition(i, s, o)), !t.GameStatus.isHeroAlive) return n;
                s += t.Consts.SmashDelay,
                i = i.getNewPosition(e)
            }
            return n
        },
        e.prototype.smashBombInPosition = function(e, i, o) {
            var n = this.field.get(e),
            s = 4 == t.GameStatus.RowCount ? 1e3: 500;
            if (this.game.camera.shake(t.Consts.ShakeIntensity, s), this.addBombExplosionAnimation(n.shape.x, n.shape.y, i), n.type == t.CardScoreType.Chest) return [];
            if (n instanceof t.Hero && t.GameStatus.currentHero == t.HeroType.Bomb) return [];
            if (o >= n.getScore()) {
                if (! (n instanceof t.Hero)) {
                    var a = this.getCardToReplaceAfterSmash(n);
                    return [this.replaceCardByPosition(e, a, !0).setAnimationDuration(1)]
                }
                if (!t.GameStatus.isHeart) return t.GameStatus.isHeroAlive = !1,
                this.removeAllChild();
                t.GameStatus.isHeart = !1,
                this.keyboardManager.reset(),
                n.useHeart()
            } else n.reduceScoreInNSeconds(o, 1.2 * i);
            return []
        },
        e.prototype.addBombExplosionAnimation = function(t, e, i) {
            setTimeout(this.playBombExplosionAnimation.bind(this, t, e), i)
        },
        e.prototype.playBombExplosionAnimation = function(e, i) {
            var o = new t.Boom(this.game, e, i);
            o.play(t.AnimationConsts.Action, 60, !1, !0),
            this.cardFactory.container.add(o)
        },
        e.prototype.replaceCardByPosition = function(e, i, o) {
            void 0 === o && (o = !1);
            var n, s, a = new t.TweenContainer,
            r = this.field.get(e),
            h = r.shape.getByName(t.Consts.CardManAnimation);
            return a.tweens.push(),
            o || (h instanceof t.Chest && (n = a.tweens).push.apply(n, h.open()), h instanceof t.Barrel && (this.cardFactory.container.bringToTop(r.shape), (s = a.tweens).push.apply(s, h.open()))),
            r.isBoss() && t.GameStatus.gameLevel++,
            this.moveAndSet(e, i),
            i.endTurnAnimationStart(),
            a.tweens.push(r.startTurnAnimation(i.endTurnAnimationEnd.bind(i))),
            a
        },
        e.prototype.moveAndSet = function(t, e) {
            this.field.set(t, e),
            e.setCoordinate(t.getPoint())
        },
        e.prototype.moveAndSetWithAnimation = function(e, i, o) {
            var n = e.getPoint();
            this.field.set(e, i);
            var s = new t.TweenContainer;
            return s.tweens.push(i.moveTo(n, o)),
            s
        },
        e.prototype.getOppositeMoveType = function(e) {
            switch (e) {
            case t.MoveType.Up:
                return t.MoveType.Down;
            case t.MoveType.Down:
                return t.MoveType.Up;
            case t.MoveType.Left:
                return t.MoveType.Right;
            case t.MoveType.Right:
                return t.MoveType.Left
            }
        },
        e.prototype.shootLightning = function() {
            var e = this.getHeroPosition(),
            i = this.field.get(e),
            o = [];
            return o.push.apply(o, this.shootLightningInAllDirections(i.lightningScore, e, t.Consts.LightningDuration)),
            this.clearLightning(),
            o.length > 0 && t.SoundController.instance.playSound(t.SoundConsts.Lighting),
            o
        },
        e.prototype.clearLightning = function() {
            this.field.getAll().forEach(function(t) {
                t.canLightningStrike = !1
            })
        },
        e.prototype.shootLightningInAllDirections = function(e, i, o) {
            var n = [];
            return n.push.apply(n, this.shootLightningInDirection(t.MoveType.Right, e, i, o)),
            n.push.apply(n, this.shootLightningInDirection(t.MoveType.Left, e, i, o)),
            n.push.apply(n, this.shootLightningInDirection(t.MoveType.Up, e, i, o)),
            n.push.apply(n, this.shootLightningInDirection(t.MoveType.Down, e, i, o)),
            n
        },
        e.prototype.shootLightningInDirection = function(i, o, n, s) {
            var a = [],
            r = n.getNewPosition(i);
            if (!this.field.isPositionValid(r)) return a;
            var h, d = this.field.get(r);
            if (d instanceof t.Hero) return a;
            if (d.canLightningStrike) return a;
            if (e.canShootLightning(d)) {
                var c = s + t.Consts.LightningDuration,
                u = new t.TweenContainer;
                if ((h = u.tweens).push.apply(h, d.runLightning()), u.setAnimationDuration(t.Consts.LightningDuration), a.push(u), o >= d.getScore()) {
                    var p = this.getCardToReplaceAfterSmash(d);
                    p.canLightningStrike = !0;
                    var l = this.replaceCardByPosition(r, p, !0).setAnimationDuration(1);
                    l.tweens[0].delay(2 * c),
                    a.push(l)
                } else d.reduceScoreInNSeconds(o, 2 * c);
                d.canLightningStrike = !0,
                a.push.apply(a, this.shootLightningInAllDirections(o, r, c))
            }
            return a
        },
        e.canShootLightning = function(e) {
            if (e instanceof t.NullCard) return ! 1;
            if (! (e instanceof t.Card)) return ! 0;
            switch (e.type) {
            case t.CardScoreType.Warrior:
            case t.CardScoreType.Trap:
                return ! 0;
            default:
                return ! 1
            }
        },
        e.prototype.shootMultiplier = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Idol);
            var e = this.getHeroPosition(),
            i = this.field.get(e),
            o = [];
            return o.push.apply(o, this.shootMultiplierInDirection(t.MoveType.Right, i.multiplierScore, e)),
            o.push.apply(o, this.shootMultiplierInDirection(t.MoveType.Left, i.multiplierScore, e)),
            o.push.apply(o, this.shootMultiplierInDirection(t.MoveType.Up, i.multiplierScore, e)),
            o.push.apply(o, this.shootMultiplierInDirection(t.MoveType.Down, i.multiplierScore, e)),
            o
        },
        e.prototype.shootSkull = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Skull);
            for (var e = this.getHeroPosition().getPoint(), i = [], o = 0, n = this.field.getPositions(function(e) {
                return ! (e instanceof t.Hero)
            }); o < n.length; o++) {
                var s = n[o],
                a = s.getPoint();
                i.push(this.shootSkullInCoordinate(e.x, e.y, a.x, a.y, 300));
                var r = this.getCardToReplaceAfterSmash(this.field.get(s)),
                h = this.replaceCardByPosition(s, r, !0).setAnimationDuration(1);
                h.tweens[0].delay(350),
                i.push(h)
            }
            return i
        },
        e.prototype.shootSkullInCoordinate = function(e, i, o, n, s) {
            var a = new t.Skull(this.game, e, i);
            a.animations.play(t.AnimationConsts.Action),
            a.anchor.set(0, 0),
            a.rotation = Phaser.Point.angle(new Phaser.Point(o, n), new Phaser.Point(e, i)),
            this.cardFactory.container.add(a);
            var r = this.game.add.tween(a).to({
                x: o,
                y: n
            },
            s);
            r.onUpdateCallback(this.onSkullFlyingUpdate, this),
            r.onComplete.add(this.onSkullFlyingComplete, this);
            var h = new t.TweenContainer;
            return h.animationDuration = 1,
            h.tweens.push(r),
            h
        },
        e.prototype.onSkullFlyingUpdate = function(e) {
            var i = new t.SkullLight(this.game, e.target.x, e.target.y);
            this.cardFactory.container.addChild(i),
            e.target.bringToTop()
        },
        e.prototype.onSkullFlyingComplete = function(t) {
            this.addBombExplosionAnimation(t.x, t.y, 0),
            t.kill()
        },
        e.prototype.shootMultiplierInDirection = function(i, o, n) {
            var s = [],
            a = n.getNewPosition(i);
            if (!this.field.isPositionValid(a)) return s;
            var r = this.field.get(a);
            if (e.canMultiply(r.type, r.getScore())) {
                var h = r.multiplyScore(o);
                if (!h) return s;
                var d = (new t.TweenContainer).setAnimationDuration(1);
                return d.tweens.push(h),
                s.push(d),
                s
            }
        },
        e.canMultiply = function(e, i) {
            switch (e) {
            case t.CardScoreType.Armor:
            case t.CardScoreType.Bomb:
            case t.CardScoreType.Cannon:
            case t.CardScoreType.Gold:
            case t.CardScoreType.Health:
            case t.CardScoreType.Lightning:
            case t.CardScoreType.Poison:
            case t.CardScoreType.Warrior:
            case t.CardScoreType.Barrel:
                return ! 0;
            case t.CardScoreType.Trap:
                return i > 0;
            case t.CardScoreType.Multiplier:
            case t.CardScoreType.Horseshoe:
            case t.CardScoreType.Chest:
            case t.CardScoreType.Skull:
                return ! 1
            }
        },
        e.prototype.stopAllAnimations = function() {
            for (var e = 0,
            i = this.field.getAll(); e < i.length; e++) {
                i[e].shape.children.filter(function(e) {
                    return e instanceof t.SpriteAnimationBase
                }).forEach(function(t) {
                    t.stopAnimation()
                })
            }
        },
        e.prototype.playAllAnimations = function() {
            for (var e = 0,
            i = this.field.getAll(); e < i.length; e++) {
                i[e].shape.children.filter(function(e) {
                    return e instanceof t.SpriteAnimationBase
                }).forEach(function(t) {
                    t.playAnimation()
                })
            }
        },
        e.prototype.replaceAllNegativeCards = function() {
            for (var e = [], i = 0, o = this.field.getPositions(function(e) {
                return ! (e instanceof t.Hero)
            }); i < o.length; i++) {
                var n = o[i];
                if (this.field.get(n).isNegative()) {
                    var s = this.getCardFromFactory(t.CardGenerationType.Positive),
                    a = this.replaceCardByPosition(n, s, !0).setAnimationDuration(1);
                    a.tweens[0].delay(200),
                    e.push(a)
                }
            }
            return e
        },
        e.prototype.smashHero = function(t) {
            var e = this.getHero();
            this.addBombExplosionAnimation(e.shape.x, e.shape.y, t)
        },
        e
    } ();
    t.Field = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e) {
            this.items = Array(),
            this.columnCount = t,
            this.rowCount = e,
            this.initArray()
        }
        return e.prototype.initArray = function() {
            this.items = [];
            for (var e = 0; e < this.rowCount; e++) {
                for (var i = [], o = 0; o < this.columnCount; o++) i.push(new t.NullCard(null));
                this.items.push(i)
            }
        },
        e.prototype.getColumnCount = function() {
            return this.columnCount
        },
        e.prototype.getRowCount = function() {
            return this.rowCount
        },
        e.prototype.getAll = function() {
            for (var t = [], e = 0; e < this.rowCount; e++) for (var i = 0; i < this.columnCount; i++) t.push(this.items[i][e]);
            return t
        },
        e.prototype.getPosition = function(e) {
            for (var i = 0; i < this.rowCount; i++) for (var o = 0; o < this.columnCount; o++) {
                var n = new t.FieldPosition(o, i);
                if (e(this.get(n))) return n
            }
            return null
        },
        e.prototype.getPositions = function(e) {
            for (var i = [], o = 0; o < this.rowCount; o++) for (var n = 0; n < this.columnCount; n++) {
                var s = new t.FieldPosition(n, o);
                e(this.get(s)) && i.push(s)
            }
            return i
        },
        e.prototype.get = function(t) {
            return this.items[t.column][t.row]
        },
        e.prototype.set = function(t, e) {
            this.items[t.column][t.row] = e
        },
        e.prototype.any = function(e) {
            for (var i = 0; i < this.rowCount; i++) for (var o = 0; o < this.columnCount; o++) {
                var n = new t.FieldPosition(o, i);
                if (e(this.get(n))) return ! 0
            }
            return ! 1
        },
        e.prototype.isPositionValid = function(t) {
            return t.column >= 0 && t.column < this.columnCount && t.row >= 0 && t.row < this.rowCount
        },
        e
    } ();
    t.FieldItems = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t, e) {
            this.column = t,
            this.row = e
        }
        return e.prototype.getNewPosition = function(i) {
            var o = new e(this.column, this.row);
            switch (i) {
            case t.MoveType.Right:
                o.column++;
                break;
            case t.MoveType.Down:
                o.row++;
                break;
            case t.MoveType.Left:
                o.column--;
                break;
            case t.MoveType.Up:
                o.row--
            }
            return o
        },
        e.prototype.getPoint = function() {
            var e = this.column * t.Consts.CardWidth + t.Consts.CardWidth / 2 + this.column * t.Consts.CardSpaceBetweenWidth,
            i = this.row * t.Consts.CardHeight + t.Consts.CardHeight / 2 + this.row * t.Consts.CardSpaceBetweenHeight;
            return new t.Point(e, i)
        },
        e
    } ();
    t.FieldPosition = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        return function(t, e, i) {
            this.isHeroAlive = t,
            this.isChest = e,
            this.isMove = i
        }
    } ();
    t.FightResult = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        return function() {
            this.gold = 0,
            this.bestGoldPerGame = 0,
            this.isTutorialSeen = !1,
            this.isTutorialStep1Done = !1,
            this.isTutorialStep2Done = !1,
            this.isTutorialChestSeen = !1,
            this.isBombHero = !1,
            this.isKeyHero = !1,
            this.isGunHero = !1,
            this.isFourXFour = !1,
            this.isHorseshoe = !1,
            this.isHeart = !1,
            this.isLuck = !1,
            this.isKey = !1,
            this.lastAdvCoolDown = null,
            this.lastItemWithAdv = 0,
            this.lastResultAdvCoolDown = 0
        }
    } ();
    t.LocalStorageData = e;
    var i = function() {
        function i() {}
        return Object.defineProperty(i, "gold", {
            get: function() {
                return i.data.gold
            },
            set: function(t) {
                i.data.gold = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "bestGoldPerGame", {
            get: function() {
                return i.data.bestGoldPerGame
            },
            set: function(t) {
                i.data.bestGoldPerGame = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isTutorialSeen", {
            get: function() {
                return i.data.isTutorialSeen
            },
            set: function(e) {
                i.data.isTutorialSeen = e,
                i.save(),
                0 == t.Consts.IsAndroid && window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_TUTORIALCOMPLETED)
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isTutorialStep1Done", {
            get: function() {
                return i.data.isTutorialStep1Done
            },
            set: function(t) {
                i.data.isTutorialStep1Done = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isTutorialStep2Done", {
            get: function() {
                return i.data.isTutorialStep2Done
            },
            set: function(t) {
                i.data.isTutorialStep2Done = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isTutorialChestSeen", {
            get: function() {
                return i.data.isTutorialChestSeen
            },
            set: function(t) {
                i.data.isTutorialChestSeen = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isBombHero", {
            get: function() {
                return i.data.isBombHero
            },
            set: function(t) {
                i.data.isBombHero = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isKeyHero", {
            get: function() {
                return i.data.isKeyHero
            },
            set: function(t) {
                i.data.isKeyHero = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isGunHero", {
            get: function() {
                return i.data.isGunHero
            },
            set: function(t) {
                i.data.isGunHero = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isFourXFour", {
            get: function() {
                return i.data.isFourXFour
            },
            set: function(t) {
                i.data.isFourXFour = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isHorseshoe", {
            get: function() {
                return i.data.isHorseshoe
            },
            set: function(t) {
                i.data.isHorseshoe = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isHeart", {
            get: function() {
                return i.data.isHeart
            },
            set: function(t) {
                i.data.isHeart = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isLuck", {
            get: function() {
                return i.data.isLuck
            },
            set: function(t) {
                i.data.isLuck = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "isKey", {
            get: function() {
                return i.data.isKey
            },
            set: function(t) {
                i.data.isKey = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "lastAdvCoolDown", {
            get: function() {
                return i.data.lastAdvCoolDown
            },
            set: function(t) {
                i.data.lastAdvCoolDown = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "lastResultAdvCoolDown", {
            get: function() {
                return i.data.lastResultAdvCoolDown
            },
            set: function(t) {
                i.data.lastResultAdvCoolDown = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        Object.defineProperty(i, "lastItemWithAdv", {
            get: function() {
                return i.data.lastItemWithAdv
            },
            set: function(t) {
                i.data.lastItemWithAdv = t,
                i.save()
            },
            enumerable: !0,
            configurable: !0
        }),
        i.addGold = function(t) {
            i.goldPerGame += t,
            i.bestGoldPerGame < i.goldPerGame && (i.bestGoldPerGame = i.goldPerGame)
        },
        i.init = function() {
            i.gameLevel = 1,
            i.levelStep = 10,
            i.turnsToBoss = i.levelStep,
            i.goldPerGame = 0,
            i.movesAfterLastSpecialCard = 0,
            i.cardCounter = 0,
            i.isNeedCreateBoss = !1,
            i.currentHero == t.HeroType.Key && (i.isKey = !0)
        },
        i.resetShop = function() {
            i.isHeart = !1,
            i.isHorseshoe = !1,
            i.isLuck = !1,
            i.isKey = !1
        },
        i.updateMovesAfterSpecialCard = function(e) {
            e == t.CardScoreType.Health || e == t.CardScoreType.Armor ? i.movesAfterLastSpecialCard = 0 : i.movesAfterLastSpecialCard++
        },
        i.updateCardCounter = function(e) {
            t.CardScoreTypeHelper.isCardScoreTypeNegative(e) && i.cardCounter--,
            t.CardScoreTypeHelper.isCardScoreTypePositive(e) && i.cardCounter++
        },
        i.stepUpdate = function() {
            i.isBossShouldBeCreated() && (i.isNeedCreateBoss = !0, i.levelStep++, i.turnsToBoss = i.levelStep + 1),
            i.isNeedCreateChestOnNextStep && (i.isNeedCreateChestOnNextStep = !1, i.isNeedCreateChest = !0)
        },
        i.isBossShouldBeCreated = function() {
            return ! i.isNeedCreateBoss && 1 == i.turnsToBoss
        },
        i.decreaseTurnsToBoss = function() {
            i.turnsToBoss > 0 && i.turnsToBoss--
        },
        i.save = function() {
            t.Consts.IsAndroid ? localStorage.setItem(t.Consts.StorageName, JSON.stringify(i.data)) : window.famobi.localStorage.setItem(t.Consts.StorageName, JSON.stringify(i.data))
        },
        i.load = function() {
            return t.Consts.IsAndroid ? JSON.parse(localStorage.getItem(t.Consts.StorageName)) || new e: (window.famobi = window.famobi || {},
            window.famobi.localStorage = window.famobi.localStorage || window.localStorage, JSON.parse(window.famobi.localStorage.getItem(t.Consts.StorageName)) || new e)
        },
        i.data = i.load(),
        i.levelStep = 10,
        i.RowCount = 3,
        i.ColumnCount = 3,
        i
    } ();
    t.GameStatus = i
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i(t, i) {
            return e.call(this, t, i) || this
        }
        return __extends(i, e),
        i.prototype.fight = function(e) {
            var i = new t.FightResult(!0, !1, !0);
            switch (e.type) {
            case t.CardScoreType.Trap:
                e.getLife() > 0 && t.GameStatus.currentHero != t.HeroType.Gun && (t.SoundController.instance.playSound(t.SoundConsts.Trap), this.currentLife > e.getScore() ? (this.currentLife -= e.getScore(), t.GameStatus.addGold(e.getScore()), i.isHeroAlive = !0) : i.isHeroAlive = !1);
                break;
            case t.CardScoreType.Warrior:
                t.SoundController.instance.playSound(Phaser.ArrayUtils.getRandomItem([t.SoundConsts.Hit1, t.SoundConsts.Hit2])),
                i.isHeroAlive = this.fightWithEnemy(e),
                i.isHeroAlive && e.isBoss() && (i.isNeedIncreaseLifeByOneAfterBoss = !0);
                break;
            case t.CardScoreType.Armor:
                e.getScore(),
                t.SoundController.instance.playSound(t.SoundConsts.ShieldWood),
                t.GameStatus.currentHero == t.HeroType.Gun ? this.needSmashLightning(e.getScore()) : this.armor < e.getScore() ? (this.armor = e.getScore(), this.setArmorFrame(e)) : t.GameStatus.currentHero == t.HeroType.Base && this.armor++;
                break;
            case t.CardScoreType.Gold:
                e.shape.getByName(t.Consts.CardManAnimation) instanceof t.Coin ? t.SoundController.instance.playSound(t.SoundConsts.Coin) : t.SoundController.instance.playSound(t.SoundConsts.CoinsBag),
                t.GameStatus.addGold(e.getScore());
                break;
            case t.CardScoreType.Health:
                t.SoundController.instance.playSound(Phaser.ArrayUtils.getRandomItem([t.SoundConsts.Health1, t.SoundConsts.Health2])),
                this.currentLife += e.getScore(),
                this.currentLife > this.totalLife && (this.currentLife = this.totalLife);
                break;
            case t.CardScoreType.Cannon:
                this.needShoot = !0,
                this.shootScore = e.getScore();
                break;
            case t.CardScoreType.Chest:
                i.isChest = !0;
                break;
            case t.CardScoreType.Poison:
                if (t.SoundController.instance.playSound(t.SoundConsts.Poison), t.GameStatus.isLuck) return i.isHeroAlive = !0,
                this.useLuck(),
                i;
                if (e.getScore() >= this.currentLife) return i.isHeroAlive = !1,
                i;
                this.currentLife -= e.getScore();
                break;
            case t.CardScoreType.Horseshoe:
                i.isNeedIncreaseLifeByOne = !0;
                break;
            case t.CardScoreType.Bomb:
                break;
            case t.CardScoreType.Lightning:
                this.needSmashLightning(e.getScore());
                break;
            case t.CardScoreType.Multiplier:
                this.needShootMultiplier = !0,
                this.multiplierScore = e.getScore();
                break;
            case t.CardScoreType.Skull:
                this.needShootSkull = !0;
                break;
            case t.CardScoreType.Barrel:
                t.SoundController.instance.playSound(Phaser.ArrayUtils.getRandomItem([t.SoundConsts.Barrel1, t.SoundConsts.Barrel2])),
                i.isMove = !1
            }
            return this.setStatus(),
            i
        },
        i.prototype.needSmashLightning = function(t) {
            this.needRunLightning = !0,
            this.lightningScore = t
        },
        i.prototype.setStatus = function() {
            this.setLife(),
            this.setArmor()
        },
        i.prototype.stepUpdate = function() {},
        i.prototype.getScore = function() {
            return this.currentLife + this.armor
        },
        i.prototype.reduceScoreInNSeconds = function(t, e) {
            if (t <= this.armor) this.armor -= t;
            else {
                var i = t - this.armor;
                this.armor = 0,
                this.currentLife -= i
            }
            setTimeout(this.setStatus.bind(this), e)
        },
        i.prototype.increaseScoreInNSeconds = function(t, e) {
            this.totalLife - this.currentLife > t ? this.currentLife = this.totalLife: this.currentLife += t,
            setTimeout(this.setStatus.bind(this), e)
        },
        i.prototype.setShopItemsStatus = function() {
            var e = 1;
            this.destroySpriteByName(t.ArtConsts.SmallHeart),
            this.destroySpriteByName(t.ArtConsts.SmallHorseshoe),
            this.destroySpriteByName(t.ArtConsts.SmallLuck),
            this.destroySpriteByName(t.ArtConsts.SmallKey),
            t.GameStatus.isHeart && this.addSpriteByName(t.ArtConsts.SmallHeart, e++, 0, 1),
            t.GameStatus.isHorseshoe,
            t.GameStatus.isLuck && this.addSpriteByName(t.ArtConsts.SmallLuck, e++, 30),
            t.GameStatus.isKey && this.addSpriteByName(t.ArtConsts.SmallKey, e, 30)
        },
        i.prototype.addSpriteByName = function(e, i, o, n) {
            void 0 === o && (o = 0),
            void 0 === n && (n = 1);
            var s = 38 * i - .5 * t.Consts.CardWidth,
            a = t.ShapeFactoryHelper.getShape(this.game, s, 80, t.ArtConsts.Items1, e, 0);
            a.name = e,
            a.angle = o,
            a.scale.set(n),
            this.shape.add(a)
        },
        i.prototype.destroySpriteByName = function(t) {
            var e = this.shape.getByName(t);
            e && e.destroy()
        },
        i.prototype.setLife = function() {
            this.getCardLifeText().setText(this.currentLife + "/" + this.totalLife)
        },
        i.prototype.setArmor = function() {
            var e = this.shape.getByName(t.Consts.PowerUpCircle);
            e.visible && 0 == this.armor ? this.hideSprite(e) : e.visible = !0;
            var i = this.shape.getByName(t.Consts.PowerUp);
            i.setText(this.armor.toString()),
            0 == this.armor && i.setText("")
        },
        i.prototype.hideSprite = function(t) {
            this.game.add.tween(t).to({
                width: 0,
                height: 0,
                angle: 360,
                alpha: 0
            },
            700, null, !0).onComplete.add(function() {
                t.visible = !1,
                t.rotation = 0,
                t.alpha = 1
            })
        },
        i.prototype.setArmorFrame = function(e) {
            var i = e.shape.getByName(t.Consts.CardManAnimation),
            o = this.shape.getByName(t.Consts.PowerUpCircle);
            o.frameName = i.frameName;
            var n = this.game.add.tween(o.scale).to({
                x: 0,
                y: 0
            },
            100).to({
                x: 1.5,
                y: 1.5
            },
            250).to({
                x: 1,
                y: 1
            },
            100),
            s = this.shape.getByName(t.Consts.PowerUp);
            s.scale.set(0);
            var a = this.game.add.tween(s.scale).to({
                x: 1,
                y: 1
            },
            100);
            n.chain(a),
            n.start()
        },
        i.prototype.fightWithEnemy = function(e) {
            if (e.getScore() >= this.armor + this.currentLife) return ! 1;
            if (e.getScore() <= this.armor) e.getScore() < this.armor && t.GameStatus.currentHero == t.HeroType.Base ? this.armor -= 1 : this.armor -= e.getScore();
            else if (this.armor > 0) {
                var i = e.getScore() - this.armor;
                this.armor = 0,
                this.currentLife -= i
            } else this.currentLife -= e.getScore();
            return t.GameStatus.addGold(e.getScore()),
            !0
        },
        i.prototype.useHeart = function() {
            var e = this.shape.getByName(t.ArtConsts.SmallHeart);
            this.shape.bringToTop(e);
            t.SoundController.instance.playSound(t.SoundConsts.Revive),
            e.animations.add("explode", Phaser.Animation.generateFrameNames(t.ArtConsts.SmallHeart, 0, 16, "", 4), 30, !1, !1),
            this.game.add.tween(e.scale).to({
                x: 1,
                y: 1
            },
            100, null, !0).onComplete.add(function() {
                var t = e.animations.play("explode", 60, !1, !1);
                t.onComplete.add(this.setStatus, this),
                t.onComplete.add(this.setShopItemsStatus, this)
            },
            this),
            this.currentLife = this.totalLife
        },
        i.prototype.isNegative = function() {
            return ! 1
        },
        i.prototype.increaseLifeByOneTween = function() {
            var t = this.getScaleTween(this.getCardLifeText(), this.increaseLifeByOne);
            return t.onStart.add(this.playHorseshoe, this),
            t
        },
        i.prototype.playHorseshoe = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Horseshoe)
        },
        i.prototype.increaseLifeByOne = function() {
            this.currentLife++,
            this.totalLife++,
            this.setLife()
        },
        i.prototype.useLuck = function() {
            t.GameStatus.isLuck = !1;
            var e = this.shape.getByName(t.ArtConsts.SmallLuck),
            i = this.game.add.tween(e).to({
                width: 1.5 * e.width,
                height: 1.5 * e.height
            },
            250).to({
                width: 0,
                height: 0,
                alpha: 0
            },
            150);
            i.onComplete.add(this.setShopItemsStatus, this),
            i.start()
        },
        i.prototype.getGoldValue = function() {
            return 0
        },
        i
    } (t.CardBase);
    t.Hero = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e(t) {
            this.upKey = t.input.keyboard.addKey(Phaser.Keyboard.UP),
            this.downKey = t.input.keyboard.addKey(Phaser.Keyboard.DOWN),
            this.leftKey = t.input.keyboard.addKey(Phaser.Keyboard.LEFT),
            this.rightKey = t.input.keyboard.addKey(Phaser.Keyboard.RIGHT),
            this.spaceKey = t.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR),
            this.swipe = new Swipe(t),
            this.reset()
        }
        return e.prototype.reset = function() {
            this.isUp = !1,
            this.isDown = !1,
            this.isLeft = !1,
            this.isRight = !1,
            this.isSpace = !1
        },
        e.prototype.update = function() {
            if (!this.isPressed()) {
                if (t.GameStatus.isTutorialSeen) this.checkSwipe();
                else if (t.GameStatus.isTutorialStep2Done) this.checkSwipe();
                else if (t.GameStatus.isTutorialStep1Done) {
                    if ((e = this.swipe.check()) && e.direction === this.swipe.DIRECTION_DOWN) return void(this.isDown = !0)
                } else {
                    var e;
                    if ((e = this.swipe.check()) && e.direction === this.swipe.DIRECTION_RIGHT) return void(this.isRight = !0)
                }
                this.spaceKey.isDown && (this.isSpace = !0)
            }
        },
        e.prototype.getMoveType = function() {
            return this.isDown ? t.MoveType.Down: this.isLeft ? t.MoveType.Left: this.isRight ? t.MoveType.Right: this.isUp ? t.MoveType.Up: null
        },
        e.prototype.isPressed = function() {
            return this.isUp || this.isDown || this.isLeft || this.isRight || this.isSpace
        },
        e.prototype.checkSwipe = function() {
            var t = this.swipe.check();
            if (null != t) switch (t.direction) {
            case this.swipe.DIRECTION_LEFT:
                return void(this.isLeft = !0);
            case this.swipe.DIRECTION_RIGHT:
                return void(this.isRight = !0);
            case this.swipe.DIRECTION_UP:
                return void(this.isUp = !0);
            case this.swipe.DIRECTION_DOWN:
                return void(this.isDown = !0);
            default:
                return
            }
        },
        e
    } ();
    t.KeyboardManager = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        return function(e, i, o) {
            this.isMoved = !1,
            this.section = e,
            i == t.ArtConsts.LockBomb ? this.lockType = t.LockType.Bomb: i == t.ArtConsts.LockRod || i == t.ArtConsts.LockDoubleRod ? this.lockType = t.LockType.Road: i != t.ArtConsts.LockFixedRod && i != t.ArtConsts.LockDoubleFixedRod || (this.lockType = t.LockType.Fix),
            this.shape = o
        }
    } ();
    t.LockItem = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.reset = function() {
            t.PositiveCardProbability = 0,
            t.CurrentPositiveCardProbability = 0,
            t.ChanceOfNegativeFromBox = 0,
            t.ChanceOfPositiveFromBox = 0
        },
        t.PositiveCardProbability = 0,
        t.CurrentPositiveCardProbability = 0,
        t.ChanceOfNegativeFromBox = 0,
        t.ChanceOfPositiveFromBox = 0,
        t
    } ();
    t.LogInfo = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(t) {
        function e(e) {
            return t.call(this, null, e) || this
        }
        return __extends(e, t),
        e.prototype.getScore = function() {
            return 0
        },
        e.prototype.reduceScoreInNSeconds = function(t, e) {},
        e.prototype.increaseScoreInNSeconds = function(t, e) {},
        e.prototype.stepUpdate = function() {},
        e.prototype.isNegative = function() {
            return ! 1
        },
        e.prototype.getGoldValue = function() {
            return 0
        },
        e
    } (t.CardBase);
    t.NullCard = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        return function(t, e) {
            this.x = t,
            this.y = e
        }
    } ();
    t.Point = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {
            this.tweens = [],
            this.animationDuration = 0
        }
        return t.prototype.setAnimationDuration = function(t) {
            return this.animationDuration = t,
            this
        },
        t
    } ();
    t.TweenContainer = e;
    var i = function() {
        return function() {}
    } ();
    t.TweenWrapper = i;
    var o = function() {
        return function() {}
    } ();
    t.OnCompleteWrapper = o
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.preload = function() {
            this.load.image(t.ArtConsts.Background, "./assets/ui/Background.jpg"),
            this.load.image(t.ArtConsts.Loading, "./assets/ui/Loading.png"),
            this.load.image(t.ArtConsts.BackgroundPause, "./assets/ui/BackgroundPause.png"),
            this.load.image(t.ArtConsts.PauseLogo, "./assets/ui/PauseLogo.png"),
            this.game.world.add(t.TextHelper.getText(this.game, 0, 0, "1.0", "#fff", 1))
        },
        i.prototype.create = function() {
            this.input.maxPointers = 1,
            this.stage.disableVisibilityChange = !0,
            this.game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE,
            this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE,
            this.game.scale.setResizeCallback(this.resizeCallback, this),
            this.game.device.android && (this.game.input.mouse.enabled = !this.game.device.mspointer),
            this.game.scale.pageAlignHorizontally = !0,
            this.game.scale.pageAlignVertically = !0,
            t.BackgroundHelper.setBackground(this.game, t.ArtConsts.Background),
            this.game.state.start(t.WindowsConsts.Preloader)
        },
        i.prototype.resizeCallback = function(t, e) {
            var i = Math.max(window.devicePixelRatio || 0, 1);
            this.game.scale.scaleMode === Phaser.ScaleManager.USER_SCALE && (this.game.width == window.innerWidth * i && this.game.height == window.innerHeight * i || (t.setGameSize(window.innerWidth * i, window.innerHeight * i), t.setUserScale(1 / i, 1 / i)))
        },
        i
    } (Phaser.State);
    t.Boot = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.create = function() {
            e.prototype.create.call(this),
            this.addMenuTopPanel(this.onPrevBtn.bind(this)),
            this.prevBtn.x -= 30,
            this.settingBtn.x += 30,
            this.initTableItems(),
            this.show()
        },
        i.prototype.show = function() {
            this.showTopPanel(),
            this.moveFromLeft(this.choiceBackgroundThreeXThree),
            this.moveFromRight(this.choiceBackgroundFourXFour)
        },
        i.prototype.changeState = function(i) {
            this.hideTopPanel(),
            this.moveToLeft(this.choiceBackgroundThreeXThree),
            this.moveToRight(this.choiceBackgroundFourXFour),
            setTimeout(e.prototype.changeState.bind(this, i), t.Consts.ShowTime)
        },
        i.prototype.onSettingBtnClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i.prototype.update = function() {
            this.updateAllChildren(this.choiceBackgroundThreeXThree),
            this.updateAllChildren(this.choiceBackgroundFourXFour)
        },
        i.prototype.initTableItems = function() {
            this.choiceBackgroundThreeXThree = new t.ChoiceBackground(this.game, 0, 0),
            this.choiceBackgroundThreeXThree.anchor.setTo(.5, .5),
            this.choiceBackgroundThreeXThree.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.ThreeXThree)),
            this.choiceBackgroundThreeXThree.addChild(new t.Shadow(this.game, 0, 85)),
            this.initRings(this.choiceBackgroundThreeXThree);
            var e = this.addBtn(this.choiceBackgroundThreeXThree.width / 2, this.choiceBackgroundThreeXThree.height / 2, t.BtnType.Play, this.onPlay3x3Click.bind(this));
            this.choiceBackgroundThreeXThree.addChild(e),
            this.choiceBackgroundThreeXThree.x = this.centerX - this.choiceBackgroundThreeXThree.width / 2.05,
            this.choiceBackgroundThreeXThree.y = this.centerY,
            this.choiceBackgroundThreeXThree.scale.set(.9, .9),
            this.choiceBackgroundFourXFour = new t.ChoiceBackground(this.game, 0, 0),
            this.choiceBackgroundFourXFour.anchor.setTo(.5, .5),
            this.choiceBackgroundFourXFour.addChild(t.ShapeFactoryHelper.getShakeShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.FourXFour)),
            this.choiceBackgroundFourXFour.addChild(new t.Shadow(this.game, 0, 85)),
            this.initRings(this.choiceBackgroundFourXFour);
            var i = this.choiceBackgroundFourXFour.width / 2,
            o = this.choiceBackgroundFourXFour.height / 2;
            if (t.GameStatus.isFourXFour) this.fourXFourBtn = this.addBtn(i, o, t.BtnType.Play, this.onPlay4x4Click);
            else {
                var n = new t.Coin(this.game, -30, -this.choiceBackgroundFourXFour.height / 3, t.PriceConsts.FourXFour.toString());
                n.anchor.setTo(.5, .5),
                this.choiceBackgroundFourXFour.addChild(n),
                this.lock = new t.Lock(this.game, 0, 0),
                this.lock.anchor.setTo(.5, .5),
                this.lock.x = this.choiceBackgroundFourXFour.width / this.choiceBackgroundFourXFour.scale.x / 2.5 - .8 * this.choiceBackgroundFourXFour.width,
                this.lock.y = this.choiceBackgroundFourXFour.height / this.choiceBackgroundFourXFour.scale.y / 2.5,
                this.choiceBackgroundFourXFour.addChild(this.lock),
                t.GameStatus.gold >= t.PriceConsts.FourXFour && (this.fourXFourBtn = this.addBtn(i, o, t.BtnType.Plus, this.onPlusClick))
            }
            this.fourXFourBtn && this.choiceBackgroundFourXFour.addChild(this.fourXFourBtn),
            this.choiceBackgroundFourXFour.x = this.centerX + this.choiceBackgroundFourXFour.width / 2.05,
            this.choiceBackgroundFourXFour.y = this.centerY,
            this.choiceBackgroundFourXFour.scale.set(.9, .9),
            this.gameContainer.add(this.choiceBackgroundThreeXThree),
            this.gameContainer.add(this.choiceBackgroundFourXFour)
        },
        i.prototype.onPrevBtn = function() {
            this.changeState(t.WindowsConsts.Shop)
        },
        i.prototype.addBtn = function(e, i, o, n, s) {
            void 0 === s && (s = !0);
            var a = new t.Btn(this.game, e, i, o, n.bind(this), s);
            return a.x -= a.width / 3,
            a.y -= a.height / 3,
            a
        },
        i.prototype.initRings = function(e) {
            var i = new t.SmallRing(this.game, 0, 0, t.ArtConsts.SmallRing);
            e.addChild(i);
            var o = new t.BigRing(this.game, 0, 0, t.ArtConsts.BigRing);
            e.addChild(o)
        },
        i.prototype.onPlusClick = function() {
            t.SoundController.instance.playSound(t.SoundConsts.Buy),
            t.GameStatus.gold -= t.PriceConsts.FourXFour,
            t.GameStatus.isFourXFour = !0,
            this.lock.unlock(this.onLockAnimationComplete),
            this.fourXFourBtn.destroy();
            var e = this.addBtn(this.choiceBackgroundFourXFour.width / this.choiceBackgroundFourXFour.scale.x / 2, this.choiceBackgroundFourXFour.height / this.choiceBackgroundFourXFour.scale.y / 2, t.BtnType.Play, this.onPlay4x4Click);
            this.choiceBackgroundFourXFour.addChild(e)
        },
        i.prototype.onLockAnimationComplete = function() {
            void 0 !== this.lock && this.lock.kill()
        },
        i.prototype.onPlay3x3Click = function() {
            t.GameStatus.RowCount = 3,
            t.GameStatus.ColumnCount = 3,
            this.changeState(t.WindowsConsts.Game)
        },
        i.prototype.onPlay4x4Click = function() {
            t.GameStatus.RowCount = 4,
            t.GameStatus.ColumnCount = 4,
            this.changeState(t.WindowsConsts.Game)
        },
        i
    } (t.StateBase);
    t.ChooseGameFormat = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.create = function() {
            e.prototype.create.call(this),
            this.addMenuTopPanel(),
            this.initHeroTable(),
            this.initButtons(),
            this.setState(),
            this.show()
        },
        i.prototype.update = function() {
            this.updateAllChildren(this.choiceHero)
        },
        i.prototype.show = function() {
            this.showTopPanel(),
            this.moveFromRight(this.nextHeroBtn, t.Consts.ShowTime / 3),
            this.moveFromLeft(this.choiceHero),
            this.moveFromLeft(this.prevHeroBtn, t.Consts.ShowTime / 3),
            this.moveFromLeft(this.iBtn, t.Consts.ShowTime / 3),
            this.moveFromBottom(this.plusBtn),
            this.moveFromBottom(this.playBtn)
        },
        i.prototype.changeState = function(i) {
            this.hideTopPanel(),
            this.moveToRight(this.nextHeroBtn),
            this.moveToLeft(this.prevHeroBtn),
            this.moveToLeft(this.choiceHero, t.Consts.ShowTime / 3),
            this.moveToLeft(this.iBtn),
            this.moveToLeft(this.iPrevBtn),
            this.moveToBottom(this.plusBtn),
            this.moveToBottom(this.playBtn),
            setTimeout(e.prototype.changeState.bind(this, i), t.Consts.ShowTime)
        },
        i.prototype.onSettingBtnClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i.prototype.initHeroTable = function() {
            this.choiceHero = new t.ChoiceHero(this.game, this.centerX, this.centerY),
            this.heroes = [t.HeroType.Base, t.HeroType.Bomb, t.HeroType.Key, t.HeroType.Gun],
            this.currentIndex = this.getCurrentIndex(),
            this.currentType = this.heroes[this.currentIndex],
            this.gameContainer.add(this.choiceHero)
        },
        i.prototype.initButtons = function() {
            this.nextHeroBtn = new t.Btn(this.game, 0, 0, t.BtnType.Next, this.onNextClick.bind(this)),
            this.nextHeroBtn.x = this.centerX + this.choiceHero.width / 2 + .7 * this.nextHeroBtn.width,
            this.nextHeroBtn.y = this.centerY,
            this.gameContainer.add(this.nextHeroBtn),
            this.prevHeroBtn = new t.Btn(this.game, 0, 0, t.BtnType.Prev, this.onPrevClick.bind(this)),
            this.prevHeroBtn.x = this.centerX - this.choiceHero.width / 2 - .7 * this.prevHeroBtn.width,
            this.prevHeroBtn.y = this.centerY,
            this.gameContainer.add(this.prevHeroBtn),
            this.playBtn = new t.Btn(this.game, 0, 0, t.BtnType.Play, this.onPlayClick.bind(this), !0),
            this.playBtn.x = this.centerX,
            this.playBtn.y = 5 * this.gameHeight / 6,
            this.playBtn.visible = !1,
            this.gameContainer.add(this.playBtn),
            this.plusBtn = new t.Btn(this.game, 0, 0, t.BtnType.Plus, this.onPlusClick.bind(this)),
            this.plusBtn.x = this.centerX,
            this.plusBtn.y = 5 * this.gameHeight / 6,
            this.plusBtn.visible = !1,
            this.gameContainer.add(this.plusBtn),
            this.iBtn = new t.Btn(this.game, 0, 0, t.BtnType.I, this.onIClick.bind(this)),
            this.iBtn.x = this.choiceHero.x - this.choiceHero.width / 2 + this.iBtn.width / 4,
            this.iBtn.y = this.choiceHero.y + this.choiceHero.height / 2 - this.iBtn.height / 4,
            this.gameContainer.add(this.iBtn),
            this.iPrevBtn = new t.Btn(this.game, 0, 0, t.BtnType.PrevSmall, this.onIPrevClick.bind(this)),
            this.iPrevBtn.x = this.choiceHero.x - this.choiceHero.width / 2 + this.iPrevBtn.width / 4,
            this.iPrevBtn.y = this.choiceHero.y + this.choiceHero.height / 2 - this.iPrevBtn.height / 4,
            this.iPrevBtn.visible = !1,
            this.gameContainer.add(this.iPrevBtn)
        },
        i.prototype.setState = function() {
            this.choiceHero.setHeroType(this.currentType),
            this.setPrevNextBtnState(),
            this.setBottomButtonState(),
            this.showIBtn(),
            this.isCurrentTypePurchased() ? (this.choiceHero.hideCoin(), this.choiceHero.hideLock()) : this.choiceHero.showCoin(t.PriceHelper.getHeroPrice(this.currentType))
        },
        i.prototype.setPrevNextBtnState = function() {
            this.prevHeroBtn.visible = !0,
            this.nextHeroBtn.visible = !0,
            0 == this.currentIndex && (this.prevHeroBtn.visible = !1),
            this.currentIndex == this.heroes.length - 1 && (this.nextHeroBtn.visible = !1)
        },
        i.prototype.setBottomButtonState = function() {
            this.playBtn.visible = !1,
            this.plusBtn.visible = !1,
            this.currentType != t.HeroType.Base ? this.isCurrentTypePurchased() ? this.showPlayBtn() : t.GameStatus.gold >= t.PriceHelper.getHeroPrice(this.currentType) ? (this.showPlusBtn(), this.choiceHero.showLock()) : this.choiceHero.showLock() : this.showPlayBtn()
        },
        i.prototype.isCurrentTypePurchased = function() {
            return this.currentType == t.HeroType.Base || this.currentType == t.HeroType.Bomb && t.GameStatus.isBombHero || this.currentType == t.HeroType.Key && t.GameStatus.isKeyHero || this.currentType == t.HeroType.Gun && t.GameStatus.isGunHero
        },
        i.prototype.showPlayBtn = function() {
            this.playBtn.visible = !0,
            this.plusBtn.visible = !1
        },
        i.prototype.showPlusBtn = function() {
            this.playBtn.visible = !1,
            this.plusBtn.visible = !0
        },
        i.prototype.onNextClick = function() {
            this.currentIndex === this.heroes.length - 1 ? (this.currentIndex = 0, this.currentType = this.heroes[this.currentIndex]) : (this.currentIndex += 1, this.currentType = this.heroes[this.currentIndex]),
            this.setState()
        },
        i.prototype.onPrevClick = function() {
            0 === this.currentIndex ? (this.currentIndex = this.heroes.length - 1, this.currentType = this.heroes[this.currentIndex]) : (this.currentIndex -= 1, this.currentType = this.heroes[this.currentIndex]),
            this.setState()
        },
        i.prototype.onPlusClick = function() {
            switch (t.GameStatus.gold -= t.PriceHelper.getHeroPrice(this.currentType), t.SoundController.instance.playSound(t.SoundConsts.Buy), this.currentType) {
            case t.HeroType.Gun:
                t.GameStatus.isGunHero = !0;
                break;
            case t.HeroType.Key:
                t.GameStatus.isKeyHero = !0;
                break;
            case t.HeroType.Bomb:
                t.GameStatus.isBombHero = !0
            }
            this.choiceHero.startLockAnimation(),
            this.setState()
        },
        i.prototype.onIClick = function() {
            var e = t.TweenHelper.scaleIn(this.game, this.iBtn);
            e.onComplete.add(this.hideIBtn, this);
            var i = t.TweenHelper.turnAnimationStart(this.game, this.choiceHero);
            i.onComplete.add(this.choiceHero.setITypeCallback, this.choiceHero, 0, this.currentType);
            var o = t.TweenHelper.turnAnimationEnd(this.game, this.choiceHero),
            n = t.TweenHelper.scaleOut(this.game, this.iPrevBtn);
            e.chain(i, o, n)
        },
        i.prototype.onIPrevClick = function() {
            var e = t.TweenHelper.scaleIn(this.game, this.iPrevBtn);
            e.onComplete.add(this.showIBtn, this);
            var i = t.TweenHelper.turnAnimationStart(this.game, this.choiceHero);
            i.onComplete.add(this.choiceHero.setHeroTypeCallback, this.choiceHero, 0, this.currentType),
            i.onComplete.add(this.setState, this);
            var o = t.TweenHelper.turnAnimationEnd(this.game, this.choiceHero),
            n = t.TweenHelper.scaleOut(this.game, this.iBtn);
            e.chain(i, o, n)
        },
        i.prototype.hideIBtn = function() {
            this.iBtn.visible = !1,
            this.iPrevBtn.visible = !0
        },
        i.prototype.showIBtn = function() {
            this.iBtn.visible = !0,
            this.iPrevBtn.visible = !1
        },
        i.prototype.onPlayClick = function() {
            t.GameStatus.currentHero = this.currentType,
            this.changeState(t.WindowsConsts.Shop)
        },
        i.prototype.getCurrentIndex = function() {
            return t.GameStatus.isGunHero ? this.heroes.indexOf(t.HeroType.Gun) : t.GameStatus.isKeyHero ? this.heroes.indexOf(t.HeroType.Key) : t.GameStatus.isBombHero ? this.heroes.indexOf(t.HeroType.Bomb) : this.heroes.indexOf(t.HeroType.Base)
        },
        i
    } (t.StateBase);
    t.ChooseHero = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.title = "THE GAME BY IFGD",
            t.code = "CODE..........................................ROSTISLAV KOSMIRAK",
            t.art = "ARTIST-ANIMATOR....VALENTYNE KRAVCHENKO",
            t.gameDesigner = "GAME DESIGNER..............................TARAS POLOVKO",
            t.sponsors = "Exclusively published by ",
            t
        }
        return __extends(i, e),
        i.prototype.create = function() {
            e.prototype.create.call(this);
            this.content = new Phaser.Group(this.game, this.gameContainer),
            this.content.add(t.TextHelper.getText(this.game, 0, 250, this.title, t.Consts.creditsColor, t.Consts.creditsFontWeight)),
            this.content.add(t.TextHelper.getText(this.game, 0, 300, this.code, t.Consts.creditsColor, t.Consts.creditsFontWeight)),
            this.content.add(t.TextHelper.getText(this.game, 0, 350, this.art, t.Consts.creditsColor, t.Consts.creditsFontWeight)),
            this.content.add(t.TextHelper.getText(this.game, 0, 400, this.gameDesigner, t.Consts.creditsColor, t.Consts.creditsFontWeight)),
            this.content.add(t.TextHelper.getText(this.game, 0, 500, this.sponsors, t.Consts.creditsColor, t.Consts.creditsFontWeight + 5));
            var i = this.game.add.image(0, 530, t.ArtConsts.FamobiLogo);
            i.scale.set(.15, .15),
            i.anchor.set(.5, 0),
            this.content.add(i),
            this.content.x = this.centerX,
            this.homeBtn = new t.Btn(this.game, this.centerX, 5 * this.gameHeight / 6, t.BtnType.Home, this.onHomeClick.bind(this), !0),
            this.gameContainer.add(this.homeBtn),
            this.show()
        },
        i.prototype.show = function() {
            this.moveFromTop(this.content),
            this.moveFromBottom(this.homeBtn)
        },
        i.prototype.changeState = function(i) {
            this.moveToTop(this.content),
            this.moveToBottom(this.homeBtn),
            setTimeout(e.prototype.changeState.bind(this, i), t.Consts.ShowTime)
        },
        i.prototype.onHomeClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i
    } (t.StateBase);
    t.Credits = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.isSwipe = !1,
            t
        }
        return __extends(i, e),
        i.prototype.create = function() {
            0 == t.Consts.IsAndroid && window.famobi_analytics.trackScreen(window.famobi_analytics.SCREEN_LEVEL),
            e.prototype.create.call(this),
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.Background),
            this.game.time.advancedTiming = !0,
            this.keyboardManager = new t.KeyboardManager(this.game),
            this.tableContainer = new Phaser.Group(this.game);
            var i, o = new t.CardFactory(this.game, this.tableContainer);
            this.field = new t.Field(this.game, o, this.keyboardManager),
            i = 3 == t.GameStatus.RowCount ? .9 : .7,
            this.tableContainer.scale.set(i, i),
            this.tableContainer.x = .5 * (t.Consts.Width - (t.Consts.CardWidth * t.GameStatus.RowCount + t.Consts.CardSpaceBetweenWidth * (t.GameStatus.RowCount - 1)) * i),
            this.tableContainer.y = .5 * (t.Consts.Height - (t.Consts.CardHeight * t.GameStatus.ColumnCount + t.Consts.CardSpaceBetweenHeight * (t.GameStatus.ColumnCount - 1)) * i) + 30,
            t.GameStatus.init(),
            this.addStatusPanel(),
            this.animationQueue = this.field.initField(),
            this.onAnimation = !1,
            this.field.onAnimation = this.onAnimation,
            this.isPause = !1,
            this.gameContainer.add(this.tableContainer),
            this.game.input.onUp.add(this.onMouseClick, this),
            this.clickAnimation = new t.MouseClickAnimation(this.game, 0, 0),
            this.game.world.addChild(this.clickAnimation)
        },
        i.prototype.onMouseClick = function() {
            this.isSwipe ? this.isSwipe = !1 : (this.clickAnimation.x = this.game.input.activePointer.x, this.clickAnimation.y = this.game.input.activePointer.y, this.clickAnimation.play(t.AnimationConsts.Action, 60, !1, !1))
        },
        i.prototype.scaleGameContainer = function() {
            if (e.prototype.scaleGameContainer.call(this), this.popup) {
                t.BackgroundHelper.setBackgroundToGroup(this.game, this.popup, t.ArtConsts.BackgroundPause);
                var i = this.popup.getByName(t.Consts.ContainerName);
                i && (this.popup.bringToTop(i), t.ScaleHelper.scaleContainer(i, this.gameWidth, this.gameHeight))
            }
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.Background)
        },
        i.prototype.render = function() {
            t.Consts.IsDev && (this.game.debug.text("FPS: " + (this.game.time.fps || "--"), 20, 40, "#00ff00", "40px Dosis-SemiBold"), this.game.debug.text("CB: " + t.GameStatus.cardCounter.toString(), 20, 80, "#00ff00", "40px Dosis-SemiBold"), this.game.debug.text("P: " + t.LogInfo.PositiveCardProbability.toFixed(2), 20, 120, "#00ff00", "40px Dosis-SemiBold"))
        },
        i.prototype.update = function() {
            this.isChest && this.keyboardManager.reset(),
            this.keyboardManager.update(),
            this.isSwipe = this.keyboardManager.isPressed(),
            this.isChest ? this.keyboardManager.isSpace && setTimeout(this.chestUnlock.onClick.bind(this.chestUnlock), 1) : this.isPause || (t.GameStatus.isGameEnd && (t.GameStatus.resetShop(), this.fadeOutState(t.WindowsConsts.Result)), this.onAnimation || (this.animationQueue.length > 0 ? this.runAnimationFromQueue() : this.fillQueue()))
        },
        i.prototype.runAnimationFromQueue = function() {
            var t = this,
            e = this.animationQueue.shift();
            this.onAnimation = !0,
            this.field.onAnimation = this.onAnimation;
            var i = e.tweens.shift(),
            o = i;
            if (e.tweens.length > 0) for (o = e.tweens.shift(), i.chain(o); e.tweens.length > 0;) {
                var n = e.tweens.shift();
                o.chain(n),
                o = n
            }
            0 === e.animationDuration ? o.onComplete.add(function() {
                t.onAnimation = !1,
                t.field.onAnimation = t.onAnimation,
                t.keyboardManager.reset()
            },
            this) : setTimeout(this.onAnimationComplete.bind(this), e.animationDuration),
            i.start()
        },
        i.prototype.fillQueue = function() {
            if (t.GameStatus.isHeroAlive) {
                var e, i, o, n, s, a = this.field.getHero();
                if (a.needShoot) return (e = this.animationQueue).push.apply(e, this.field.shootCannon()),
                void(a.needShoot = !1);
                if (a.needRunLightning) return (i = this.animationQueue).push.apply(i, this.field.shootLightning()),
                void(a.needRunLightning = !1);
                if (a.needShootMultiplier) return (o = this.animationQueue).push.apply(o, this.field.shootMultiplier()),
                void(a.needShootMultiplier = !1);
                if (a.needShootSkull) return (n = this.animationQueue).push.apply(n, this.field.shootSkull()),
                void(a.needShootSkull = !1); (s = this.animationQueue).push.apply(s, this.field.smashBomb()),
                this.checkKeyHandler()
            } else t.GameStatus.isGameEnd = !0
        },
        i.prototype.onAnimationComplete = function() {
            this.onAnimation = !1,
            this.field.onAnimation = this.onAnimation,
            this.keyboardManager.reset()
        },
        i.prototype.openChestPopUp = function() {
            if (!this.isPause && !this.isChest) {
                this.isChest = !0,
                this.field.stopAllAnimations();
                var e = new t.ChestUnlock(this.game, this.chestOpened.bind(this), this.chestClosed.bind(this));
                e.initGroup(),
                this.game.input.enabled = !0,
                this.game.input.onDown.add(e.onClick.bind(e)),
                this.popup = new Phaser.Group(this.game),
                t.BackgroundHelper.setBackgroundToGroup(this.game, this.popup, t.ArtConsts.BackgroundPause);
                var i = new Phaser.Group(this.game, this.world);
                t.ScaleHelper.scaleContainer(i, this.gameWidth, this.gameHeight),
                i.name = t.Consts.ContainerName,
                i.add(e),
                this.popup.add(i),
                this.chestUnlock = e,
                this.fadeIn(this.popup)
            }
        },
        i.prototype.chestOpened = function() {
            t.SoundController.instance.playSound(t.SoundConsts.ChestOpening),
            this.isChest = !1,
            this.field.playAllAnimations(),
            this.chestOpenedAction()
        },
        i.prototype.chestOpenedAction = function() {
            var e;
            this.destroyChestDelayed(),
            (e = this.animationQueue).push.apply(e, this.field.replaceCard(this.moveType, t.CardGenerationType.AfterChest)),
            t.GameStatus.stepUpdate(),
            this.isChangeTurnsToBoss() && t.GameStatus.decreaseTurnsToBoss()
        },
        i.prototype.destroyChestDelayed = function(t) {
            void 0 === t && (t = 1),
            setTimeout(this.destroyChest.bind(this), t)
        },
        i.prototype.destroyChest = function() {
            this.popup && this.fadeOut(this.popup,
            function() {
                this.chestUnlock && this.chestUnlock.destroy(),
                this.popup.removeAll(!0),
                this.popup.destroy(!0)
            }.bind(this))
        },
        i.prototype.chestClosed = function() {
            this.isChest = !1;
            var e = 4 == t.GameStatus.RowCount ? 1e3: 500;
            this.game.camera.shake(t.Consts.ShakeIntensity, e),
            this.smashChest();
            this.field.smashHero(600),
            this.field.playAllAnimations(),
            this.destroyChestDelayed(500);
            var i, o, n = this.field.getHero();
            t.GameStatus.currentHero != t.HeroType.Bomb && n.reduceScoreInNSeconds(1, 1),
            0 == n.getScore() ? ((i = this.animationQueue).push.apply(i, this.field.removeAllChild()), t.GameStatus.isHeroAlive = !1) : (o = this.animationQueue).push.apply(o, this.field.move(this.moveType)),
            t.GameStatus.stepUpdate(),
            this.isChangeTurnsToBoss() && t.GameStatus.decreaseTurnsToBoss()
        },
        i.prototype.smashChest = function() {
            var e = this.popup.getByName(t.Consts.ContainerName);
            this.addBombExplosionAnimation(e, t.RandomHelper.getRandomIntInclusive(100, 200), t.RandomHelper.getRandomIntInclusive(150, 250), 1),
            this.addBombExplosionAnimation(e, t.RandomHelper.getRandomIntInclusive(400, 500), t.RandomHelper.getRandomIntInclusive(450, 550), 100),
            this.addBombExplosionAnimation(e, t.RandomHelper.getRandomIntInclusive(100, 500), t.RandomHelper.getRandomIntInclusive(150, 550), 200)
        },
        i.prototype.addBombExplosionAnimation = function(e, i, o, n) {
            setTimeout(function() {
                var n = new t.Boom(this.game, i, o);
                n.play(t.AnimationConsts.Action, 60, !1, !0),
                e.add(n),
                setTimeout(function() {
                    t.SoundController.instance.playSound(t.SoundConsts.PickLockFail)
                }.bind(this), t.RandomHelper.getRandomIntInclusive(1, 100))
            }.bind(this), n)
        },
        i.prototype.openPauseMenu = function() {
            if (!this.isChest && !this.isPause) {
                0 == t.Consts.IsAndroid && window.famobi_analytics.trackScreen(window.famobi_analytics.SCREEN_PAUSE),
                this.isPause = !0,
                this.field.stopAllAnimations(),
                this.popup = new Phaser.Group(this.game),
                t.BackgroundHelper.setBackgroundToGroup(this.game, this.popup, t.ArtConsts.BackgroundPause);
                var e = new Phaser.Group(this.game, this.world);
                t.ScaleHelper.scaleContainer(e, this.gameWidth, this.gameHeight),
                e.name = t.Consts.ContainerName;
                var i = new t.PauseLogo(this.game, this.centerX, this.centerY - 200);
                i.anchor.set(.5, .5);
                var o = this.centerY + 100,
                n = new t.Btn(this.game, this.centerX - 150, o, t.BtnType.Home, this.onHomeClick.bind(this), !0),
                s = new t.Btn(this.game, this.centerX, o, t.BtnType.Sound, null),
                a = new t.Btn(this.game, this.centerX + 150, o, t.BtnType.Resume, this.onResumeClick.bind(this));
                i.x = this.centerX,
                i.y = 2 * this.gameHeight / 6,
                n.x = this.centerX - n.width - 25,
                n.y = 4 * this.gameHeight / 6,
                s.x = this.centerX,
                s.y = 4 * this.gameHeight / 6,
                a.x = this.centerX + a.width + 25,
                a.y = 4 * this.gameHeight / 6,
                e.add(i),
                e.add(n),
                e.add(s),
                e.add(a),
                this.popup.add(e),
                this.fadeIn(this.popup)
            }
        },
        i.prototype.checkKeyHandler = function() {
            var t = this.keyboardManager.getMoveType();
            if (t) {
                var e, i = this.move(t);
                i.length > 0 ? (this.field.stepUpdate(), (e = this.animationQueue).push.apply(e, i)) : this.keyboardManager.reset()
            }
        },
        i.prototype.move = function(e) {
            var i = this.field.getCardToFight(e);
            if (null == i) return [];
            var o = this.field.getHero(),
            n = o.fight(i);
            if (!n.isHeroAlive) return t.GameStatus.isHeart ? (t.GameStatus.isHeart = !1, this.keyboardManager.reset(), o.useHeart(), this.field.move(e)) : (t.GameStatus.isHeroAlive = !1, this.field.removeAllChild());
            if (n.isChest) return this.moveType = e,
            t.GameStatus.currentHero == t.HeroType.Key ? this.chestOpened() : t.GameStatus.isKey ? (this.field.getHero().setShopItemsStatus(), this.chestOpened()) : this.openChestPopUp(),
            [];
            var s, a = []; (t.GameStatus.stepUpdate(), n.isNeedIncreaseLifeByOne) && ((s = new t.TweenContainer).tweens.push(this.field.getHero().increaseLifeByOneTween()), a.push(s)); (n.isMove ? a.push.apply(a, this.field.move(e)) : a.push.apply(a, this.field.replaceCard(e, t.CardGenerationType.AfterBarrel, i.getScore())), n.isNeedIncreaseLifeByOneAfterBoss) && ((s = new t.TweenContainer).tweens.push(this.field.getHero().increaseLifeByOneTween()), a.push(s));
            return this.isChangeTurnsToBoss() && t.GameStatus.decreaseTurnsToBoss(),
            a
        },
        i.prototype.isChangeTurnsToBoss = function() {
            return ! t.GameStatus.isNeedCreateBoss && !this.field.isBossInTheField()
        },
        i.prototype.addStatusPanel = function() {
            this.panelContainer = new Phaser.Group(this.game),
            this.gamePanel = new t.GameStatusPanel(this.game, 0, 0),
            this.menuBtn = new t.Btn(this.game, 0, this.gamePanel.height / 2, t.BtnType.Pause, this.openPauseMenu.bind(this)),
            this.menuBtn.x = this.gamePanel.width + this.menuBtn.width / 2 + 5,
            this.panelContainer.scale.set(.9, .9),
            this.panelContainer.x = 40,
            this.panelContainer.y = 60,
            this.panelContainer.addChild(this.menuBtn),
            this.panelContainer.addChild(this.gamePanel),
            this.gameContainer.add(this.panelContainer)
        },
        i.prototype.onHomeClick = function() {
            t.GameStatus.resetShop(),
            this.fadeOutState(t.WindowsConsts.MainMenu)
        },
        i.prototype.onResumeClick = function() {
            this.fadeOut(this.popup,
            function() {
                this.field.playAllAnimations(),
                this.isPause = !1,
                this.popup.destroy(!0)
            }.bind(this))
        },
        i
    } (t.StateBase);
    t.Game = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.create = function() {
            0 == t.Consts.IsAndroid && window.famobi_analytics.trackScreen(window.famobi_analytics.SCREEN_HOME),
            e.prototype.create.call(this),
            this.logo = new t.MenuLogo(this.game, this.centerX - 15, this.centerY - this.gameHeight / 4),
            this.logo.scale.set(.9, .9),
            this.gameContainer.add(this.logo),
            this.groupBtn = new t.Btn(this.game, 0, .7 * this.gameHeight, t.BtnType.Group, this.onGroupClick.bind(this), !0),
            this.gameContainer.add(this.groupBtn),
            this.groupBtn.x = this.centerX - this.groupBtn.width - 60,
            this.playBtn = new t.BigPlayBtn(this.game, 0, .7 * this.gameHeight, this.onPlayClick.bind(this)),
            this.gameContainer.add(this.playBtn),
            this.playBtn.x = this.centerX,
            this.soundBtn = new t.Btn(this.game, 0, .7 * this.gameHeight, t.BtnType.Sound, null),
            this.gameContainer.add(this.soundBtn),
            this.soundBtn.x = this.centerX + this.groupBtn.width + 60,
            0 == t.Consts.IsAndroid && (this.moreGamesBtn = this.game.add.sprite(this.centerX, .9 * this.gameHeight, t.ArtConsts.MoreGames), this.moreGamesBtn.scale.x = .3, this.moreGamesBtn.scale.y = .3, this.moreGamesBtn.anchor.set(.5), this.moreGamesBtn.inputEnabled = !0, this.moreGamesBtn.events.onInputDown.add(this.onBtnMoreClick, this), this.gameContainer.add(this.moreGamesBtn)),
            this.show()
        },
        i.prototype.onBtnMoreClick = function() {
            window.famobi.moreGamesLink()
        },
        i.prototype.show = function() {
            this.moveFromTop(this.logo),
            this.moveFromBottom(this.groupBtn),
            this.moveFromBottom(this.playBtn, .5 * t.Consts.ShowTime),
            this.moveFromBottom(this.soundBtn, .75 * t.Consts.ShowTime),
            0 == t.Consts.IsAndroid && this.moveFromBottom(this.moreGamesBtn, t.Consts.ShowTime)
        },
        i.prototype.changeState = function(i) {
            this.moveToTop(this.logo),
            this.moveToBottom(this.groupBtn, t.Consts.ShowTime),
            this.moveToBottom(this.playBtn, .5 * t.Consts.ShowTime),
            this.moveToBottom(this.soundBtn, .25 * t.Consts.ShowTime),
            0 == t.Consts.IsAndroid && this.moveToBottom(this.moreGamesBtn),
            setTimeout(e.prototype.changeState.bind(this, i), 1.75 * t.Consts.ShowTime)
        },
        i.prototype.update = function() {
            this.logo.update()
        },
        i.prototype.onGroupClick = function() {
            this.changeState(t.WindowsConsts.Credits)
        },
        i.prototype.onPlayClick = function() {
            t.GameStatus.isTutorialSeen ? this.changeState(t.WindowsConsts.ChooseHero) : (t.GameStatus.currentHero = t.HeroType.Base, t.GameStatus.RowCount = 3, t.GameStatus.ColumnCount = 3, this.changeState(t.WindowsConsts.Game))
        },
        i
    } (t.StateBase);
    t.MainMenu = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.preload = function() {
            t.BackgroundHelper.setBackground(this.game, t.ArtConsts.Background);
            var e = t.Consts.Width / 2,
            i = t.Consts.Height / 2,
            o = t.Consts.Width,
            n = t.Consts.Height,
            s = new t.PauseLogo(this.game, e, i - 100);
            s.anchor.set(.5, .5),
            this.background = new Phaser.Group(this.game),
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.BackgroundPause),
            this.gameContainer = new Phaser.Group(this.game),
            t.ScaleHelper.scaleContainer(this.gameContainer, o, n),
            this.loadingBar = this.add.sprite(e, i + i / 2, t.ArtConsts.Loading),
            this.loadingBar.anchor.setTo(.5),
            this.loadingBar.alpha = .7,
            this.game.load.setPreloadSprite(this.loadingBar, 0);
            var a = this.game.add.graphics(145, i + i / 2 - 20);
            a.lineStyle(8, 16777215, .7),
            a.drawRect(0, 0, 350, 40),
            this.preloadText = t.TextHelper.getText(this.game, 0, 3, "0%", "#ffffff", 24),
            this.loadingBar.addChild(this.preloadText),
            this.preloadText.alpha = .71,
            this.game.load.onFileComplete.add(this.onFileComplete, this),
            this.gameContainer.add(s),
            this.gameContainer.add(a),
            this.gameContainer.add(this.loadingBar),
            this.fadeInState(),
            this.game.scale.onSizeChange.add(this.scaleGameContainer, this);
            // 0 == t.Consts.IsAndroid && this.game.load.image(t.ArtConsts.MoreGames, window.famobi.getMoreGamesButtonImage(!0));
            for (var r = 0,h = t.SoundController.instance.getSoundNames(); r < h.length; r++) {
                var d = h[r];
                this.loadSounds(d)
            }
            this.load.image(t.ArtConsts.BackgroundMenu, "./assets/ui/BackgroundMenu.jpg"),
            this.load.image(t.ArtConsts.FamobiLogo, "./assets/ui/FamobiLogo.png"),
            this.load.atlasJSONHash(t.ArtConsts.Items1, "./assets/sprites/game1.png", "./assets/sprites/game1.json"),
            this.load.atlasJSONHash(t.ArtConsts.Items2, "./assets/sprites/game2.png", "./assets/sprites/game2.json"),
            this.game.load.onLoadComplete.add(this.onLoadingComplete, this)
        },
        i.prototype.scaleGameContainer = function() {
            e.prototype.scaleGameContainer.call(this),
            t.BackgroundHelper.setBackgroundToGroup(this.game, this.background, t.ArtConsts.BackgroundPause)
        },
        i.prototype.loadSounds = function(t) {
            this.load.audio(t, ["./assets/sounds/mp3/" + t + ".mp3", "./assets/sounds/m4a/" + t + ".m4a", "./assets/sounds/ogg/" + t + ".ogg"], !0)
        },
        i.prototype.onFileComplete = function(t, e, i, o, n) {
            this.preloadText.setText(t.toString() + "%")
        },
        i.prototype.onLoadingComplete = function() {
            t.SoundController.instance.init(),
            t.SoundController.instance.isDecodingSupported() ? this.game.sound.setDecodedCallback(t.SoundController.instance.getSoundNames(), this.onSoundsDecoded, this) : this.onSoundsDecoded()
        },
        i.prototype.create = function() {
            this.fadeOutState(t.WindowsConsts.MainMenu)
        },
        i.prototype.onSoundsDecoded = function() {
            t.SoundController.instance.startMusic()
        },
        i
    } (t.StateBase);
    t.Preloader = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.resultShowTime = 60,
            t.isPlay = !0,
            t
        }
        return __extends(i, e),
        i.prototype.create = function() {
            0 == t.Consts.IsAndroid && window.famobi_analytics.trackScreen(window.famobi_analytics.SCREEN_GAMERESULT),
            t.GameStatus.gold += t.GameStatus.goldPerGame,
            this.prevGoldValue = 0,
            this.prevSilverValue = 0,
            t.BackgroundHelper.setBackground(this.game, t.ArtConsts.BackgroundPause),
            e.prototype.create.call(this),
            this.addMenuTopPanel(null, !1),
            this.addStatus(),
            this.isAdvertisementAvailable() || (this.choiceBackground.y = this.centerY),
            t.AdManager.instance.onAdDismissSignal.add(this.advertisementDismissed, this),
            this.show();
            var i = function() {
                this.addBottomButtons(),
                this.moveFromBottom(this.buttons),
                t.AdManager.instance.isRewardedVideoAvailable() && (this.addRewardedVideoPanel(), this.advPanel && (this.advPanel.visible = this.advText.visible = this.advBtn.visible = !0, this.moveFromLeft(this.advPanel), this.moveFromLeft(this.advText), this.moveFromRight(this.advBtn)))
            }.bind(this);
            t.Consts.IsAndroid ? t.AdManager.instance.isInterstitialAvailable() ? setTimeout(function() {
                t.AdManager.instance.showAd(i)
            },
            200) : i() : setTimeout(function() {
                Promise.all([window.famobi_analytics.trackEvent("EVENT_LEVELFAIL", {
                    levelName: "",
                    reason: "dead"
                }), window.famobi_analytics.trackEvent("EVENT_TOTALSCORE", {
                    totalScore: t.GameStatus.goldPerGame
                })]).then(i, i)
            },
            1500)
        },
        i.prototype.isAdvertisementAvailable = function() {
            if (Date.now() - t.GameStatus.lastAdvCoolDown < 1e3 * resultAdvConfigs.coolDownTime) return ! 1;
            var e = Math.random() < resultAdvConfigs.probability / 100;
            return e && (t.GameStatus.lastResultAdvCoolDown = Date.now()),
            e
        },
        i.prototype.show = function() {
            this.moveFromTop(this.coinPanel),
            this.settingBtn && this.moveFromTop(this.settingBtn),
            this.moveFromTop(this.choiceBackground)
        },
        i.prototype.changeState = function(i) {
            t.AdManager.instance.onAdDismissSignal.remove(this.advertisementDismissed, this),
            this.moveToTop(this.coinPanel),
            this.settingBtn && this.moveToTop(this.settingBtn),
            this.moveToTop(this.choiceBackground),
            this.advPanel && (this.moveToLeft(this.advPanel), this.moveToLeft(this.advText), this.moveToRight(this.advBtn)),
            this.moveToBottom(this.buttons),
            setTimeout(e.prototype.changeState.bind(this, i), t.Consts.ShowTime)
        },
        i.prototype.onSettingBtnClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i.prototype.addStatus = function() {
            this.choiceBackground = new t.ChoiceBackground(this.game, this.centerX, this.centerY - 100);
            var e = t.ShapeFactoryHelper.getShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.Medal, 0),
            i = t.ShapeFactoryHelper.getShape(this.game, 0, 0, t.ArtConsts.Items1, t.ArtConsts.Medal, 1);
            e.x = -this.choiceBackground.width / 2 + e.width + 45,
            i.x = e.x,
            e.y = -this.choiceBackground.height / 2 + e.height + 65,
            i.y = e.y + 1.5 * i.height,
            this.currentSilverNumber = 0,
            this.silverText = t.TextHelper.getText(this.game, e.x, e.y, t.StringFormatHelper.ThousandsSeparator(this.currentSilverNumber), "#FCE58D", t.Consts.resultNumbersFontWeight),
            this.silverText.anchor.set(0, .5),
            this.silverText.x += e.width,
            this.currentGoldNumber = 0,
            this.goldText = t.TextHelper.getText(this.game, i.x, i.y, t.StringFormatHelper.ThousandsSeparator(this.currentGoldNumber), "#FCE58D", t.Consts.resultNumbersFontWeight),
            this.goldText.anchor.set(0, .5),
            this.goldText.x += i.width,
            this.choiceBackground.addChild(e),
            this.choiceBackground.addChild(this.silverText),
            this.choiceBackground.addChild(i),
            this.choiceBackground.addChild(this.goldText),
            this.gameContainer.add(this.choiceBackground)
        },
        i.prototype.update = function() {
            var e = !1;
            this.currentGoldNumber + t.GameStatus.bestGoldPerGame / this.resultShowTime > t.GameStatus.bestGoldPerGame ? (this.currentGoldNumber = t.GameStatus.bestGoldPerGame, this.goldText.setText(t.StringFormatHelper.ThousandsSeparator(this.currentGoldNumber))) : this.currentGoldNumber < t.GameStatus.bestGoldPerGame && (this.currentGoldNumber += t.GameStatus.bestGoldPerGame / this.resultShowTime, this.goldText.setText(t.StringFormatHelper.ThousandsSeparator(this.currentGoldNumber)), this.prevGoldValue < Math.floor(this.currentGoldNumber) && (this.prevGoldValue = Math.floor(this.currentGoldNumber), e = !0)),
            this.currentSilverNumber + t.GameStatus.goldPerGame / this.resultShowTime > t.GameStatus.goldPerGame ? (this.currentSilverNumber = t.GameStatus.goldPerGame, this.silverText.setText(t.StringFormatHelper.ThousandsSeparator(this.currentSilverNumber))) : this.currentSilverNumber < t.GameStatus.goldPerGame && (this.currentSilverNumber += t.GameStatus.goldPerGame / this.resultShowTime, this.silverText.setText(t.StringFormatHelper.ThousandsSeparator(this.currentSilverNumber)), this.prevSilverValue < Math.floor(this.currentSilverNumber) && (this.prevSilverValue = Math.floor(this.currentSilverNumber), e = !0)),
            e && (this.isPlay ? (t.SoundController.instance.playSound(t.SoundConsts.CoinsCounting), this.isPlay = !1) : this.isPlay = !0)
        },
        i.prototype.addBottomButtons = function() {
            this.buttons = new Phaser.Group(this.game);
            var e = new t.Btn(this.game, 0, 0, t.BtnType.Home, this.onHomeClick.bind(this)),
            i = new t.Btn(this.game, 0, 0, t.BtnType.Play, this.onPlayClick.bind(this));
            e.x -= e.width,
            i.x += i.width,
            this.buttons.x = this.centerX,
            this.buttons.y = this.gameHeight - e.height,
            this.buttons.add(e),
            this.buttons.add(i),
            this.gameContainer.add(this.buttons)
        },
        i.prototype.onHomeClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i.prototype.onPlayClick = function() {
            this.changeState(t.WindowsConsts.ChooseHero)
        },
        i.prototype.addRewardedVideoPanel = function() {
            this.advPanel = t.ShapeFactoryHelper.getShape(this.game, this.centerX - 65, .7 * this.gameHeight, t.ArtConsts.Items1, t.ArtConsts.AdvPanel),
            this.advText = t.TextHelper.getText(this.game, this.advPanel.x - 125, this.advPanel.y + 25, "+" + t.GameStatus.goldPerGame, "#fff", 45),
            this.advBtn = new t.Btn(this.game, this.gameWidth - 5, this.advPanel.y + 25, t.BtnType.Adv, this.onRewardedVideoClicked.bind(this), !0),
            this.advBtn.x -= .5 * this.advBtn.width,
            this.advPanel.visible = this.advText.visible = this.advBtn.visible = !1,
            this.gameContainer.add(this.advPanel),
            this.gameContainer.add(this.advText),
            this.gameContainer.add(this.advBtn)
        },
        i.prototype.onRewardedVideoClicked = function() {
            var e = this;
            t.Consts.IsAndroid ? t.AdManager.instance.showRewardedAd(null) : t.AdManager.instance.showRewardedAd(function() {
                e.removeRewardedPanel(),
                e.doubleCoins()
            })
        },
        i.prototype.removeRewardedPanel = function() {
            this.game.add.tween(this.choiceBackground).to({
                y: this.centerY
            },
            300).start(),
            this.moveToLeft(this.advPanel),
            this.moveToLeft(this.advText),
            this.moveToRight(this.advBtn)
        },
        i.prototype.advertisementDismissed = function(e) {
            "rewardvideo" == e.adType ? (t.AdManager.instance.wasRecentRewardedVideoFinished() && this.doubleCoins(), this.removeRewardedPanel()) : e.adType
        },
        i.prototype.doubleCoins = function() {
            t.GameStatus.addGold(t.GameStatus.goldPerGame),
            t.GameStatus.gold += t.GameStatus.goldPerGame
        },
        i
    } (t.StateBase);
    t.Result = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function(e) {
        function i() {
            return null !== e && e.apply(this, arguments) || this
        }
        return __extends(i, e),
        i.prototype.create = function() {
            0 == t.Consts.IsAndroid && window.famobi_analytics.trackScreen(window.famobi_analytics.SCREEN_SHOP),
            e.prototype.create.call(this),
            this.addMenuTopPanel(this.onPrevBtn.bind(this)),
            this.initBottomButtons(),
            this.initTableItems(),
            this.show()
        },
        i.prototype.show = function() {
            this.showTopPanel(),
            this.moveFromLeft(this.cardHeart),
            this.moveFromLeft(this.cardHorseshoe, .5 * t.Consts.ShowTime),
            this.moveFromRight(this.cardLuck, .25 * t.Consts.ShowTime),
            this.moveFromRight(this.cardKey, .75 * t.Consts.ShowTime),
            this.moveFromBottom(this.playBtn)
        },
        i.prototype.changeState = function(i) {
            this.hideTopPanel(),
            this.moveToLeft(this.cardHeart, .75 * t.Consts.ShowTime),
            this.moveToLeft(this.cardHorseshoe, .25 * t.Consts.ShowTime),
            this.moveToRight(this.cardLuck, .5 * t.Consts.ShowTime),
            this.moveToRight(this.cardKey),
            this.moveToBottom(this.playBtn),
            setTimeout(e.prototype.changeState.bind(this, i), 1.75 * t.Consts.ShowTime)
        },
        i.prototype.onSettingBtnClick = function() {
            this.changeState(t.WindowsConsts.MainMenu)
        },
        i.prototype.update = function() {
            this.cardHeart.update(),
            this.updateAllChildren(this.cardHeart),
            this.cardHorseshoe.update(),
            this.updateAllChildren(this.cardHorseshoe),
            this.cardLuck.update(),
            this.updateAllChildren(this.cardLuck),
            this.cardKey.update(),
            this.updateAllChildren(this.cardKey)
        },
        i.prototype.updateStatus = function() {
            this.cardHeart.setStatus(),
            this.cardHorseshoe.setStatus(),
            this.cardLuck.setStatus(),
            this.cardKey.setStatus()
        },
        i.prototype.initBottomButtons = function() {
            this.playBtn = new t.Btn(this.game, this.centerX, 14 * this.gameHeight / 16, t.BtnType.Play, this.onPlayClick.bind(this), !0),
            this.gameContainer.add(this.playBtn)
        },
        i.prototype.onPrevBtn = function() {
            this.changeState(t.WindowsConsts.ChooseHero)
        },
        i.prototype.onPlayClick = function() {
            this.changeState(t.WindowsConsts.ChooseGameFormat)
        },
        i.prototype.initTableItems = function() {
            this.typeToShowAdv = this.getTypeToShowAdv(),
            this.cardHeart = this.initItem(0, 0, t.PriceConsts.Heart, t.ShopItemType.Heart, !0),
            this.cardHorseshoe = this.initItem(0, 0, t.PriceConsts.Horseshoe, t.ShopItemType.Horseshoe, !0),
            this.cardLuck = this.initItem(0, 0, t.PriceConsts.Luck, t.ShopItemType.Luck, !0),
            this.cardKey = this.initItem(0, 0, t.PriceConsts.Key, t.ShopItemType.Key, !0);
            this.cardHeart.x = this.centerX - .6 * this.cardHeart.width,
            this.cardHeart.y = this.centerY - .6 * this.cardHeart.height,
            this.cardHorseshoe.x = this.centerX - .6 * this.cardHorseshoe.width,
            this.cardHorseshoe.y = this.centerY + .6 * this.cardHorseshoe.height,
            this.cardLuck.x = this.centerX + .6 * this.cardLuck.width,
            this.cardLuck.y = this.centerY - .6 * this.cardLuck.height,
            this.cardKey.x = this.centerX + .6 * this.cardKey.width,
            this.cardKey.y = this.centerY + .6 * this.cardKey.height
        },
        i.prototype.initItem = function(e, i, o, n, s) {
            var a = new t.ShopCard(this.game, e, i, n, o, this.updateStatus.bind(this));
            s && a.scaleSprite();
            var r = 0;
            return this.typeToShowAdv == n && (r = shopAdvConfigs.probability),
            a.setStatus(r),
            this.gameContainer.add(a),
            a
        },
        i.prototype.getTypeToShowAdv = function() {
            if (!t.AdManager.instance.isRewardedVideoAvailable()) return 0;
            if (Date.now() - t.GameStatus.lastAdvCoolDown < 1e3 * shopAdvConfigs.coolDownTime) return 0;
            var e;
            do {
                e = this.game.rnd.integerInRange(t.ShopItemType.Heart, t.ShopItemType.Key)
            } while ( e == t . GameStatus . lastItemWithAdv );
            return t.GameStatus.lastItemWithAdv = e,
            t.GameStatus.lastAdvCoolDown = Date.now(),
            e
        },
        i
    } (t.StateBase);
    t.Shop = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {
            this.currentSoundVolume = 1,
            this.hadBeenMutedBeforePauseTriggered = !1,
            this.soundNames = [t.SoundConsts.Click, t.SoundConsts.Barrel1, t.SoundConsts.Barrel2, t.SoundConsts.Bomb, t.SoundConsts.BossAppearance, t.SoundConsts.Buy, t.SoundConsts.Cannon, t.SoundConsts.Card, t.SoundConsts.ChestOpening, t.SoundConsts.Coin, t.SoundConsts.CoinsBag, t.SoundConsts.CoinsCounting, t.SoundConsts.Health1, t.SoundConsts.Health2, t.SoundConsts.HeroDies, t.SoundConsts.Hit1, t.SoundConsts.Hit2, t.SoundConsts.Horseshoe, t.SoundConsts.Idol, t.SoundConsts.IncorrectClick, t.SoundConsts.Lighting, t.SoundConsts.Melody, t.SoundConsts.Move01, t.SoundConsts.Move02, t.SoundConsts.PickLockFail, t.SoundConsts.PickLockNeutral, t.SoundConsts.PickLockSuccess, t.SoundConsts.Poison, t.SoundConsts.Revive, t.SoundConsts.ShieldMetal, t.SoundConsts.ShieldWood, t.SoundConsts.Skull, t.SoundConsts.Trap]
        }
        return Object.defineProperty(e, "instance", {
            get: function() {
                return e._instance ? e._instance: e._instance = new e
            },
            enumerable: !0,
            configurable: !0
        }),
        e.prototype.isDecodingSupported = function() {
            return t.GameEngine.instance.sound.usingWebAudio
        },
        e.prototype.getSoundNames = function() {
            return this.soundNames
        },
        e.prototype.init = function() {
            if (t.Consts.IsAndroid) {
                var e = "true" === localStorage.getItem("soundsMuted");
                localStorage.setItem("soundsMuted", e),
                this.setVolume(e ? 0 : 1)
            } else {
                e = "true" === window.famobi.localStorage.getItem("soundsMuted");
                window.famobi.localStorage.setItem("soundsMuted", e),
                this.setVolume(e ? 0 : 1)
            }
        },
        e.prototype.startMusic = function() {
            this.mainTheme = t.GameEngine.instance.sound.play(t.SoundConsts.Melody, 1, !0),
            this.mainTheme.volume = this.getVolume(),
            t.GameEngine.instance.sound.usingWebAudio && "suspended" === t.GameEngine.instance.sound.context.state && t.GameEngine.instance.input.onTap.addOnce(function() {
                "suspended" === t.GameEngine.instance.sound.context.state && t.GameEngine.instance.sound.context.resume()
            })
        },
        e.prototype.pauseAudio = function() {
            this.hadBeenMutedBeforePauseTriggered = t.GameEngine.instance.sound.mute,
            t.GameEngine.instance.sound.mute = !0
        },
        e.prototype.resumeAudio = function() {
            t.GameEngine.instance.sound.mute = this.hadBeenMutedBeforePauseTriggered,
            t.GameEngine.instance.sound.usingWebAudio && ("suspended" === t.GameEngine.instance.sound.context.state || t.GameEngine.instance.device.iOS) && this.restoreSuspendedContext()
        },
        e.prototype.restoreSuspendedContext = function() {
            t.GameEngine.instance.input.onTap.addOnce(function() { ("suspended" === t.GameEngine.instance.sound.context.state || t.GameEngine.instance.device.iOS) && t.GameEngine.instance.sound.context.resume()
            })
        },
        e.prototype.getVolume = function() {
            return this.currentSoundVolume
        },
        e.prototype.setVolume = function(e) {
            this.currentSoundVolume = Phaser.Math.clamp(e, 0, 1),
            this.mainTheme && (this.mainTheme.volume = this.currentSoundVolume),
            t.Consts.IsAndroid ? localStorage.setItem("soundsMuted", 0 == this.currentSoundVolume) : window.famobi.localStorage.setItem("soundsMuted", 0 == this.currentSoundVolume)
        },
        e.prototype.isMuted = function() {
            return 0 == this.currentSoundVolume
        },
        e.prototype.playSound = function(e, i, o) {
            void 0 === i && (i = 1),
            void 0 === o && (o = !1),
            t.GameEngine.instance.sound.usingWebAudio && "suspended" === t.GameEngine.instance.sound.context.state || t.GameEngine.instance.sound.play(e, i * this.currentSoundVolume, o)
        },
        e._instance = null,
        e
    } ();
    t.SoundController = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.findNearestValue = function(t, e) {
            for (var i = Math.abs(e[0] - t), o = 0, n = 1; n < e.length; n++) {
                var s = Math.abs(e[n] - t);
                s < i && (o = n, i = s)
            }
            return e[o]
        },
        t
    } ();
    t.ArrayHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.setBackground = function(e, i) {
            var o = e.add.sprite(e.world.centerX, e.world.height, i);
            o.anchor.set(.5, 1),
            t.ScaleHelper.scaleContainerFit(o, o.width, o.height)
        },
        e.setBackgroundToGroup = function(i, o, n) {
            e.destroyPreviousBackground(o);
            var s = i.add.sprite(i.world.centerX, i.world.height + 140, n);
            s.anchor.set(.5, 1),
            t.ScaleHelper.scaleContainerFit(s, s.width, s.height),
            s.name = t.Consts.BackgroundImageName,
            o.add(s)
        },
        e.destroyPreviousBackground = function(e) {
            for (var i = 0; i < e.children.length; i++) if (e.children[i] instanceof Phaser.Image) {
                var o = e.children[i];
                if (o.name == t.Consts.BackgroundImageName) {
                    o.destroy();
                    break
                }
            }
        },
        e
    } ();
    t.BackgroundHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.getBtnBackgroundArtName = function(e) {
            switch (e) {
            case t.SpriteSize.Small:
                return t.ArtConsts.SmallBtnBackground;
            case t.SpriteSize.Big:
                return t.ArtConsts.BigBtnBackground;
            default:
                throw new Error("Not implemented yet")
            }
        },
        e.getBtnSize = function(e) {
            switch (e) {
            case t.BtnType.Home:
            case t.BtnType.Next:
            case t.BtnType.Prev:
            case t.BtnType.Play:
            case t.BtnType.Plus:
            case t.BtnType.Group:
            case t.BtnType.Sound:
            case t.BtnType.Resume:
            case t.BtnType.Control:
            case t.BtnType.Adv:
                return t.SpriteSize.Big;
            case t.BtnType.Pause:
            case t.BtnType.Settings:
            case t.BtnType.HomeSmall:
            case t.BtnType.PrevSmall:
            case t.BtnType.I:
                return t.SpriteSize.Small;
            default:
                throw new Error("Not implemented yet")
            }
        },
        e.getBtnArtName = function(e) {
            switch (e) {
            case t.BtnType.Sound:
                return t.ArtConsts.SoundBtn;
            case t.BtnType.Home:
                return t.ArtConsts.HomeBtn;
            case t.BtnType.Pause:
                return t.ArtConsts.PauseBtn;
            case t.BtnType.Group:
                return t.ArtConsts.GroupBtn;
            case t.BtnType.Next:
                return t.ArtConsts.NextBtn;
            case t.BtnType.Prev:
                return t.ArtConsts.PrevBtn;
            case t.BtnType.Play:
                return t.ArtConsts.PlayBtn;
            case t.BtnType.Plus:
                return t.ArtConsts.PlusBtn;
            case t.BtnType.Resume:
                return t.ArtConsts.ResumeBtn;
            case t.BtnType.Settings:
                return t.ArtConsts.SettingsBtn;
            case t.BtnType.Control:
                return t.ArtConsts.ControlBtn;
            case t.BtnType.HomeSmall:
                return t.ArtConsts.HomeSmallBtn;
            case t.BtnType.PrevSmall:
                return t.ArtConsts.PrevBtn;
            case t.BtnType.Adv:
                return t.ArtConsts.AdvPlayBtn;
            case t.BtnType.I:
                return t.ArtConsts.IBtn;
            default:
                throw new Error("Not implemented yet")
            }
        },
        e.alignIconCenter = function(e, i) {
            switch (i) {
            case t.BtnType.Play:
                e.x += 7,
                e.y += 2;
                break;
            case t.BtnType.Group:
            case t.BtnType.Sound:
                e.y += 2;
                break;
            case t.BtnType.Pause:
                e.x -= 2,
                e.y -= 2;
                break;
            case t.BtnType.Next:
                e.x += 3,
                e.y += 3;
                break;
            case t.BtnType.Prev:
                e.y += 3;
                break;
            case t.BtnType.Plus:
                e.x += 2,
                e.y += 1;
                break;
            case t.BtnType.HomeSmall:
                e.y -= 2;
                break;
            case t.BtnType.PrevSmall:
                e.x -= 2;
                break;
            case t.BtnType.I:
                e.x -= 4,
                e.y -= 4
            }
        },
        e.scaleIcon = function(e, i) {
            switch (i) {
            case t.BtnType.HomeSmall:
                e.scale.set(.9);
                break;
            case t.BtnType.PrevSmall:
                e.scale.set(.8)
            }
        },
        e
    } ();
    t.BtnHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.getFrame = function(t) {
            return t < 10 ? "000" + t: t >= 10 && t < 100 ? "00" + t: t >= 100 && t < 1e3 ? "0" + t: t.toString()
        },
        t
    } ();
    t.FrameHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.getHeroPrice = function(e) {
            switch (e) {
            case t.HeroType.Key:
                return t.PriceConsts.HeroKey;
            case t.HeroType.Gun:
                return t.PriceConsts.HeroGun;
            case t.HeroType.Bomb:
                return t.PriceConsts.HeroBomb;
            default:
                throw new Error("Not implemented yet")
            }
        },
        e
    } ();
    t.PriceHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.getRandomIntInclusive = function(t, e) {
            return t = Math.ceil(t),
            e = Math.floor(e),
            Math.floor(Math.random() * (e - t + 1)) + t
        },
        t.getRandomBool = function() {
            return Math.random() >= .5
        },
        t.shuffle = function(t) {
            for (var e, i, o = t.length; 0 !== o;) i = Math.floor(Math.random() * o),
            e = t[o -= 1],
            t[o] = t[i],
            t[i] = e;
            return t
        },
        t
    } ();
    t.RandomHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.scaleContainer = function(e, i, o) {
            var n = t.GameEngine.instance.width,
            s = t.GameEngine.instance.height,
            a = Math.min(n / i, s / o);
            e.scale.set(a, a),
            e.x = .5 * (n - i * a),
            e.y = .5 * (s - o * a)
        },
        e.scaleContainerFit = function(e, i, o) {
            var n = t.GameEngine.instance.width + 200,
            s = t.GameEngine.instance.height + 200,
            a = Math.max(n / i, s / o);
            e.scale.set(a, a)
        },
        e
    } ();
    t.ScaleHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.getShape = function(e, i, o, n, s, a) {
            void 0 === a && (a = 0);
            var r = new Phaser.Sprite(e, i, o, n, s + t.FrameHelper.getFrame(a));
            return r.anchor.set(.5, .5),
            e.world.add(r),
            r
        },
        e.getShakeShape = function(e, i, o, n, s, a, r, h) {
            void 0 === a && (a = 0),
            void 0 === r && (r = !1),
            void 0 === h && (h = t.RandomHelper.getRandomIntInclusive(0, 200));
            var d = new t.SpriteShakeBase(e, i, o, n, s + t.FrameHelper.getFrame(a), r, h);
            return d.anchor.set(.5, .5),
            e.world.add(d),
            d
        },
        e
    } ();
    t.ShapeFactoryHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.ThousandsSeparator = function(t) {
            return t.toFixed(0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
        },
        t
    } ();
    t.StringFormatHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function t() {}
        return t.getText = function(t, e, i, o, n, s) {
            var a = new Phaser.Text(t, e, i, o, {
                font: s + "px Dosis-SemiBold",
                wordWrap: !0,
                wordWrapWidth: 1e3,
                align: "center"
            });
            return a.stroke = "#3F1F1F",
            a.strokeThickness = 5,
            a.anchor.setTo(.5, .5),
            a.addColor(n, 0),
            t.world.addChild(a),
            a
        },
        t
    } ();
    t.TextHelper = e
} (CardsMatch || (CardsMatch = {})),
function(t) {
    var e = function() {
        function e() {}
        return e.turnAnimationStart = function(e, i) {
            return e.add.tween(i.scale).to({
                x: t.Consts.ScaleZoom,
                y: t.Consts.ScaleZoom
            },
            t.Consts.ScaleSpeed).to({
                x: .1,
                y: t.Consts.FlipZoom
            },
            t.Consts.FlipSpeed / 2)
        },
        e.turnAnimationEnd = function(e, i) {
            return e.add.tween(i.scale).to({
                x: t.Consts.ScaleZoom,
                y: t.Consts.ScaleZoom
            },
            t.Consts.FlipSpeed / 2).to({
                x: 1,
                y: 1
            },
            t.Consts.ScaleSpeed)
        },
        e.scaleIn = function(e, i, o) {
            void 0 === o && (o = !0);
            var n = e.add.tween(i.scale).to({
                x: 0,
                y: 0
            },
            .25 * t.Consts.ShowTime, null, o);
            return n.onStart.add(function() {
                i.inputEnabled = !1
            }),
            n.onComplete.add(function() {
                i.scale.set(1),
                i.visible = !1,
                i.inputEnabled = !0
            }),
            n
        },
        e.scaleOut = function(e, i, o) {
            return void 0 === o && (o = 1),
            i.scale.set(0),
            i.visible = !0,
            i.inputEnabled = !0,
            e.add.tween(i.scale).to({
                x: o,
                y: o
            },
            .25 * t.Consts.ShowTime)
        },
        e
    } ();
    t.TweenHelper = e
} (CardsMatch || (CardsMatch = {}));

new CardsMatch.GameEngine()