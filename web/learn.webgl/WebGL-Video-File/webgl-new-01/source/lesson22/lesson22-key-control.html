<html>
<head>
    <title>lesson22-key-control</title>
    <meta http-equiv="content-type" content="text/html; charset=gb2312">
    
    <script type ="text/javascript" src="glMatrix-0.9.6.min.js"></script>
    <script id="shader-vs" type="x-shader/x-fragment">
        
        attribute   vec3    v3Position;
        attribute   vec4    inColor;
        attribute   vec2    inUV;
        uniform     mat4    proj;
        varying     vec4    outColor;
        varying     vec2    outUV;

        void main()
        {
            gl_Position =   proj * vec4(v3Position, 1.0);
            outColor    =   inColor;
            outUV       =   inUV;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision   mediump float;
        varying     vec4        outColor;
        varying     vec2        outUV;
        uniform     sampler2D   texture;
        void main(void)
        {
            gl_FragColor = texture2D(texture,outUV) * outColor;
        }
    </script>

    <script>

        var webgl = null;
        var vertexShaderObject = null;
        var fragmentShaderObject = null;
        var programObject = null;
        var triangleBuffer = null;

        var v3PositionIndex = 0;
        var attrColor = 0;
        var attrUV = 0;

        var uniformProj = 0;
        var uniformTexture = 0;
        var textureHandle;



        var projectMat = mat4.create();


        function getShaderSource(scriptID) {
            var shaderScript = document.getElementById(scriptID);
            if (shaderScript == null) return "";

            var sourceCode = "";
            var child = shaderScript.firstChild;
            while (child) {
                if (child.nodeType == child.TEXT_NODE) sourceCode += child.textContent;
                child = child.nextSibling;
            }

            return sourceCode;
        }

        /**
        *   初始化,完成资源的加载.
        */
        function init() {

            var canvas = document.getElementById('myCanvas');
            webgl = canvas.getContext("webgl");

            webgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);

            //mat4.ortho(0, canvas.clientWidth, canvas.clientHeight, 0, -1.0, 1.0, projectMat);
            mat4.perspective(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0, projectMat);

            vertexShaderObject = webgl.createShader(webgl.VERTEX_SHADER);
            fragmentShaderObject = webgl.createShader(webgl.FRAGMENT_SHADER);

            webgl.shaderSource(vertexShaderObject, getShaderSource("shader-vs"));
            webgl.shaderSource(fragmentShaderObject, getShaderSource("shader-fs"));

            webgl.compileShader(vertexShaderObject);
            webgl.compileShader(fragmentShaderObject);

            if (!webgl.getShaderParameter(vertexShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(vertexShaderObject);
                alert(err);
                return;
            }
            if (!webgl.getShaderParameter(fragmentShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(fragmentShaderObject);
                alert(err);
                return;
            }

            programObject = webgl.createProgram();

            webgl.attachShader(programObject, vertexShaderObject);
            webgl.attachShader(programObject, fragmentShaderObject);

            webgl.linkProgram(programObject);
            if (!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) {
                alert("error:programObject");
                return;
            }

            webgl.useProgram(programObject);

            uniformProj     =   webgl.getUniformLocation(programObject, "proj");
            uniformTexture  =   webgl.getUniformLocation(programObject, "texture");

            v3PositionIndex =   webgl.getAttribLocation(programObject, "v3Position");

            attrColor       =   webgl.getAttribLocation(programObject, "inColor");
            attrUV          =   webgl.getAttribLocation(programObject, "inUV");

            var  boxVertex  =
            [       //x     y     z     u    v      r    g    b    a
                    -1.0 ,-1.0 , 1.0 ,  0.0 ,0.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,
                     1.0 ,-1.0 , 1.0 ,  1.0 ,0.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  1.0 ,1.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,

                    -1.0 ,-1.0 , 1.0 ,  0.0 ,0.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  1.0 ,1.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,
                    -1.0 , 1.0 , 1.0 ,  0.0 ,1.0 ,  1.0 ,1.0 ,1.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  1.0 ,0.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,
                    -1.0 , 1.0 ,-1.0 ,  1.0 ,1.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 ,-1.0 ,  0.0 ,1.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  1.0 ,0.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 ,-1.0 ,  0.0 ,1.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,
                     1.0 ,-1.0 ,-1.0 ,  0.0 ,0.0 ,  1.0 ,0.0 ,0.0 ,1.0 ,

                    -1.0 , 1.0 ,-1.0 ,  0.0 ,1.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,
                    -1.0 , 1.0 , 1.0 ,  0.0 ,0.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  1.0 ,0.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,

                    -1.0 , 1.0 ,-1.0 ,  0.0 ,1.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  1.0 ,0.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 ,-1.0 ,  1.0 ,1.0 ,  0.0 ,1.0 ,0.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  1.0 ,1.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,
                     1.0 ,-1.0 ,-1.0 ,  0.0 ,1.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,
                     1.0 ,-1.0 , 1.0 ,  0.0 ,0.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  1.0 ,1.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,
                     1.0 ,-1.0 , 1.0 ,  0.0 ,0.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,
                    -1.0 ,-1.0 , 1.0 ,  1.0 ,0.0 ,  0.0 ,0.0 ,1.0 ,1.0 ,

                     1.0 ,-1.0 ,-1.0 ,  1.0 ,0.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 ,-1.0 ,  1.0 ,1.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  0.0 ,1.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,

                     1.0 ,-1.0 ,-1.0 ,  1.0 ,0.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 , 1.0 , 1.0 ,  0.0 ,1.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,
                     1.0 ,-1.0 , 1.0 ,  0.0 ,0.0 ,  1.0 ,1.0 ,0.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  0.0 ,0.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,
                    -1.0 ,-1.0 , 1.0 ,  1.0 ,0.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,
                    -1.0 , 1.0 , 1.0 ,  1.0 ,1.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,

                    -1.0 ,-1.0 ,-1.0 ,  0.0 ,0.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,
                    -1.0 , 1.0 , 1.0 ,  1.0 ,1.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,
                    -1.0 , 1.0 ,-1.0 ,  0.0 ,1.0 ,  0.0 ,1.0 ,1.0 ,1.0 ,
                ];
            triangleBuffer = webgl.createBuffer();
            webgl.bindBuffer(webgl.ARRAY_BUFFER, triangleBuffer);
            webgl.bufferData(webgl.ARRAY_BUFFER, new Float32Array(boxVertex), webgl.STATIC_DRAW);

            textureHandle   =   initTexture("test.gif");
        }

        function handleLoadedTexture(texture) {
            webgl.bindTexture(webgl.TEXTURE_2D, texture);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, webgl.RGBA, webgl.UNSIGNED_BYTE, texture.image);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);

            webgl.bindTexture(webgl.TEXTURE_2D, null);
        }
        function initTexture(imageFile) {
            var texture;
            //! 创建一个纹理 webgl
            texture = webgl.createTexture();
            //! 创建一个图片
            texture.image = new Image();
            //! 指定图片的路径
            texture.image.src = imageFile;
            texture.image.onload = function () {
                handleLoadedTexture(texture)
            }
            return texture;

        }


        var rPyramid = 0;
        var varTransZ = 0;
        var varTransX = 0;
        var varRot = 0;
        var varScale = 1;
        function handleKeyDown(event) {


            if (String.fromCharCode(event.keyCode) == 'W') {
                varTransZ -= 1;
            }
            else if (String.fromCharCode(event.keyCode) == 'S')
            {
                varTransZ += 1;
            }
            else if (String.fromCharCode(event.keyCode) == 'A') {
                varTransX -= 1;
            }
            else if (String.fromCharCode(event.keyCode) == 'D') {
                varTransX += 1;
            }
            else if (String.fromCharCode(event.keyCode) == 'R') {
                varRot += 1;
            }

            else if (String.fromCharCode(event.keyCode) == 'Z') {
                varScale += 0.1;
            }
            else if (String.fromCharCode(event.keyCode) == 'X') {
                varScale -= 0.1;
            }

        }

        function handleKeyUp(event) {
        }


        function webGLStart() {

            document.onkeydown  =   handleKeyDown;
            document.onkeyup    =   handleKeyUp;

            //! 初始化
            init();
            //! 进入游戏循环
            tick();
        }

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }
        
        function renderScene() {

            //! 设置重绘背景的颜色
            webgl.clearColor(0.0, 0.0, 0.0, 1.0);
            //! 执行绘制，即将背景清空成制定的颜色(clearColor)
            webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            webgl.enable(webgl.DEPTH_TEST);
            //! 指定绘制所使用的顶点数据 从 该缓冲区中获取
            webgl.bindBuffer(webgl.ARRAY_BUFFER, triangleBuffer);

          
            var mvp         =   mat4.create();
            var matTrans    =   mat4.create();
            var matRot      =   mat4.create();
            var matScale    =   mat4.create();
            var matModel    =   mat4.create();
            var matAll      =   mat4.create();


            mat4.identity(matTrans);
            mat4.identity(matRot);
            mat4.identity(matModel);
            mat4.identity(matScale);
            mat4.identity(matAll);

            webgl.activeTexture(webgl.TEXTURE0);
            webgl.bindTexture(webgl.TEXTURE_2D, textureHandle);
            webgl.uniform1i(uniformTexture, 0);


            mat4.translate(matTrans, [varTransX, 0.0, varTransZ]);
            mat4.rotate(matRot, degToRad(varRot), [1.0, 1.0, 1.0]);

            mat4.multiply(matTrans, matRot, matModel);

            mat4.scale(matScale, [varScale, 1, 1], matScale);

            mat4.multiply(matModel, matScale, matAll);

            mat4.multiply(projectMat, matAll, mvp);

            webgl.uniformMatrix4fv(uniformProj, false, mvp);

            webgl.enableVertexAttribArray(v3PositionIndex);
            webgl.enableVertexAttribArray(attrColor);
            webgl.enableVertexAttribArray(attrUV);

            webgl.vertexAttribPointer(v3PositionIndex,  3,  webgl.FLOAT, false, 4 * 9, 0);
            webgl.vertexAttribPointer(attrUV,           2,  webgl.FLOAT, false, 4 * 9, 4*3);
            webgl.vertexAttribPointer(attrColor,        4,  webgl.FLOAT, false, 4 * 9, 4 * 5);

            webgl.drawArrays(webgl.TRIANGLES, 0, 36);
        }


        function tick() {
            requestAnimFrame(tick);
            renderScene();

        }


        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                   window.webkitRequestAnimationFrame ||
                   window.mozRequestAnimationFrame ||
                   window.oRequestAnimationFrame ||
                   window.msRequestAnimationFrame ||
                   function (callback, element) {
                       window.setTimeout(callback, 1000 / 60);
                   };
        })();

    </script>
</head>
<body onload='webGLStart()'>
    <canvas id="myCanvas" style="border: 1px solid red;" width='600' height='600'></canvas>
</body>
</html>
