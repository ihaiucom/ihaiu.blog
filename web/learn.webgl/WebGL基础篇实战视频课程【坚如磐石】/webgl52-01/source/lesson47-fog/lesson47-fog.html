<html>
<head>
    <title>lesson47-实现雾效果</title>
    <meta http-equiv="content-type" content="text/html; charset=gb2312">
    
    <script type ="text/javascript" src="glMatrix-0.9.6.min.js"></script>
    <script id="shader-vs" type="x-shader/x-fragment">
        
        attribute vec3  position;
        attribute vec3  normal;
        attribute vec4  color;
        uniform   mat4  mMatrix;
        uniform   mat4  mvpMatrix;
        uniform   mat4  invMatrix;
        uniform   vec3  lightDirection;
        uniform   vec3  eyePosition;
        uniform   vec4  ambientColor;
        uniform   float fogStart;
        uniform   float fogEnd;
        varying   vec4  vColor;
        varying   float fogFactor;


        void main(void){
	        vec3  invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;
	        vec3  invEye   = normalize(invMatrix * vec4(eyePosition, 0.0)).xyz;
	        vec3  halfLE   = normalize(invLight + invEye);
	        float diffuse  = clamp(dot(normal, invLight), 0.1, 1.0);
	        float specular = pow(clamp(dot(normal, halfLE), 0.0, 1.0), 50.0);
	        vec4  amb      = color * ambientColor;
	        vColor         = amb * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0);
        	
	        vec3  pos      = (mMatrix * vec4(position, 1.0)).xyz;
	        float linerPos = length(eyePosition - pos) /30.0;
	        fogFactor      = clamp((fogEnd - linerPos) / (fogEnd - fogStart), 0.0, 1.0);
        	
	        gl_Position    = mvpMatrix * vec4(position, 1.0);
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec4  fogColor;
        varying vec4  vColor;
        varying float fogFactor;

        void main(void)
        {
	        gl_FragColor = mix(fogColor, vColor, fogFactor);
        }
    </script>

    <script>

        var webgl = null;
        var vertexShaderObject      = null;
        var fragmentShaderObject    = null;
        var programObject           = null;
        var attLocation             = new   Array();
        var uniLocation             = new   Array();
        var count   =   0;
        var canvas  =   null;
        var index = null;

        var eRangeFogStart = null;
        var eRangeFogEnd = null; 
        
        function getShaderSource(scriptID) 
        {
            var shaderScript = document.getElementById(scriptID);
            if (shaderScript == null) return "";

            var sourceCode = "";
            var child = shaderScript.firstChild;
            while (child) 
            {
                if (child.nodeType == child.TEXT_NODE) sourceCode += child.textContent;
                child = child.nextSibling;
            }

            return sourceCode;
        }

        // VBO 生成
        function create_vbo(data)
        {
            var vbo = webgl.createBuffer();
            webgl.bindBuffer(webgl.ARRAY_BUFFER, vbo);
            webgl.bufferData(webgl.ARRAY_BUFFER, new Float32Array(data), webgl.STATIC_DRAW);
            webgl.bindBuffer(webgl.ARRAY_BUFFER, null);
            return vbo;
        }


        // Index Buffer Object 生成
        function create_ibo(data) 
        {
            var ibo = webgl.createBuffer();
            webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
            webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), webgl.STATIC_DRAW);
            webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, null);
            return ibo;
        }

        function torus(row, column, irad, orad) 
        {
            var pos = new Array(), nor = new Array(),
		    col = new Array(), idx = new Array();
            for (var i = 0; i <= row; i++) {
                var r = Math.PI * 2 / row * i;
                var rr = Math.cos(r);
                var ry = Math.sin(r);
                for (var ii = 0; ii <= column; ii++) {
                    var tr = Math.PI * 2 / column * ii;
                    var tx = (rr * irad + orad) * Math.cos(tr);
                    var ty = ry * irad;
                    var tz = (rr * irad + orad) * Math.sin(tr);
                    var rx = rr * Math.cos(tr);
                    var rz = rr * Math.sin(tr);
                    pos.push(tx, ty, tz);
                    nor.push(rx, ry, rz);
                    var tc = hsva(360 / column * ii, 1, 1, 1);
                    col.push(tc[0], tc[1], tc[2], tc[3]);
                }
            }
            for (i = 0; i < row; i++) {
                for (ii = 0; ii < column; ii++) {
                    r = (column + 1) * i + ii;
                    idx.push(r, r + column + 1, r + 1);
                    idx.push(r + column + 1, r + column + 2, r + 1);
                }
            }
            return [pos, nor, col, idx];
        }

        function hsva(h, s, v, a) 
        {
            if (s > 1 || v > 1 || a > 1) { return; }
            var th = h % 360;
            var i = Math.floor(th / 60);
            var f = th / 60 - i;
            var m = v * (1 - s);
            var n = v * (1 - s * f);
            var k = v * (1 - s * (1 - f));
            var color = new Array();
            if (!s > 0 && !s < 0) {
                color.push(v, v, v, a);
            } else {
                var r = new Array(v, n, m, m, k, v);
                var g = new Array(k, v, v, n, m, m);
                var b = new Array(m, m, k, v, v, n);
                color.push(r[i], g[i], b[i], a);
            }
            return color;
  
        }
        /**
        *   初始化,完成资源的加载.
        */
        function init() 
        {

            
            //! 获取控件
            eRangeFogStart  =   document.getElementById('fogStart');
            eRangeFogEnd    =   document.getElementById('fogEnd');
            canvas          =   document.getElementById('myCanvas');
            webgl           =   canvas.getContext("webgl");
            

            webgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
           

            vertexShaderObject      =   webgl.createShader(webgl.VERTEX_SHADER);
            fragmentShaderObject    =   webgl.createShader(webgl.FRAGMENT_SHADER);

            webgl.shaderSource(vertexShaderObject, getShaderSource("shader-vs"));
            webgl.shaderSource(fragmentShaderObject, getShaderSource("shader-fs"));

            webgl.compileShader(vertexShaderObject);
            webgl.compileShader(fragmentShaderObject);

            if (!webgl.getShaderParameter(vertexShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(vertexShaderObject);
                alert(err);
                return;
            }
            if (!webgl.getShaderParameter(fragmentShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(fragmentShaderObject);
                alert(err);
                return;
            }
            
            programObject = webgl.createProgram();

            webgl.attachShader(programObject, vertexShaderObject);
            webgl.attachShader(programObject, fragmentShaderObject);

            webgl.linkProgram(programObject);
            if (!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) {
                alert("error:programObject");
                return;
            }

            webgl.useProgram(programObject);

            attLocation[0] = webgl.getAttribLocation(programObject, 'position');
            attLocation[1] = webgl.getAttribLocation(programObject, 'normal');
            attLocation[2] = webgl.getAttribLocation(programObject, 'color');
            


            uniLocation[0] = webgl.getUniformLocation(programObject, 'mvpMatrix');
            uniLocation[0] = webgl.getUniformLocation(programObject, 'mMatrix');
            uniLocation[1] = webgl.getUniformLocation(programObject, 'mvpMatrix');
            uniLocation[2] = webgl.getUniformLocation(programObject, 'invMatrix');
            uniLocation[3] = webgl.getUniformLocation(programObject, 'lightDirection');
            uniLocation[4] = webgl.getUniformLocation(programObject, 'eyePosition');
            uniLocation[5] = webgl.getUniformLocation(programObject, 'ambientColor');
            uniLocation[6] = webgl.getUniformLocation(programObject, 'fogStart');
            uniLocation[7] = webgl.getUniformLocation(programObject, 'fogEnd');
            uniLocation[8] = webgl.getUniformLocation(programObject, 'fogColor');


            webgl.enable(webgl.DEPTH_TEST);

            var torusData   =   torus(64, 64, 0.75, 1.75, [1.0, 1.0, 1.0, 1.0]);
            var position    =   torusData[0];
            var normal      =   torusData[1];
            var color       =   torusData[2];
                index       =   torusData[3];


            var vPosition   =   create_vbo(position);
            var vNormal     =   create_vbo(normal);
            var vColor      =   create_vbo(color);
            

            webgl.bindBuffer(webgl.ARRAY_BUFFER, vPosition);
            webgl.enableVertexAttribArray(attLocation[0]);
            webgl.vertexAttribPointer(attLocation[0], 3, webgl.FLOAT, false, 0, 0);


            webgl.bindBuffer(webgl.ARRAY_BUFFER, vNormal);
            webgl.enableVertexAttribArray(attLocation[1]);
            webgl.vertexAttribPointer(attLocation[1], 3, webgl.FLOAT, false, 0, 0);
            

            webgl.bindBuffer(webgl.ARRAY_BUFFER, vColor);
            webgl.enableVertexAttribArray(attLocation[2]);
            webgl.vertexAttribPointer(attLocation[2], 4, webgl.FLOAT, false, 0, 0);



            var ibo = create_ibo(index);
            webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
        }
        function handleKeyDown(event) {
        }

        function handleKeyUp(event) {
        }


        function webGLStart() {

            document.onkeydown  =   handleKeyDown;
            document.onkeyup    =   handleKeyUp;

            //! 初始化
            init();
            //! 进入循环
            tick();
        }

        var count = 0;
        function renderScene() {

            webgl.enable(webgl.DEPTH_TEST);
            webgl.depthFunc(webgl.LEQUAL);
            webgl.enable(webgl.CULL_FACE);
            //! 设置重绘背景的颜色
            webgl.clearColor(0.75, 0.75, 0.75, 1.0);
            webgl.clearDepth(1.0);
            webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
           

            var mMatrix     =   mat4.identity(mat4.create());
	        var vMatrix     =   mat4.identity(mat4.create());
	        var pMatrix     =   mat4.identity(mat4.create());
	        var tmpMatrix   =   mat4.identity(mat4.create());
	        var mvpMatrix   =   mat4.identity(mat4.create());
	        var invMatrix   =   mat4.identity(mat4.create());

	        mat4.lookAt([0.0, 0.0, -15.0], [0, 0, 0], [0, 1, 0], vMatrix);
	        mat4.perspective(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0, pMatrix);
	        mat4.multiply(pMatrix, vMatrix, tmpMatrix);

	        var fogStart    = eRangeFogStart.value * 0.01;
	        var fogEnd      = eRangeFogEnd.value * 0.01;
	        
	        var rad = new Array();
	        for (var i = 0; i < 9; i++) {
	            rad[i] = ((count + 40 * i) % 360) * Math.PI / 180;
	        }
	        count++;
	        // 平行光方向
	        var lightDirection = [-0.577, 0.577, 0.577];
        	
	        // 点
	        var eyePosition = [0.0, 0.0, -15.0];
        	
	        // 环境光颜色
	        var ambientColor = [0.1, 0.1, 0.1, 1.0];


	        for (i = 0; i < 9; i++)
	         {
	            var amb = hsva(i * 40, 1, 1, 1);
	            mat4.identity(mMatrix);
	            mat4.rotate(mMatrix, i * 40 * Math.PI / 180, [0, 1, 0], mMatrix);
	            mat4.translate(mMatrix, [0.0, 0.0, 10.0], mMatrix);
	            mat4.rotate(mMatrix, rad[i], [1, 1, 0], mMatrix);
	            mat4.multiply(tmpMatrix, mMatrix, mvpMatrix);
	            mat4.inverse(mMatrix, invMatrix);
	            webgl.uniformMatrix4fv(uniLocation[0], false, mMatrix);
	            webgl.uniformMatrix4fv(uniLocation[1], false, mvpMatrix);
	            webgl.uniformMatrix4fv(uniLocation[2], false, invMatrix);
	            webgl.uniform3fv(uniLocation[3], lightDirection);
	            webgl.uniform3fv(uniLocation[4], eyePosition);
	            webgl.uniform4fv(uniLocation[5], amb);
	            webgl.uniform1f(uniLocation[6], fogStart);
	            webgl.uniform1f(uniLocation[7], fogEnd);
	            webgl.uniform4fv(uniLocation[8], [0.75, 0.75, 0.75, 1.0]);
	            webgl.drawElements(webgl.TRIANGLES, index.length, webgl.UNSIGNED_SHORT, 0);
	        }
            
        }


        function tick() 
        {
            requestAnimFrame(tick);
            renderScene();
        }

        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                   window.webkitRequestAnimationFrame ||
                   window.mozRequestAnimationFrame ||
                   window.oRequestAnimationFrame ||
                   window.msRequestAnimationFrame ||
                   function (callback, element) {
                       window.setTimeout(callback, 1000 / 60);
                   };
        })();

    </script>
</head>
<body onload='webGLStart()'>
    <canvas id="myCanvas" style="border: 1px solid red;" width='600' height='600'></canvas>
    <p><input id="fogStart" type="range" value="50" min="0" max="100">fogStart</p>
    <p><input id="fogEnd" type="range" value="100" min="0" max="100">fogEnd</p>
</body>
</html>
