<html>
<head>
    <title>lessom-13:webgl-point Sprite</title>
    <meta http-equiv="content-type" content="text/html; charset=gb2312">
    
    <script type ="text/javascript" src="glMatrix-0.9.6.min.js"></script>
    <script id="shader-vs" type="x-shader/x-fragment">
        
            uniform   float _pointSize;
            attribute vec2  _position;
            void main()
            {
	            gl_Position  = vec4(_position, 0.0, 1.0);
	            gl_PointSize = _pointSize;
            }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 _pointColor;
        void main()
        {
	        gl_FragColor = _pointColor;
        }
    </script>

    <script>

        var     canvas              =   null;
        var     webgl               =   null;
        var     vertexShaderObject  =   null;
        var     fragmentShaderObject=   null;
        var     programObject       =   null;
        var     triangleBuffer      =   null;
        
        var     _pointColor;
        var     _pointSize;
        var     _attrPosition;

        var     count           =   0;
        var     velocity        =   0.0;
        var     MAX_VELOCITY    =   2.0;
        var     SPEED           =   0.02;
        var     pointPosition   =   null;


        var     position = [];
        var     vector = [];
        var     resolutionX = 100;
        var     resolutionY = 100;
        var     intervalX = 1.0 / resolutionX;
        var     intervalY = 1.0 / resolutionY;
        var     verticesCount = resolutionX * resolutionY;
        
        var mouseFlag       =   false;
        var mousePositionX  =   0.0; //（-1.0 - 1.0）
        var mousePositionY  =   0.0; // （-1.0 - 1.0）
        var projectMat = mat4.create();


        function getShaderSource(scriptID) {
            var shaderScript = document.getElementById(scriptID);
            if (shaderScript == null) return "";

            var sourceCode = "";
            var child = shaderScript.firstChild;
            while (child) {
                if (child.nodeType == child.TEXT_NODE) sourceCode += child.textContent;
                child = child.nextSibling;
            }

            return sourceCode;
        }

        /**
        *   初始化,完成资源的加载.
        */
        function init() {

            canvas  =   document.getElementById('myCanvas');
            webgl   =   canvas.getContext("webgl");

            webgl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);

            canvas.addEventListener('mousedown', mouseDown, true);
            canvas.addEventListener('mouseup', mouseUp, true);
            canvas.addEventListener('mousemove', mouseMove, true);
            //mat4.ortho(0, canvas.clientWidth, canvas.clientHeight, 0, -1.0, 1.0, projectMat);


            vertexShaderObject = webgl.createShader(webgl.VERTEX_SHADER);
            fragmentShaderObject = webgl.createShader(webgl.FRAGMENT_SHADER);

            webgl.shaderSource(vertexShaderObject, getShaderSource("shader-vs"));
            webgl.shaderSource(fragmentShaderObject, getShaderSource("shader-fs"));

            webgl.compileShader(vertexShaderObject);
            webgl.compileShader(fragmentShaderObject);

            if (!webgl.getShaderParameter(vertexShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(vertexShaderObject);
                alert(err);
                return;
            }
            if (!webgl.getShaderParameter(fragmentShaderObject, webgl.COMPILE_STATUS)) {
                var err = webgl.getShaderInfoLog(fragmentShaderObject);
                alert(err);
                return;
            }

            programObject = webgl.createProgram();

            webgl.attachShader(programObject, vertexShaderObject);
            webgl.attachShader(programObject, fragmentShaderObject);

            webgl.linkProgram(programObject);
            if (!webgl.getProgramParameter(programObject, webgl.LINK_STATUS)) {
                alert("error:programObject");
                return;
            }

            webgl.useProgram(programObject);

            _pointColor     =   webgl.getUniformLocation(programObject, "_pointColor");
            _pointSize      =   webgl.getUniformLocation(programObject, "_pointSize");
            _attrPosition   =   webgl.getAttribLocation(programObject, "_position");

            
            var i, j, x, y;
            for (i = 0; i < resolutionX; i++) 
            {
                for (j = 0; j < resolutionY; j++) 
                {
                    x = i * intervalX * 2.0 - 1.0;
                    y = j * intervalY * 2.0 - 1.0;
                    position.push(x, y);
                    vector.push(0.0, 0.0);
                }
            }

            pointPosition = new Float32Array(position);
            var vbo = webgl.createBuffer();
            webgl.bindBuffer(webgl.ARRAY_BUFFER, vbo);
            webgl.enableVertexAttribArray(_attrPosition);
            webgl.vertexAttribPointer(_attrPosition, 2, webgl.FLOAT, false, 0, 0);
            webgl.bufferData(webgl.ARRAY_BUFFER, pointPosition, webgl.DYNAMIC_DRAW);
            
        }


        function webGLStart() {
            //! 初始化
            init();
            //! 进入游戏循环
            tick();
        }

        function hsva(h, s, v, a) {
            if (s > 1 || v > 1 || a > 1) { return; }
            var th = h % 360;
            var i = Math.floor(th / 60);
            var f = th / 60 - i;
            var m = v * (1 - s);
            var n = v * (1 - s * f);
            var k = v * (1 - s * (1 - f));
            var color = new Array();
            if (!s > 0 && !s < 0) {
                color.push(v, v, v, a);
            } else {
                var r = new Array(v, n, m, m, k, v);
                var g = new Array(k, v, v, n, m, m);
                var b = new Array(m, m, k, v, v, n);
                color.push(r[i], g[i], b[i], a);
            }
            return color;
        }
        // イベントI理
        function mouseDown(eve) 
        {
            mouseFlag = true;
        }
        function mouseUp(eve) 
        {
            mouseFlag = false;
        }
        function mouseMove(eve) 
        {
            if (mouseFlag) 
            {
                var cw = canvas.width;
                var ch = canvas.height;
                mousePositionX = (eve.clientX - canvas.offsetLeft - cw / 2.0) / cw * 2.0;
                mousePositionY = -(eve.clientY - canvas.offsetTop - ch / 2.0) / ch * 2.0;
            }
        }

        function vectorUpdate(x, y, tx, ty, vx, vy) {
            var px = tx - x;
            var py = ty - y;
            var r = Math.sqrt(px * px + py * py) * 5.0;
            if (r !== 0.0) {
                px /= r;
                py /= r;
            }
            px += vx;
            py += vy;
            r = Math.sqrt(px * px + py * py);
            if (r !== 0.0) {
                px /= r;
                py /= r;
            }
            return [px, py];
        }
        function renderScene() 
        {
            
            //! 设置重绘背景的颜色
            webgl.clearColor(0.0, 0.0, 0.0, 1.0);
            //! 执行绘制，即将背景清空成制定的颜色(clearColor)
            webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            webgl.enable(webgl.BLEND);
            webgl.blendFuncSeparate(webgl.SRC_ALPHA, webgl.ONE, webgl.ONE, webgl.ONE);
	
           
            count++;
            var pointColor = hsva((count % 720) / 2, 1.0, 1.0, 0.5);

            if (mouseFlag) {
                velocity = MAX_VELOCITY;
            } else {
                velocity *= 0.95;
            }
            var i, j, k, l;
            
            for (i = 0; i < resolutionX; i++) {
                k = i * resolutionX;
                for (j = 0; j < resolutionY; j++) {
                    l = (k + j) * 2;

                    if (mouseFlag) 
                    {
                        var p = vectorUpdate(
						pointPosition[l],
						pointPosition[l + 1],
						mousePositionX,
						mousePositionY,
						vector[l],
						vector[l + 1]
					    );
                        vector[l] = p[0];
                        vector[l + 1] = p[1];
                    }
                    pointPosition[l] += vector[l] * velocity * SPEED;
                    pointPosition[l + 1] += vector[l + 1] * velocity * SPEED;
                }
            }
            webgl.bufferSubData(webgl.ARRAY_BUFFER, 0, pointPosition);

            // 点を描画
            webgl.uniform1f(_pointSize, velocity * 1.25 + 0.25);
            webgl.uniform4fv(_pointColor, pointColor);
            webgl.drawArrays(webgl.POINTS, 0, verticesCount);

            webgl.flush();
        }


        function tick() {
            requestAnimFrame(tick);
            renderScene();

        }
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                   window.webkitRequestAnimationFrame ||
                   window.mozRequestAnimationFrame ||
                   window.oRequestAnimationFrame ||
                   window.msRequestAnimationFrame ||
                   function (callback, element) {
                       window.setTimeout(callback, 1000 / 60);
                   };
        })();

    </script>
</head>
<body onload='webGLStart()'>
    <canvas id="myCanvas" style="border: 1px solid red;" width='1024' height='768'></canvas>
</body>
</html>
