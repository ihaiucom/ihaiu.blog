---
layout: post
title: 网络同步
date: 2017-10-31 13:00:00
categories: 网络同步
tags: 网络同步 TRUESYNC ForgeNetworking
excerpt: 网络同步 TRUESYNC ForgeNetworking
shareexcerpt: 网络同步 TRUESYNC ForgeNetworking
thread: 20171031000000
author: 大海明月
authorQQ: 593705098
authorEmail: zengfeng75@qq.com
thumbnail: 

sh: true
sh_csharp: true
---





<br>
<br>
<h2 class="nav1">Photon TRUESYNC</h2>
<div class="" >
<ul>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com" draggable="false">
  <span class="title">Photon 官网首页(光子  专注多人网络同步游戏) </span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com/zh-TW/Realtime" draggable="false">
  <span class="title">Realtime 即时 (其实是让你去注册一个账号，然后创建应用。估计是使用它们的云服务平台。) </span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com/PUN" draggable="false">
  <span class="title">PUN （看着像Photon Unity Networking的缩写, 是Unity网络组建，主要是链接到https://www.assetstore.unity3d.com/en/#!/content/1786）</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com/PUN" draggable="false">
  <span class="title">Bolt （是 Steam 用的好像，主要是链接到https://www.assetstore.unity3d.com/en/#!/content/83233）</span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com/PUN" draggable="false">
  <span class="title">Thunder （Unity的UNET API的高级中继，打通和匹配服务，主要是链接到https://www.assetstore.unity3d.com/en/#!/content/83233）</span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.photonengine.com/PUN" draggable="false">
  <span class="title">TrueSync （TrueSync奠基在PUN的所有功能之上，更提供一个能够轻松实作高精度同步的架构与特制的物理引擎。，主要是链接到 https://www.assetstore.unity3d.com/en/#!/content/73228）</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.assetstore.unity3d.com/en/#!/content/1786" draggable="false">
  <span class="title">Photon Unity Networking Free, Unity网络组建 (assetstore)</span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.assetstore.unity3d.com/en/#!/content/83233" draggable="false">
  <span class="title">Photon Bolt $95.00, Steam使用的 (assetstore)</span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.assetstore.unity3d.com/en/#!/content/94901" draggable="false">
  <span class="title">Photon Thunder  Unity的UNET API的高级中继，打通和匹配服务(assetstore)</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://www.assetstore.unity3d.com/en/#!/content/94901" draggable="false">
  <span class="title">Photon TrueSync (assetstore)</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://doc.photonengine.com/en-us/realtime/current/getting-started/realtime-intro" draggable="false">
  <span class="title">Photon Documentation Realtime</span>
</a>
</li>

<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://doc.photonengine.com/en-us/pun/current/getting-started/pun-intro" draggable="false">
  <span class="title">Photon Documentation PUN</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://doc.photonengine.com/en-us/bolt/current/setup/overview" draggable="false">
  <span class="title">Photon Documentation Bolt</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://doc.photonengine.com/en-us/thunder/current/getting-started/introduction" draggable="false">
  <span class="title">Photon Documentation Thunder and UNet</span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://doc.photonengine.com/en-us/truesync/current/getting-started/truesync-intro" draggable="false">
  <span class="title">Photon Documentation TrueSync </span>
</a>
</li>



<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="http://forum.photonengine.com/" draggable="false">
  <span class="title">Photon forum 论坛 </span>
</a>
</li>


<li data-fid="1" data-index="1" draggable="true">
<a target="_blank" contextmenu="thumb-menu" href="https://mp.weixin.qq.com/s?__biz=MzU1NDI4NDIyNg==&mid=100000015&idx=1&sn=abc79b9fb757a296d363ffc60eaddb52&chksm=7be4a4a24c932db4516e070cb9a4a9422be00cbf3f5ef652cc91866af71625f84418805d0d8f&scene=18#rd" draggable="false">
  <span class="title">Photon产品介绍 </span>
</a>
</li>


</ul>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 调用PhotonNetwork.ConnectUsingSettings(gameVersion);时的回调</h2>
<div class="" >
<pre>
OnPhotonCustomRoomPropertiesChanged
OnPhotonCustomRoomPropertiesChanged
OnCreatedRoom
OnJoinedRoom
</pre>
</div>

<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 调用CreateRoom时的回调</h2>
<div class="" >
<pre>
OnConnectedToPhoton
OnConnectedToMaster
</pre>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 调用JoinRandomRoom时的回调</h2>
<div class="" >
<pre>
OnPhotonRandomJoinFailed
</pre>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 调用PhotonNetwork.LeaveRoom时的回调</h2>
<div class="" >
<pre>
OnLeftRoom
OnConnectedToMaster
</pre>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 自己调用PhotonNetwork.LeaveRoom时的回调</h2>
<div class="" >
<pre>
OnLeftRoom
OnConnectedToMaster
</pre>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 其他玩家调用PhotonNetwork.LeaveRoom时的回调</h2>
<div class="" >
<pre>
OnPhotonPlayerDisconnected(PhotonPlayer other)
</pre>
</div>


<br>
<br>
<h2 class="nav2">Photon IPunCallbacks 调用PhotonNetwork.LoadLevel;时的回调</h2>
<div class="" >
<pre>
OnLeftRoom
</pre>
</div>



<br>
<br>
<h2 class="nav2">TrueSync代码</h2>
<div class="" >
<ul>

<li>TrueSyncConfig</li>
<pre>
帧同步配置
</pre>

<li>TrueSyncManager</li>
<pre>
管理、驱动帧同步 

//同步全局配置
static TrueSyncConfig TrueSyncGlobalConfig;
// 配置
static TrueSyncConfig Config;
TrueSyncConfig ActiveConfig;
// 锁帧
private AbstractLockstep lockstep;
// 协程调度
CoroutineScheduler scheduler;


// 玩家预设列表
GameObject[] playerPrefabs;
// 
 private Dictionary&lt;int, List&lt;GameObject&gt;&gt; gameOjectsSafeMap = new Dictionary&lt;int, List&lt;GameObject&gt;&gt;();


// 非哪个玩家拥有的行为，叫做普通行为
List&lt;TrueSyncManagedBehaviour&gt; generalBehaviours = new List&lt;TrueSyncManagedBehaviour&gt;();

// 对应玩家所拥有的行为
Dictionary&lt;byte, List&lt;TrueSyncManagedBehaviour&gt;&gt; behaviorsByPlayer;

// 一个临时缓存池，用在后面注册行为的时候占存。在帧更新的时候OnStepUpdate调用CheckQueuedBehaviours。分配玩家拥有者和调OnSyncedStart。然后就清理该列表
List&lt;TrueSyncManagedBehaviour&gt; queuedBehaviours = new List&lt;TrueSyncManagedBehaviour&gt;();

// 保存了所有行为的字典
Dictionary&lt;ITrueSyncBehaviour, TrueSyncManagedBehaviour&gt; mapBehaviorToManagedBehavior = new Dictionary&lt;ITrueSyncBehaviour, TrueSyncManagedBehaviour&gt;();

// 时间
FP time = 0;
static FP Time;

// 帧时间
static FP DeltaTime;

// 帧
static int Ticks;
static int LastSafeTick;

// 重力
static TSVector Gravity;

// 玩家列表
static List&lt;TSPlayerInfo&gt; Players；

// 本地玩家
static TSPlayerInfo LocalPlayer；


// 启动状态, 在Update决定什么时候运行lockstep.RunSimulation(true);
private enum StartState { BEHAVIOR_INITIALIZED, FIRST_UPDATE, STARTED };
private StartState startState;



        void Awake() {
            TrueSyncConfig currentConfig = ActiveConfig;
            lockedTimeStep = currentConfig.lockedTimeStep;

            // 初始化状态跟踪
            StateTracker.Init(currentConfig.rollbackWindow);
            // 初始化随机数
            TSRandom.Init();

            // 初始化物理管理器
            if (currentConfig.physics2DEnabled || currentConfig.physics3DEnabled) {
                PhysicsManager.New(currentConfig);
                PhysicsManager.instance.LockedTimeStep = lockedTimeStep;
                PhysicsManager.instance.Init();
            }

            // 跟踪 时间
            StateTracker.AddTracking(this, &quot;time&quot;);
        }




void Start() 做了什么?
设置instance = this;
设置Application.runInBackground = true;
初始化通信PhotonTrueSyncCommunicator 
创建lockstep
检测是否是录像模式, 如果是就加载录像
如果配置了显示TrueSyncStats，那就初始化
创建协程调度 scheduler = new CoroutineScheduler(lockstep);
非录像模式下 初始化帧的玩家列表
初始化场景中现有的帧同步行为 TrueSyncBehaviour
实例化玩家预设playerPrefabs和同步其行为的拥有者 initBehaviors
初始化行为拥有者，并分配给对于玩家。没有继承TrueSyncBehaviour的就继续放到普通行为列表。initGeneralBehaviors
添加物理对象移除监听 PhysicsManager.instance.OnRemoveBody(OnRemovedRigidBody);
设置启动状态 startState = StartState.BEHAVIOR_INITIALIZED;


// 创建ITrueSyncBehaviour的TrueSyncManagedBehaviour
private TrueSyncManagedBehaviour NewManagedBehavior(ITrueSyncBehaviour trueSyncBehavior)

// 初始化玩家预设和他们的同步行为。行为设置拥有者，并其添加到对应玩家的行为字典里behaviorsByPlayer
private void initBehaviors()

// 对行为列表分配拥有者， 在Start(), CheckQueuedBehaviours()里调用
private void initGeneralBehaviors(IEnumerable&lt;TrueSyncManagedBehaviour&gt; behaviours, bool realOwnerId)

// 将注册行为占存列表列queuedBehaviours的行为调initGeneralBehaviors分配拥有者。调SetGameInfo和OnSyncedStart两个方法
private void CheckQueuedBehaviours()

// 只做一件事，检测启动状态，如果是第一次启动就调lockstep.RunSimulation(true);
void Update()





// 在帧同步调暂停后 恢复继续运行。instance.lockstep.RunSimulation(false);
public static void RunSimulation()

// 暂停游戏 调instance.lockstep.PauseSimulation();
public static void PauseSimulation() 

// 结束游戏 调instance.lockstep.EndSimulation();
public static void EndSimulation()

// 更新一次协程， 主要是物理里调用了。默认的协程更新在 帧更新里OnStepUpdate
public static void UpdateCoroutines()

// 添加一个协程
public static void SyncedStartCoroutine(IEnumerator coroutine)




// 实例化一个预设
// 先势力化一个GameObject
// 非录像模式将该对象添加到帧记录里。AddGameObjectOnSafeMap(go);
// 将该对象的帧行为添加到queuedBehaviours，等待帧更新的时候分配拥有者和调度初始化方法
// 调该对象上组件的初始化方法（ICollider注册到物理管理器里PhysicsManager, TSTransform, TSTransform2D）。InitializeGameObject
public static GameObject SyncedInstantiate(GameObject prefab)
public static GameObject SyncedInstantiate(GameObject prefab, TSVector position, TSQuaternion rotation)
public static GameObject SyncedInstantiate(GameObject prefab, TSVector2 position, TSQuaternion rotation)

// 将势力化的GameObject添加到当前的帧+1列表里
private static void AddGameObjectOnSafeMap(GameObject go)

// 在帧更新OnStepUpdate的时候掉, 清理销毁掉当前 Ticks + 1里的GameObject。猜测估计是帧回滚的时候把预处理的对象销毁
private static void CheckGameObjectsSafeMap()

// 调该对象上组件的初始化方法（ICollider注册到物理管理器里PhysicsManager, TSTransform, TSTransform2D）
private static void InitializeGameObject(GameObject go, TSVector position, TSQuaternion rotation)

// 销毁GameObject
// 第一步调SyncedDisableBehaviour, 停止更新该对象上的ITrueSyncBehaviour
// 第二步调 TSCollider和TSCollider2D 调 DestroyTSRigidBody
public static void SyncedDestroy(GameObject gameObject)

// 将GameObject的ITrueSyncBehaviour的disabled设置为true, 停止对他调帧更新方法 OnSyncedInput，OnSyncUpdate。
public static void SyncedDisableBehaviour(GameObject gameObject)

// 设置 tsColliderGO.gameObject.SetActive(false);
// 将物理对象从lockstep销毁 instance.lockstep.Destroy(body);
private static void DestroyTSRigidBody(GameObject tsColliderGO, IBody body)

// 注册ITrueSyncBehaviour, 将他添加到queuedBehaviours。在下次CheckQueuedBehaviours的时候，也就是在下次帧更新的时候OnStepUpdate，对他分配拥有者，调SetGameInfo和OnSyncedStart两个方法
public static void RegisterITrueSyncBehaviour(ITrueSyncBehaviour trueSyncBehaviour)

// 注册游戏是否继续的委托。 调委托会返回一个bool值。 true游戏可以继续运行。lockstep里会调该方法检测是否可以继续CheckGameIsReady（）
public static void RegisterIsReadyChecker(TrueSyncIsReady IsReadyChecker)

// 移除玩家
// 第一步将该玩家的 行为全部禁止帧更新behaviorsByPlayer[(byte)playerId],disabled = true;
// 第二步将这些行为的GameObject上拥有TSCollider、TSCollider2D的物理全部掉DestroyTSRigidBody
public static void RemovePlayer(int playerId)


// 检测帧更新时间，时间到就调instance.scheduler.UpdateAllCoroutines();和lockstep.Update();
// lockedTimeStep，帧同步一帧的时间
// JitterTimeFactor, 为了避免浮动点数比较造成误差。if (tsDeltaTime &gt;= (lockedTimeStep - JitterTimeFactor))
// tsDeltaTime, 用的时间还是用Unity的 tsDeltaTime += UnityEngine.Time.deltaTime;
void FixedUpdate()

// 里面创建一个输入数据结构 return new InputData();  是在lockstep创建的时候传这个方法给他
InputDataBase ProvideInputData()

// 这个方法会调本地玩家所有帧行为的OnSyncedInput方法
// 这这个方法生命周期内 TrueSyncInput.CurrentInputData = playerInputData
// 是在lockstep创建的时候传这个方法给他
void GetLocalData(InputDataBase playerInputData)

// 帧更新
// 添加当前时间 time += lockedTimeStep;
// 非录像模式， 检测GameObject CheckGameObjectsSafeMap();
// 遍历generalBehaviours普通行为列表，调行为的OnPreSyncedUpdate()。还会调协程更新instance.scheduler.UpdateAllCoroutines();
// 遍历allInputData,和对应玩家的行为列表behaviorsByPlayer。 调行为的OnPreSyncedUpdate()。还会调协程更新instance.scheduler.UpdateAllCoroutines();
// 遍历generalBehaviours普通行为列表，调行为的OnSyncedUpdate()。还会调协程更新instance.scheduler.UpdateAllCoroutines();
// 遍历allInputData,和对应玩家的行为列表behaviorsByPlayer。 调行为的OnSyncedUpdate()。还会调协程更新instance.scheduler.UpdateAllCoroutines();
// 检测占存行为列表CheckQueuedBehaviours（）。给他们分配拥有者和调同步开始方法
// 是在lockstep创建的时候传这个方法给他
void OnStepUpdate(List&lt;InputDataBase&gt; allInputData)


// 玩家离线消息处理
// 调TrueSyncManagedBehaviour.OnPlayerDisconnection(generalBehaviours, behaviorsByPlayer, playerId);
// 是在lockstep创建的时候传这个方法给他
 void OnPlayerDisconnection(byte playerId)



// 游戏开始消息处理
// 是在lockstep创建的时候传这个方法给他
        void OnGameStarted() {
            TrueSyncManagedBehaviour.OnGameStarted(generalBehaviours, behaviorsByPlayer);
            instance.scheduler.UpdateAllCoroutines();

            CheckQueuedBehaviours();
        }


// 游戏暂停消息处理
// 是在lockstep创建的时候传这个方法给他
        void OnGamePaused() {
            TrueSyncManagedBehaviour.OnGamePaused(generalBehaviours, behaviorsByPlayer);
            instance.scheduler.UpdateAllCoroutines();
        }

// 游戏继续消息处理
        void OnGameUnPaused() {
            TrueSyncManagedBehaviour.OnGameUnPaused(generalBehaviours, behaviorsByPlayer);
            instance.scheduler.UpdateAllCoroutines();
        }

// 游戏结束消息处理
        void OnGameEnded() {
            TrueSyncManagedBehaviour.OnGameEnded(generalBehaviours, behaviorsByPlayer);
            instance.scheduler.UpdateAllCoroutines();
        }


// 移除物理对象事件处理
// 会移除该对象的GameObject上所有同步行为 调RemoveFromTSMBList
// PhysicsManager.instance.OnRemoveBody(OnRemovedRigidBody); 在这里注册
private void OnRemovedRigidBody(IBody body) 

// 从tsmbList列表中，移除behaviours
private void RemoveFromTSMBList(List&lt;TrueSyncManagedBehaviour&gt; tsmbList, List&lt;TrueSyncBehaviour&gt; behaviours)

// 清理
// 清理对象池 ResourcePool.CleanUpAll();
// 清理状态跟踪 StateTracker.CleanUp();
// 去除实例变量引用 instance = null;
public static void CleanUp()


// Unity的消息。退出应用
        void OnApplicationQuit() {
            EndSimulation();
        }


</pre>



<li>ICommunicator</li>
<pre>
接口 通信器

// 往返时间
int RoundTripTime();

// 操作时间
void OpRaiseEvent(byte eventCode, object message, bool reliable, int[] toPlayers);

// 添加监听
void AddEventListener(OnEventReceived onEventReceived);
</pre>


<li>PhotonTrueSyncCommunicator</li>
<pre>
帧同步 通信器， 实现ICommunicator接口
// 往返时间
int RoundTripTime();

// 操作时间
void OpRaiseEvent(byte eventCode, object message, bool reliable, int[] toPlayers);

// 添加监听
void AddEventListener(OnEventReceived onEventReceived);
</pre>



<li>OnEventReceived</li>
<pre>
代理事件， 接收消息

// byte eventCode 消息编号
// object content 消息内容
public delegate void OnEventReceived(byte eventCode, object content);
</pre>



<li>TrueSyncBehaviour</li>
<pre>
帧同步行为，继承自 MonoBehaviour, 实现接口 ITrueSyncBehaviourGamePlay, ITrueSyncBehaviourCallbacks

// 该行为的拥有者玩家
public TSPlayerInfo owner;

// 本地玩家，相当于快捷访问本地玩家
public TSPlayerInfo localOwner;

// 快捷访问
TSTransform tsTransform
TSTransform2D tsTransform2D
TSRigidBody tsRigidBody
TSRigidBody2D tsRigidBody2D
TSCollider tsCollider
TSCollider2D tsCollider2D

// 基本上就是上面这些属性，实现的接口都是空的没有写业务逻辑

</pre>


<li>TrueSyncManagedBehaviour</li>
<pre>
帧同步行为管理器，实现接口 ITrueSyncBehaviourGamePlay, ITrueSyncBehaviour, ITrueSyncBehaviourCallbacks
主要是包装了TrueSyncBehaviour/ITrueSyncBehaviour, 实现的接口方法直接掉TrueSyncBehaviour的放方法，TrueSyncBehaviour的OnSyncedStartLocalPlayer 方法该行为是本地用户时才调

// 有一个属性, true是，不会参与帧更新
    [AddTracking]
    public bool disabled;


后面就是一些全局静态方法，用管理处理列表的事件



</pre>



<li>CoroutineScheduler</li>
<pre>
协程调用
在TrueSyncManager.SyncedStartCoroutine 调 StartCoroutine(IEnumerator coroutine) 启动一个协程
在TrueSyncManager驱动UpdateAllCorutines()
</pre>



<li>ITrueSyncBehaviour</li>
<pre>
接口 帧同步行为
就只有一个方法
// 设置游戏信息 (本地玩家， 玩家数量)
void SetGameInfo(TSPlayerInfo localOwner, int numberOfPlayers);
</pre>


<li>ITrueSyncBehaviourGamePlay</li>
<pre>
接口 玩家操作帧同步行为, 继承自ITrueSyncBehaviour

// 同步 玩家输入操作
void OnSyncedInput();



// 同步 读取玩家操作
void OnSyncedUpdate();

void OnPreSyncedUpdate();
</pre>


<li>ITrueSyncBehaviourCallbacks</li>
<pre>
接口 回调同步行为, 继承自ITrueSyncBehaviour

// 开始
void OnSyncedStart();



// 开始 -- 只调本地玩家的
void OnSyncedStartLocalPlayer();

// 游戏暂停
void OnGamePaused();

// 游戏继续
void OnGameUnPaused();

// 可以游戏了， 什么时候调用 我也不清楚
void OnGameEnded();


// 有玩家离线时调用
void OnPlayerDisconnection(int playerId);
</pre>





<li>TSRandom</li>
<pre>
随机数
http://www.codeproject.com/Articles/164087/Random-Number-Generation
https://github.com/ihaiucom/learn.PhotonTrueSync/blob/master/PhotonGame/Assets/TrueSync/Engine/Math/TSRandom.cs

原理是，传一个因素进去，然后里面生成N数量的数组。每个数有一个公式计算来生成。所以传相同的因素生成的结果是一样的。
获取随机数的时候根据当前索引mti依次读取数组里面的数。当mti大于N时，内部重新生成默认因素是5489U
</pre>

<p><a target="_blank" href="http://www.codeproject.com/Articles/164087/Random-Number-Generation">Random-Number-Generation </a></p>
<p><a target="_blank" href="https://github.com/ihaiucom/learn.PhotonTrueSync/blob/master/PhotonGame/Assets/TrueSync/Engine/Math/TSRandom.cs">TrueSync/Engine/Math/TSRandom.cs</a></p>



<li>StateTracker.TrackedInfo</li>
<pre>
状态跟踪信息， 用来保存对象引用，和对象的成员属性信息MemberInfo
object relatedObj； 保存对象
MemberInfo propInfo; 对象的成员属性信息
</pre>


<li>StateTracker.State</li>
<pre>
状态跟踪信息， 持有TrackedInfo跟踪信息

// 保存值到value变量
public void SaveValue()

// 将保存的值用反射赋值给对象
public void RestoreValue()
</pre>


<li>StateTracker</li>
<pre>
状态跟踪

//TSRandom 用到
StateTracker.AddTracking(r, "mt");
StateTracker.AddTracking(r, "mti");

//TrueSyncManager 用到
StateTracker.AddTracking(this, "time");


//TSTransform 用到 配合 [AddTracking] Attribute 使用, StateTracker.AddTracking(object obj)通过反射获取obj的成员变量
StateTracker.AddTracking(this);

// TrueSyncManagedBehaviour 用到
StateTracker.AddTracking(this);
StateTracker.AddTracking(trueSyncBehavior);




// 这个是核心了， 里面保存了rollbackWindow数量的列表，AddTracking的时候回把StateTracker.State添加到所有列表里
// SaveState 的时候就保存GenericBufferWindow当前列表的, 保存完后就GenericBufferWindow的索引移动下一个
// RestoreState 从GenericBufferWindow当前的列表把值恢复
StateTracker.instance.states = new GenericBufferWindow&lt;List&lt;StateTracker.State&gt;&gt;(rollbackWindow);
</pre>




<li>GenericBufferWindow</li>
<pre>
通用缓存窗口

// StateTracker 用到
      StateTracker.instance.states = new GenericBufferWindow&lt;List&lt;StateTracker.State&gt;&gt;(rollbackWindow);

// CompoundStats 用到
      this.bufferStats = new GenericBufferWindow&lt;Stats&gt;(10);

// AbstractLockstep 用到  
      this.bufferSyncedInfo = new GenericBufferWindow&lt;SyncedInfo&gt;(3);


构造方法： 会创建一个T[size] 的数组buffer，并且实例化T 

</pre>


<li>ResourcePool 对象池</li>
<pre>
ResourcePool 是一个抽象对象池,他有一个静态对象池列表。他管理所有对象池的清理CleanUpAll();




ResourcePool&lt;T&gt; 是ResourcePool派生类。里面有一个对象栈存储空闲的对象。

// 还回对象
GiveBack(T obj)

// 获取对象, 如果T是ResourcePoolItem的派生类就会调对象的CleanUp()方法
T GetNew()

// 实例化对象
T NewInstance()



ResourcePoolItem 是对象池对象接口，实现该接口的对象在获取对象时会调CleanUp()方法




【使用】
internal class ResourcePoolListSyncedData : ResourcePool&lt;List&lt;SyncedData&gt;&gt;
internal class ResourcePoolStateTrackerState : ResourcePool&lt;StateTracker.State&gt;
internal class ResourcePoolSyncedData : ResourcePool&lt;SyncedData&gt;



</pre>




<li>SerializableDictionary</li>
<pre>
public class SerializableDictionary&lt;TKey, TValue&gt; : Dictionary&lt;TKey, TValue&gt;, ISerializationCallbackReceiver

其实就是一个字典Dictionary, 然后实现了Unity的接口ISerializationCallbackReceiver。OnBeforeSerialize、OnAfterDeserialize

派生类
public class SerializableDictionaryByteByte : SerializableDictionary&lt;byte, byte&gt;
public class SerializableDictionaryByteByteArray : SerializableDictionary&lt;byte, byte[]&gt;
public class SerializableDictionaryByteInt : SerializableDictionary&lt;byte, int&gt;
public class SerializableDictionaryBytePlayer : SerializableDictionary&lt;byte, TSPlayer&gt;
public class SerializableDictionaryByteString : SerializableDictionary&lt;byte, string&gt;
public class SerializableDictionaryIntSyncedData : SerializableDictionary&lt;int, SyncedData&gt;

</pre>



<li>InputDataBase</li>
<pre>
继承ResourcePoolItem 对象池对象接口
抽象输入数据，主要定义了几个接口。和一个owerID拥有者属性

    // 序列化
    public abstract void Serialize(List&lt;byte&gt; bytes);

    // 解析
    public abstract void Deserialize(byte[] data, ref int offset);


    // 是否想等
    public abstract bool EqualsData(InputDataBase otherBase);


    // 清理
    public abstract void CleanUp();

    // 拷贝
    public abstract void CopyFrom(InputDataBase fromBase);

</pre>


<li>InputData</li>
<pre>
继承InputDataBase
拥有各个基本类型字典

序列化和解析都是对这些解绑类型字典
每个值的序列化:key, valueType, value
数组的: key, valueType, length, value[]
字符串的用char[] 也就是数组


然后有各个类型的AddXX和GetXX
    
</pre>



<li>SyncedInfo</li>
<pre>
同步信息，保存了3个属性

  
    // 玩家ID
    public byte playerId;

    // 帧
    public int tick;

    // 校验码
    public string checksum;

2 个方法

// 序列化
public static byte[] Encode(SyncedInfo info)

// 解析
public static SyncedInfo Decode(byte[] infoBytes)

</pre>


<li>SyncedData</li>
<pre>
同步数据

主要就序列化下面两个方法的数据

    public void GetEncodedHeader(List<byte> bytes)
    {
      // 帧
      Utils.GetBytes(this.tick, bytes);
      // 拥有者玩家ID
      bytes.Add(this.inputData.ownerID);
      // 从哪个玩家掉线
      bytes.Add(this.dropFromPlayerId);
      // 是否掉线
      bytes.Add(this.dropPlayer ? 1 : 0);
    }


    public void GetEncodedActions(List<byte> bytes)
    {
      this.inputData.Serialize(bytes);
    }

</pre>



<li>TSPlayerInfo</li>
<pre>
玩家信息,保存2个属性

    // 玩家ID
    [SerializeField]
    internal byte id;

    // 玩家名称
    [SerializeField]
    internal string name;

</pre>



<li>TSPlayer</li>
<pre>
玩家

    // 玩家信息
    [SerializeField]
    public TSPlayerInfo playerInfo;

    // 掉线次数
    [NonSerialized]
    public int dropCount;

    //是否掉线
    [NonSerialized]
    public bool dropped;

    // 开始发送同步数据
    [NonSerialized]
    public bool sentSyncedStart;

    // 保存玩家整个战斗的操作同步数据, 他是一个字典SerializableDictionary<int, SyncedData>
    [SerializeField]
    internal SerializableDictionaryIntSyncedData controls;

    // 最后一次 同步操作数据的帧, AddData(SyncedData data)
    private int lastTick;


    internal TSPlayer(byte id, string name)
    {
      // 创建玩家信息
      this.playerInfo = new TSPlayerInfo(id, name);
      this.dropCount = 0;
      this.dropped = false;
      // 创建玩家操作字典存储器
      this.controls = new SerializableDictionaryIntSyncedData();
    }

    // 获取某帧是否有真实同步操作数据
    public bool IsDataReady(int tick)
    {
      return this.controls.ContainsKey(tick) && !this.controls[tick].fake;
    }

    // 获取某帧是否有模拟同步操作数据, 客户端先行，是客户端预测的操作, 回滚添加的。
    public bool IsDataDirty(int tick)
    {
      bool flag = this.controls.ContainsKey(tick);
      return flag && this.controls[tick].dirty;
    }

    // 获取该帧的同步操作数据
    public SyncedData GetData(int tick)
    {
      bool flag = !this.controls.ContainsKey(tick);
      SyncedData result;
      if (flag)
      {
        // 如果不存在，就查找上一帧是否存在
        bool flag2 = this.controls.ContainsKey(tick - 1);
        SyncedData syncedData;
        if (flag2)
        {
          // 如果存在上一帧，就克隆上一帧的同步数据
          syncedData = this.controls[tick - 1].clone();
          syncedData.tick = tick;
        }
        else
        {
          // 否则就新建一个同步数据
          syncedData = SyncedData.pool.GetNew();
          syncedData.Init(this.ID, tick);
        }
        // 设置为伪造的
        syncedData.fake = true;
        // 保存到帧字典
        this.controls[tick] = syncedData;
        result = syncedData;
      }
      else
      {
        // 如果存在该,就返回该帧数据
        result = this.controls[tick];
      }
      return result;
    }


    // 添加存在帧同步数据
    public void AddData(SyncedData data)
    {
      int tick = data.tick;
      bool flag = this.controls.ContainsKey(tick);
      if (flag)
      {
        // 如果已经存在，就还给对象池
        SyncedData.pool.GiveBack(data);
      }
      else
      {
        // 否则 添加到存储里
        this.controls[tick] = data;
        // 设置最后存储的帧
        this.lastTick = tick;
      }
    }




</pre>



<li>ReplayRecord</li>
<pre>
录像

负责记录游戏是所有玩家的SynceData

序列化: 各个玩家的所有操作
</pre>

</ul>
</div>

