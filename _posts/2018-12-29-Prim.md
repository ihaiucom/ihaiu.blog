---
layout: post
title: 最小生成树之Prim普里姆算法
date: 2018-12-29 9:50:00
categories: game
tags: game
excerpt: 最小生成树之Prim普里姆算法
shareexcerpt: 最小生成树之Prim普里姆算法
thread: 20181018160000
author: 大海明月
authorQQ: 593705098
authorEmail: zengfeng75@qq.com
thumbnail: 

sh: true
sh_js: true
---




<br>
<br>


### 相关链接

<a href="https://www.lintcode.com/problem/minimum-risk-path/description" target="_blank">783. 最小危险值路径</a><br>
<a href="https://blog.csdn.net/qq_35644234/article/details/59106779" target="_blank">数据结构--最小生成树详解</a><br>
<a href="https://blog.ihaiu.com/Floyd/#content" target="_blank">最短路径算法之 Floyd</a><br>


### 在线测试

<a href="https://blog.ihaiu.com/web/path_algorithm/index.html" target="_blank">寻路算法 在线测试</a><br><br>



<p>1. 点击右边的测试数据按钮，可以切换数据</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/01.gif" style="border: solid 1px #666;" /></p><br>


<p>2. 点击右边的最小生成树，可以切换是否开启这功能</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/02.gif" style="border: solid 1px #666;" /></p><br>


<p>3. 点击右边的操作模式<br>
* 拖动节点： 可以拖动节点，默认都可以
* 设置起始点： 选中该模式，再点击节点，可以将该节点设置为最短寻路起始点。节点下标Start<br>
* 设置结束点： 选中该模式，再点击节点，可以将该节点设置为最短寻结束点。节点下标End<br>
寻得的路线为绿色连线，红色表示该路线中成本最大的值

</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/03.gif" style="border: solid 1px #666;" /></p><br>


<p>4. 修改数据
(1) 先点击“导出数据按钮”，会在页面下方输出图形json数据 <br>
(2) 编辑数据，点提交就可以修改了。只需要修改属性 x(起点), y(目标点), w(成本)
</p>

<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/04.gif" style="border: solid 1px #666;" /></p><br>

### Prim.ts


<pre class="brush: js; ">
namespace ihaiu
{
    /** 作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 */
    export class PrimAssis
    {
        // 边的终点
        start: number = 0;
        // 边的起点
        end: number = 0;
        // 边的权重
        weight: number = 0;
    }

    /** 最小生成树之Prim普里姆算法 */
    export class Prim
    {

        // 成本矩阵
        arcs: number[][];

        // 计算结果
        result: GraphData;

        constructor()
        {

        }


        /** 获取路径成本 */
        public getArcs(from: number, to: number): number
        {
            return this.arcs[from][to];
        }


        /** 是否有连接线 */
        public hasEdge(from: number, to: number): boolean
        {
            let arc = this.getArcs(from, to);
            return arc != Number.MAX_VALUE && arc != 0;
        }

        public calculationByGraphData(g: GraphData, beginIndex: number = 0):GraphData
        {
            g.check();
            let g2 = this.calculation(
                            g.nodeNum, 
                            g.edegeNum,
                            g.x,
                            g.y,
                            g.w,
                            beginIndex
                            );

            g2.nodeNum = g.nodeNum;             
            g2.nodes = g.nodes;
            return g2;
        }


        /** 计算寻路 */
        public calculation(nodeNum: number, edegeNum: number, x: number[], y: number[], w: number[], beginIndex: number = 0):GraphData
        {
            // 结果图
            let result: GraphData = new GraphData().init();

            // 成本矩阵
            let arcs: number[][] = [];


            // 初始化矩阵值
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                arcs[u] = [];

                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    arcs[u][v] = Number.MAX_VALUE;
                }
            }


            // 输入边
            for(let i = 0; i &lt; x.length; i ++)
            {
                let u = x[i];
                let v = y[i];
                arcs[u][v] = w[i];
                arcs[v][u] = w[i];
            }

            //closeEdge这个数组记录到达某个顶点的各个边中的权重最大的那个边
            let closeEdges: PrimAssis[] = [];
            for(let i = 0; i &lt; nodeNum; i ++)
            {
                closeEdges.push(new PrimAssis());
            }

            //进行closeEdge的初始化，更加开始起点进行初始化
            for(let i = 0; i &lt; nodeNum; i ++)
            {
                if(i != beginIndex)
                {
                    let edge = closeEdges[i];
                    edge.start = beginIndex;
                    edge.end = i;
                    edge.weight = arcs[beginIndex][i];
                }
            }

            //把起点的closeEdge中的值设置为-1，代表已经加入到集合U了
            closeEdges[beginIndex].weight = -1;

             //访问剩下的顶点，并加入依次加入到集合U
             for(let i = 1; i&lt; nodeNum; i ++)
             {
                let minWeight = Number.MAX_VALUE;
                let minIndex = 0;
                //寻找数组close_edge中权重最小的那个边
                for(let k = 0; k &lt; nodeNum; k ++)
                {
                    if(closeEdges[k].weight != -1)
                    {
                        if(closeEdges[k].weight &lt; minWeight)
                        {
                            minWeight = closeEdges[k].weight;
                            minIndex = k;
                        }
                    }
                }

                let minEdge = closeEdges[minIndex];

                //将权重最小的那条边的终点也加入到集合U
                minEdge.weight = -1;


                //输出对应的边的信息
                result.addEdge(
                    minEdge.start, 
                    minEdge.end, 
                    arcs[minEdge.start][minEdge.end]
                    );

                    //更新我们的close_edge数组。
                    for (let k = 0; k &lt; nodeNum; k++) {
                        let edge = closeEdges[k];
                        if (arcs[minEdge.end][k] &lt; edge.weight) 
                        {
                            edge.weight = arcs[minEdge.end][k];
                            edge.start = minEdge.end;
                            edge.end = k;
                        }
                    }


             }

             this.arcs = arcs;
             this.result = result;
             return result;
        }







    }
}
</pre>

