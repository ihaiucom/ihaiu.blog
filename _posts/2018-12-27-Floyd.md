---
layout: post
title: 最短路径算法之 Floyd
date: 2018-12-27 9:50:00
categories: game
tags: game
excerpt: 最短路径算法之 Floyd
shareexcerpt: 最短路径算法之 Floyd
thread: 20181018160000
author: 大海明月
authorQQ: 593705098
authorEmail: zengfeng75@qq.com
thumbnail: 

sh: true
sh_js: true
---




<br>
<br>



<a href="https://www.lintcode.com/problem/minimum-risk-path/description" target="_blank">783. 最小危险值路径</a><br>


## Floyd.ts


<pre class="brush: js; ">
namespace ihaiu
{
    export class Floyd
    {
        constructor()
        {

        }

        // 顶点数
        nodeNum: number= 0;

        // 成本矩阵
        arcs: number[][];

        // 路径字典
        pathMap: number[][][];

        /** 获取路径 */
        public getPath(from: number, to: number): number[]
        {
            return this.pathMap[from][to];
        }


        /** 获取路径成本 */
        public getArcs(from: number, to: number): number
        {
            return this.arcs[from][to];
        }

        /** 获取路径中最大成本 */
        public getPathMaxArc(from: number, to: number): number
        {
            return this.getPathMaxArcByPath(this.getPath(from, to));
        }

        public getPathMaxArcByPath(ponts: number[]): number
        {
            let max = -1;
            for(let i = 0; i &lt; ponts.length - 1; i ++)
            {
                let u = ponts[i];
                let v = ponts[i + 1];
                let d = this.arcs[u][v];
                if(d &gt; max)
                {
                    max = d;
                }
            }
            return max;
        }

        /** 计算寻路 */
        public calculation(nodeNum: number, edegeNum: number, x: number[], y: number[], w: number[])
        {
            // 成本矩阵
            let arcs: number[][] = [];
            // 路径矩阵
            let path: number[][] = [];

            // 矫正顶点数量
            let num = 0;
            for(let i = 0; i &lt; x.length; i ++)
            {  
                num = Math.max(x[i], num);
                num = Math.max(y[i], num);
            }
            nodeNum = Math.max(num + 1, nodeNum);
            this.nodeNum = nodeNum;
            


            // 初始化矩阵值
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                arcs[u] = [];
                path[u] = [];

                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    if( u != v)
                    {
                        arcs[u][v] = Number.MAX_VALUE;
                    }
                    else
                    {
                        // 同一个点，成本是0
                        arcs[u][v] = 0;
                    }
                    path[u][v] = v;
                }
            }


            this.print(arcs, nodeNum, -1);

            // 输入边
            for(let i = 0; i &lt; x.length; i ++)
            {
                let u = x[i];
                let v = y[i];
                arcs[u][v] = w[i];
                arcs[v][u] = w[i];
            }
            
            // floyd算法
            // if ( arcs[i][k]  + arcs[k][j] &lt; arcs[i][j] )
            //     arcs[i][j] = arcs[i][k] + arcs[k][j]

            for(let k = 0; k &lt; nodeNum; k ++)
            {
                for(let i = 0; i &lt; nodeNum; i ++)
                {
                    for(let j = 0; j &lt; nodeNum; j ++)
                    {
                        if( arcs[i][k] &lt; Number.MAX_VALUE && arcs[k][j] &lt; Number.MAX_VALUE )
                        {
                            let d = arcs[i][k] + arcs[k][j];
                            if(d &lt; arcs[i][j])
                            {
                                arcs[i][j] = d;
                                path[i][j] = path[i][k];
                            }
                        }
                    }
                }

                this.print(arcs, nodeNum, k);
            }
            

            // 路径字典
            let pathMap: number[][][] = this.generatePathMap(arcs, path, nodeNum);

            this.printPathMap(arcs, pathMap, nodeNum);

            this.arcs = arcs;
            this.pathMap = pathMap;
        }


        // 生存路径字典
        generatePathMap(arcs: number[][], path: number[][], nodeNum: number): number[][][]
        {
            // 路径字典
            let pathMap: number[][][] = [];
            let temp = 0;
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                pathMap[u] = [];
                let str = &quot;&quot;;
                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    let points = pathMap[u][v]=[];
                    points.push(u);
                    temp = path[u][v];
                    while(temp != v)
                    {
                        points.push(temp);
                        temp = path[temp][v];
                    }
                    points.push(v);
                }

            }

            return pathMap;
        }

        // 打印矩阵
        print(arcs: number[][], nodeNum: number, index: number)
        {
            return;
            console.log(&quot;step of %d:&quot;, index);
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                let str = &quot;&quot;;
                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    if(arcs[u][v] &lt; Number.MAX_VALUE)
                    {
                        str += arcs[u][v] + &quot;  &quot;;
                    }
                    else
                    {
                        str +=  &quot;∞  &quot;;
                    }
                }
                str += &quot;\n&quot;;
                console.log(str);
            }
        }

        // 打印路径
        printPath(arcs: number[][], path: number[][], nodeNum: number)
        {
            console.log(&quot;path:&quot;);
            let temp = 0;
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                let str = &quot;&quot;;
                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    str += u + &quot; -&gt; &quot; + v + &quot;, weight:&quot; + arcs[u][v] + &quot;:&quot; + u;

                    temp = path[u][v];
                    while(temp != v)
                    {
                        str += &quot;-&gt;&quot; + temp;
                        temp = path[temp][v];
                    }
                    str += &quot;-&gt;&quot; + v + &quot;\n&quot;;
                }

                console.log(str);

            }
        }

        // 打印路径字典
        printPathMap(arcs: number[][], pathMap: number[][][], nodeNum: number)
        {
            console.log(&quot;pathMap:&quot;);
            let temp = 0;
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                let str = &quot;&quot;;
                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    str += u + &quot; -&gt; &quot; + v + &quot;, weight:&quot; + arcs[u][v] + &quot;:&quot; ;

                    let points = pathMap[u][v];
                    if(points.length &lt; 2)
                        console;

                    str += points[0];
                    for(let i = 1; i &lt; points.length - 1; i ++)
                    {
                        str += &quot;-&gt;&quot; + points[i];
                    }

                    str += &quot;-&gt;&quot; + points[points.length - 1] + &quot;\n&quot;;
                }

                console.log(str);

            }
        }





    }
}
</pre>



## GameMain.ts


<pre class="brush: js; ">

namespace ihaiu
{

    // 程序入口
    export class GameMain
    {
        constructor()
        {

            // this.test1();
            // this.test2();
            this.test3();
            // this.test4();
        }

        test1()
        {
            let x: number[];
            let y: number[];
            let w: number[];
            let n: number;
            let m: number;

            n = 2, m = 2, x = [0, 1], y = [1, 2], w = [1, 2]; //返回2。
             
            let floyd = new Floyd();
            floyd.calculation(n, m, x, y, w);
            console.log("The minimum risk value is: %d", floyd.getPathMaxArc(0, floyd.nodeNum - 1));
       

        }

        test2()
        {
            let x: number[];
            let y: number[];
            let w: number[];
            let n: number;
            let m: number;
            n = 3, m = 4, x = [0, 0, 1, 2], y = [1, 2, 3, 3], w = [1, 2, 3, 4]; //返回3

            let floyd = new Floyd();
            floyd.calculation(n, m, x, y, w);
            console.log("The minimum risk value is: %d", floyd.getPathMaxArc(0, floyd.nodeNum - 1));
        }

        
        test3()
        {
            let x: number[];
            let y: number[];
            let w: number[];
            let n: number;
            let m: number;
            
            n = 4, m = 5, x = [0, 1, 1, 2, 3], y = [1, 2, 3, 4, 4], w = [3, 2, 4, 2, 1]; //返回3


            let floyd = new Floyd();
            floyd.calculation(n, m, x, y, w);
            console.log("The minimum risk value is: %d", floyd.getPathMaxArc(0, floyd.nodeNum - 1));
        }

        
        test4()
        {
            let x: number[];
            let y: number[];
            let w: number[];
            let n: number;
            let m: number;
            
            n = 5, m = 7, x = [0, 0, 1, 2, 3, 3, 4], y = [1, 2, 3, 4, 4, 5, 5], w = [2, 5, 3, 4, 3, 4, 1]; //返回4


            let floyd = new Floyd();
            floyd.calculation(n, m, x, y, w);
            console.log("The minimum risk value is: %d", floyd.getPathMaxArc(0, floyd.nodeNum - 1));
        }
    }

}

setTimeout(function() 
{ 
    new ihaiu.GameMain();
}, 100);

</pre>


## 日志

<pre>

pathMap:
0 -> 0, weight:0:0->0
0 -> 1, weight:3:0->1
0 -> 2, weight:5:0->1->2
0 -> 3, weight:7:0->1->3
0 -> 4, weight:7:0->1->2->4
1 -> 0, weight:3:1->0
1 -> 1, weight:0:1->1
1 -> 2, weight:2:1->2
1 -> 3, weight:4:1->3
1 -> 4, weight:4:1->2->4
2 -> 0, weight:5:2->1->0
2 -> 1, weight:2:2->1
2 -> 2, weight:0:2->2
2 -> 3, weight:3:2->4->3
2 -> 4, weight:2:2->4
3 -> 0, weight:7:3->1->0
3 -> 1, weight:4:3->1
3 -> 2, weight:3:3->4->2
3 -> 3, weight:0:3->3
3 -> 4, weight:1:3->4
4 -> 0, weight:7:4->2->1->0
4 -> 1, weight:4:4->2->1
4 -> 2, weight:2:4->2
4 -> 3, weight:1:4->3
4 -> 4, weight:0:4->4
The minimum risk value is: 3

</pre>

